{"version":3,"sources":["../../../../../src/lib/bigmath/index.ts","../../../../../src/lib/numbers/index.ts","../../../../../src/domain/sidecar/utils.ts"],"names":["bigMath"],"mappings":"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","file":"utils.js","sourcesContent":["export const bigMath = {\n  abs(x: bigint) {\n    return x < 0n ? -x : x;\n  },\n  mulDiv(x: bigint, y: bigint, z: bigint, roundUpMagnitude = false) {\n    const result = (x * y) / z;\n\n    if (roundUpMagnitude && this.mulmod(x, y, z) > 0n) {\n      return result + 1n;\n    }\n\n    return result;\n  },\n  max(max: bigint, ...rest: bigint[]) {\n    return rest.reduce((currentMax, val) => (currentMax < val ? val : currentMax), max);\n  },\n  min(min: bigint, ...rest: bigint[]) {\n    return rest.reduce((currentMin, val) => (currentMin > val ? val : currentMin), min);\n  },\n  avg(...values: (bigint | undefined)[]) {\n    let sum = 0n;\n    let count = 0n;\n    for (const value of values) {\n      if (value !== undefined) {\n        sum += value;\n        count += 1n;\n      }\n    }\n\n    if (count === 0n) {\n      return undefined;\n    }\n\n    return sum / count;\n  },\n  divRound(x: bigint, y: bigint) {\n    return x / y + ((x % y) * 2n > y ? 1n : 0n);\n  },\n  divRoundUp(x: bigint, y: bigint) {\n    return (x + y - 1n) / y;\n  },\n  mulmod(x: bigint, y: bigint, m: bigint): bigint {\n    return (x * y) % m;\n  },\n  clamp(value: bigint, min: bigint, max: bigint): bigint {\n    return bigMath.max(min, bigMath.min(value, max));\n  },\n};\n","import { formatUnits, parseUnits } from \"viem\";\n\nimport { bigMath } from \"../bigmath\";\n\nexport type Numeric = number | bigint;\nexport type BigNumberish = string | Numeric;\n\nexport const USD_DECIMALS = 30;\n\nexport const BASIS_POINTS_DIVISOR = 10000;\nexport const BASIS_POINTS_DIVISOR_BIGINT = 10000n;\nexport const BASIS_POINTS_DECIMALS = 4;\n\nexport const PRECISION_DECIMALS = 30;\nexport const PRECISION = expandDecimals(1, PRECISION_DECIMALS);\n\nexport const BN_ZERO = 0n;\nexport const BN_ONE = 1n;\nexport const BN_NEGATIVE_ONE = -1n;\n\nexport const MaxUint256 = BigInt(\n  \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n);\n\nexport const PERCENT_PRECISION_DECIMALS = PRECISION_DECIMALS - 2;\n\nconst MAX_EXCEEDING_THRESHOLD = \"1000000000\";\nconst MIN_EXCEEDING_THRESHOLD = \"0.01\";\n\nexport const TRIGGER_PREFIX_ABOVE = \">\";\nexport const TRIGGER_PREFIX_BELOW = \"<\";\n\ndeclare const __nonZero: unique symbol;\nexport type NonZero<T extends number | bigint> = T & {\n  readonly [__nonZero]: true;\n};\n\nexport function isNonZero<T extends number | bigint>(\n  value: T\n): value is NonZero<T> {\n  return value !== 0 && value !== 0n;\n}\n\nexport function safeDivide<T extends number | bigint>(a: T, b: NonZero<T>): T {\n  return (a / b) as T;\n}\n\nexport function expandDecimals(n: BigNumberish, decimals: number): bigint {\n  return BigInt(n) * 10n ** BigInt(decimals);\n}\n\nexport function basisPointsToFloat(basisPoints: bigint) {\n  return (basisPoints * PRECISION) / BASIS_POINTS_DIVISOR_BIGINT;\n}\n\nexport function getBasisPoints(\n  numerator: bigint,\n  denominator: bigint,\n  shouldRoundUp = false\n) {\n  const result = (numerator * BASIS_POINTS_DIVISOR_BIGINT) / denominator;\n\n  if (shouldRoundUp) {\n    const remainder = (numerator * BASIS_POINTS_DIVISOR_BIGINT) % denominator;\n    if (remainder !== 0n) {\n      return result < 0n ? result - 1n : result + 1n;\n    }\n  }\n\n  return result;\n}\n\nexport function roundUpMagnitudeDivision(a: bigint, b: bigint) {\n  if (a < 0n) {\n    return (a - b + 1n) / b;\n  }\n\n  return (a + b - 1n) / b;\n}\n\nexport function applyFactor(value: bigint, factor: bigint) {\n  return (value * factor) / PRECISION;\n}\n\nexport function numberToBigint(value: number, decimals: number) {\n  const negative = value < 0;\n  if (negative) value *= -1;\n\n  const int = Math.trunc(value);\n  let frac = value - int;\n\n  let res = BigInt(int);\n\n  for (let i = 0; i < decimals; i++) {\n    res *= 10n;\n    if (frac !== 0) {\n      frac *= 10;\n      const fracInt = Math.trunc(frac);\n      res += BigInt(fracInt);\n      frac -= fracInt;\n    }\n  }\n\n  return negative ? -res : res;\n}\n\nexport const trimZeroDecimals = (amount: string) => {\n  if (parseFloat(amount) === parseInt(amount)) {\n    return parseInt(amount).toString();\n  }\n  return amount;\n};\n\nexport function bigintToNumber(value: bigint, decimals: number) {\n  const negative = value < 0;\n  if (negative) value *= -1n;\n  const precision = 10n ** BigInt(decimals);\n  const int = value / precision;\n  const frac = value % precision;\n\n  const num = parseFloat(`${int}.${frac.toString().padStart(decimals, \"0\")}`);\n  return negative ? -num : num;\n}\n\nexport function adjustForDecimals(\n  amount: bigint,\n  divDecimals: number,\n  mulDecimals: number\n) {\n  return (\n    (amount * expandDecimals(1, mulDecimals)) / expandDecimals(1, divDecimals)\n  );\n}\n\nexport function formatUsd(\n  usd?: bigint,\n  opts: {\n    fallbackToZero?: boolean;\n    displayDecimals?: number;\n    maxThreshold?: string | null;\n    minThreshold?: string;\n    displayPlus?: boolean;\n    visualMultiplier?: number;\n  } = {}\n) {\n  const { fallbackToZero = false, displayDecimals = 2 } = opts;\n\n  if (typeof usd !== \"bigint\") {\n    if (fallbackToZero) {\n      usd = 0n;\n    } else {\n      return undefined;\n    }\n  }\n\n  if (opts.visualMultiplier) {\n    usd *= BigInt(opts.visualMultiplier);\n  }\n\n  const defaultMinThreshold =\n    displayDecimals > 1\n      ? \"0.\" + \"0\".repeat(displayDecimals - 1) + \"1\"\n      : undefined;\n\n  const exceedingInfo = getLimitedDisplay(usd, USD_DECIMALS, {\n    maxThreshold: opts.maxThreshold,\n    minThreshold: opts.minThreshold ?? defaultMinThreshold,\n  });\n\n  const maybePlus = opts.displayPlus ? \"+\" : \"\";\n  const sign = usd < 0n ? \"-\" : maybePlus;\n  const symbol = exceedingInfo.symbol ? `${exceedingInfo.symbol}\\u00a0` : \"\";\n  const displayUsd = formatAmount(\n    exceedingInfo.value,\n    USD_DECIMALS,\n    displayDecimals,\n    true\n  );\n  return `${symbol}${sign}$\\u200a${displayUsd}`;\n}\n\nexport function formatBigUsd(\n  amount: bigint,\n  opts: { displayDecimals?: number } = {}\n) {\n  return formatUsd(amount, {\n    maxThreshold: \"9999999999999999999999999\",\n    displayDecimals: opts.displayDecimals ?? 0,\n  });\n}\n\nexport function formatDeltaUsd(\n  deltaUsd?: bigint,\n  percentage?: bigint,\n  opts: { fallbackToZero?: boolean; showPlusForZero?: boolean } = {}\n) {\n  if (typeof deltaUsd !== \"bigint\") {\n    if (opts.fallbackToZero) {\n      return `${formatUsd(0n)} (${formatAmount(0n, 2, 2)}%)`;\n    }\n\n    return undefined;\n  }\n\n  const sign = getPlusOrMinusSymbol(deltaUsd, {\n    showPlusForZero: opts.showPlusForZero,\n  });\n\n  const exceedingInfo = getLimitedDisplay(deltaUsd, USD_DECIMALS);\n  const percentageStr =\n    percentage !== undefined\n      ? ` (${sign}${formatPercentage(bigMath.abs(percentage))})`\n      : \"\";\n  const deltaUsdStr = formatAmount(exceedingInfo.value, USD_DECIMALS, 2, true);\n  const symbol = exceedingInfo.symbol ? `${exceedingInfo.symbol} ` : \"\";\n\n  return `${symbol}${sign}$\\u200a${deltaUsdStr}${percentageStr}`;\n}\n\nexport function formatPercentage(\n  percentage?: bigint,\n  opts: {\n    fallbackToZero?: boolean;\n    signed?: boolean;\n    displayDecimals?: number;\n    bps?: boolean;\n    showPlus?: boolean;\n  } = {}\n) {\n  const {\n    fallbackToZero = false,\n    signed = false,\n    displayDecimals = 2,\n    bps = true,\n    showPlus = true,\n  } = opts;\n\n  if (percentage === undefined) {\n    if (fallbackToZero) {\n      return `${formatAmount(\n        0n,\n        PERCENT_PRECISION_DECIMALS,\n        displayDecimals\n      )}%`;\n    }\n\n    return undefined;\n  }\n\n  const sign = signed ? `${getPlusOrMinusSymbol(percentage)}` : \"\";\n  const displaySign = !showPlus && sign === \"+\" ? \"\" : `${sign}`;\n\n  return `${displaySign}${displaySign ? \"\\u200a\" : \"\"}${formatAmount(\n    bigMath.abs(percentage),\n    bps ? 2 : PERCENT_PRECISION_DECIMALS,\n    displayDecimals\n  )}%`;\n}\n\nexport function formatTokenAmount(\n  amount?: bigint,\n  tokenDecimals?: number,\n  symbol?: string,\n  opts: {\n    showAllSignificant?: boolean;\n    displayDecimals?: number;\n    fallbackToZero?: boolean;\n    useCommas?: boolean;\n    minThreshold?: string;\n    maxThreshold?: string;\n    displayPlus?: boolean;\n    isStable?: boolean;\n  } = {}\n) {\n  const {\n    showAllSignificant = false,\n    fallbackToZero = false,\n    useCommas = false,\n    minThreshold = \"0\",\n    maxThreshold,\n  } = opts;\n\n  const displayDecimals = opts.displayDecimals ?? (opts.isStable ? 2 : 4);\n\n  const symbolStr = symbol ? ` ${symbol}` : \"\";\n\n  if (typeof amount !== \"bigint\" || !tokenDecimals) {\n    if (fallbackToZero) {\n      amount = 0n;\n      tokenDecimals = displayDecimals;\n    } else {\n      return undefined;\n    }\n  }\n\n  let amountStr: string;\n\n  const maybePlus = opts.displayPlus ? \"+\" : \"\";\n  const sign = amount < 0n ? \"-\" : maybePlus;\n\n  if (showAllSignificant) {\n    amountStr = formatAmountFree(amount, tokenDecimals, tokenDecimals);\n  } else {\n    const exceedingInfo = getLimitedDisplay(amount, tokenDecimals, {\n      maxThreshold,\n      minThreshold,\n    });\n    const symbol = exceedingInfo.symbol ? `${exceedingInfo.symbol} ` : \"\";\n    amountStr = `${symbol}${sign}${formatAmount(\n      exceedingInfo.value,\n      tokenDecimals,\n      displayDecimals,\n      useCommas,\n      undefined\n    )}`;\n  }\n\n  return `${amountStr}${symbolStr}`;\n}\n\nexport function formatTokenAmountWithUsd(\n  tokenAmount?: bigint,\n  usdAmount?: bigint,\n  tokenSymbol?: string,\n  tokenDecimals?: number,\n  opts: {\n    fallbackToZero?: boolean;\n    displayDecimals?: number;\n    displayPlus?: boolean;\n    isStable?: boolean;\n  } = {}\n) {\n  if (\n    typeof tokenAmount !== \"bigint\" ||\n    typeof usdAmount !== \"bigint\" ||\n    !tokenSymbol ||\n    !tokenDecimals\n  ) {\n    if (!opts.fallbackToZero) {\n      return undefined;\n    }\n  }\n\n  const tokenStr = formatTokenAmount(tokenAmount, tokenDecimals, tokenSymbol, {\n    ...opts,\n    useCommas: true,\n    displayPlus: opts.displayPlus,\n  });\n\n  const usdStr = formatUsd(usdAmount, {\n    fallbackToZero: opts.fallbackToZero,\n    displayPlus: opts.displayPlus,\n  });\n\n  return `${tokenStr} (${usdStr})`;\n}\n\n/**\n *\n * @param opts.signed - Default `true`. whether to display a `+` or `-` sign for all non-zero values.\n */\nexport function formatRatePercentage(\n  rate?: bigint,\n  opts?: { displayDecimals?: number; signed?: boolean }\n) {\n  if (typeof rate !== \"bigint\") {\n    return \"-\";\n  }\n\n  const signed = opts?.signed ?? true;\n  const plurOrMinus = signed ? getPlusOrMinusSymbol(rate) : \"\";\n\n  const amount = bigMath.abs(rate * 100n);\n  return `${plurOrMinus}\\u200a${formatAmount(\n    amount,\n    30,\n    opts?.displayDecimals ?? 4\n  )}%`;\n}\n\nexport function formatUsdPrice(\n  price?: bigint,\n  opts: Parameters<typeof formatUsd>[1] = {}\n) {\n  if (price === undefined) {\n    return;\n  }\n\n  if (price < 0n) {\n    return \"NA\";\n  }\n\n  const decimals = calculateDisplayDecimals(\n    price,\n    undefined,\n    opts.visualMultiplier\n  );\n\n  return formatUsd(price, {\n    ...opts,\n    displayDecimals: decimals,\n  });\n}\n\nexport function formatPercentageDisplay(\n  percentage: number,\n  hideThreshold?: number\n) {\n  if (hideThreshold && percentage < hideThreshold) {\n    return \"\";\n  }\n\n  return `${percentage}%`;\n}\n\nexport function formatAmountHuman(\n  amount: BigNumberish | undefined,\n  tokenDecimals: number,\n  showDollar = false,\n  displayDecimals = 1\n) {\n  if (amount === undefined) {\n    return \"...\";\n  }\n\n  let n = Number(formatAmount(amount, tokenDecimals));\n  // For large numbers, we can neglect the decimals to avoid decimals in cases like 9999999.99999\n  if (n >= 1_000_000) {\n    n = Math.round(n);\n  }\n  const isNegative = n < 0;\n  const absN = Math.abs(n);\n  const sign = showDollar ? \"$\\u200a\" : \"\";\n\n  if (absN >= 1_000_000_000) {\n    return `${isNegative ? \"-\" : \"\"}${sign}${(absN / 1_000_000_000).toFixed(\n      displayDecimals\n    )}b`;\n  }\n\n  if (absN >= 1_000_000) {\n    return `${isNegative ? \"-\" : \"\"}${sign}${(absN / 1_000_000).toFixed(\n      displayDecimals\n    )}m`;\n  }\n\n  if (absN >= 1000) {\n    return `${isNegative ? \"-\" : \"\"}${sign}${(absN / 1_000).toFixed(\n      displayDecimals\n    )}k`;\n  }\n\n  return `${isNegative ? \"-\" : \"\"}${sign}${absN.toFixed(displayDecimals)}`;\n}\n\nexport function formatBalanceAmount(\n  amount: bigint,\n  tokenDecimals: number,\n  tokenSymbol?: string,\n  {\n    showZero = false,\n    toExponential = true,\n    isStable = false,\n    signed = false,\n  }: {\n    showZero?: boolean;\n    toExponential?: boolean;\n    isStable?: boolean;\n    signed?: boolean;\n  } = {}\n): string {\n  if (amount === undefined) return \"-\";\n\n  if (amount === 0n) {\n    if (showZero === true) {\n      if (tokenSymbol) {\n        if (isStable) {\n          return `0.00 ${tokenSymbol}`;\n        }\n        return `0.0000 ${tokenSymbol}`;\n      }\n      if (isStable) {\n        return \"0.00\";\n      }\n      return \"0.0000\";\n    }\n\n    return \"-\";\n  }\n\n  const sign = signed || amount < 0n ? getPlusOrMinusSymbol(amount) : \"\";\n  const absAmount = bigMath.abs(amount);\n  const absAmountFloat = bigintToNumber(absAmount, tokenDecimals);\n\n  let value = \"\";\n\n  const baseDecimals = isStable ? 2 : 4;\n  if (absAmountFloat >= 1)\n    value = formatAmount(absAmount, tokenDecimals, baseDecimals, true);\n  else if (absAmountFloat >= 0.1)\n    value = formatAmount(absAmount, tokenDecimals, baseDecimals + 1, true);\n  else if (absAmountFloat >= 0.01)\n    value = formatAmount(absAmount, tokenDecimals, baseDecimals + 2, true);\n  else if (absAmountFloat >= 0.001)\n    value = formatAmount(absAmount, tokenDecimals, baseDecimals + 3, true);\n  else if (absAmountFloat >= 1e-8)\n    value = formatAmount(absAmount, tokenDecimals, 8, true);\n  else {\n    if (toExponential) {\n      value = bigintToNumber(absAmount, tokenDecimals).toExponential(2);\n    } else {\n      value = bigintToNumber(absAmount, tokenDecimals).toFixed(8);\n    }\n  }\n\n  if (tokenSymbol) {\n    // Non-breaking space\n    return `${sign}${value} ${tokenSymbol}`;\n  }\n\n  return `${sign}${value}`;\n}\n\nexport function formatFactor(factor: bigint) {\n  if (factor == 0n) {\n    return \"0\";\n  }\n\n  if (bigMath.abs(factor) > PRECISION * 1000n) {\n    return (factor / PRECISION).toString();\n  }\n\n  const trailingZeroes =\n    bigMath\n      .abs(factor)\n      .toString()\n      .match(/^(.+?)(?<zeroes>0*)$/)?.groups?.zeroes?.length || 0;\n  const factorDecimals = 30 - trailingZeroes;\n  return formatAmount(factor, 30, factorDecimals);\n}\nexport function numberWithCommas(\n  x: BigNumberish,\n  { showDollar = false }: { showDollar?: boolean } = {}\n) {\n  if (x === undefined || x === null) {\n    return \"...\";\n  }\n\n  const parts = x.toString().split(\".\");\n  parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n  return `${showDollar ? \"$\\u200a\" : \"\"}${parts.join(\".\")}`;\n}\n\nexport const formatAmount = (\n  amount: BigNumberish | undefined,\n  tokenDecimals: number,\n  displayDecimals?: number,\n  useCommas?: boolean,\n  defaultValue?: string,\n  visualMultiplier?: number\n) => {\n  if (defaultValue === undefined || defaultValue === null) {\n    defaultValue = \"...\";\n  }\n  if (amount === undefined || amount === null || amount === \"\") {\n    return defaultValue;\n  }\n  if (displayDecimals === undefined) {\n    displayDecimals = 4;\n  }\n  const amountBigInt = roundWithDecimals(\n    BigInt(amount) * BigInt(visualMultiplier ?? 1),\n    {\n      displayDecimals,\n      decimals: tokenDecimals,\n    }\n  );\n  let amountStr = formatUnits(amountBigInt, tokenDecimals);\n  amountStr = limitDecimals(amountStr, displayDecimals);\n  if (displayDecimals !== 0) {\n    amountStr = padDecimals(amountStr, displayDecimals);\n  }\n  if (useCommas) {\n    return numberWithCommas(amountStr);\n  }\n  return amountStr;\n};\n\nexport const formatKeyAmount = <T extends {}>(\n  map: T | undefined,\n  key: keyof T,\n  tokenDecimals: number,\n  displayDecimals: number,\n  useCommas?: boolean\n) => {\n  const value = map ? map[key] ?? undefined : undefined;\n  if (value === undefined || value === null) {\n    return \"...\";\n  }\n\n  return formatAmount(\n    value as bigint,\n    tokenDecimals,\n    displayDecimals,\n    useCommas\n  );\n};\n\nexport const formatArrayAmount = (\n  arr: any[],\n  index: number,\n  tokenDecimals: number,\n  displayDecimals?: number,\n  useCommas?: boolean\n) => {\n  if (!arr || arr[index] === undefined || arr[index] === null) {\n    return \"...\";\n  }\n\n  return formatAmount(arr[index], tokenDecimals, displayDecimals, useCommas);\n};\n\nexport const formatAmountFree = (\n  amount: BigNumberish,\n  tokenDecimals: number,\n  displayDecimals?: number\n) => {\n  if (amount === undefined || amount === null) {\n    return \"...\";\n  }\n\n  amount = BigInt(amount);\n\n  let amountStr = formatUnits(amount, tokenDecimals);\n  amountStr = limitDecimals(amountStr, displayDecimals);\n  return trimZeroDecimals(amountStr);\n};\n\nexport function getLimitedDisplay(\n  amount: bigint,\n  tokenDecimals: number,\n  opts: { maxThreshold?: BigNumberish | null; minThreshold?: BigNumberish } = {}\n) {\n  const {\n    maxThreshold = MAX_EXCEEDING_THRESHOLD,\n    minThreshold = MIN_EXCEEDING_THRESHOLD,\n  } = opts;\n  const max =\n    maxThreshold === null\n      ? null\n      : expandDecimals(BigInt(maxThreshold), tokenDecimals);\n  const min = parseUnits(minThreshold.toString(), tokenDecimals);\n  const absAmount = bigMath.abs(amount);\n\n  if (absAmount == 0n) {\n    return {\n      symbol: \"\",\n      value: absAmount,\n    };\n  }\n\n  const symbol =\n    max !== null && absAmount > max\n      ? TRIGGER_PREFIX_ABOVE\n      : absAmount < min\n      ? TRIGGER_PREFIX_BELOW\n      : \"\";\n  const value =\n    max !== null && absAmount > max ? max : absAmount < min ? min : absAmount;\n\n  return {\n    symbol,\n    value,\n  };\n}\n\nexport const limitDecimals = (amount: BigNumberish, maxDecimals?: number) => {\n  let amountStr = amount.toString();\n  if (maxDecimals === undefined) {\n    return amountStr;\n  }\n  if (maxDecimals === 0) {\n    return amountStr.split(\".\")[0];\n  }\n  const dotIndex = amountStr.indexOf(\".\");\n  if (dotIndex !== -1) {\n    let decimals = amountStr.length - dotIndex - 1;\n    if (decimals > maxDecimals) {\n      amountStr = amountStr.substr(\n        0,\n        amountStr.length - (decimals - maxDecimals)\n      );\n    }\n  }\n\n  return amountStr;\n};\n\nexport const padDecimals = (amount: BigNumberish, minDecimals: number) => {\n  let amountStr = amount.toString();\n  const dotIndex = amountStr.indexOf(\".\");\n  if (dotIndex !== -1) {\n    const decimals = amountStr.length - dotIndex - 1;\n    if (decimals < minDecimals) {\n      amountStr = amountStr.padEnd(\n        amountStr.length + (minDecimals - decimals),\n        \"0\"\n      );\n    }\n  } else {\n    amountStr = amountStr + \".\" + \"0\".repeat(minDecimals);\n  }\n  return amountStr;\n};\n\nexport function getPlusOrMinusSymbol(\n  value?: bigint,\n  opts: { showPlusForZero?: boolean } = {}\n): string {\n  if (value === undefined) {\n    return \"\";\n  }\n\n  const { showPlusForZero = false } = opts;\n  return value === 0n ? (showPlusForZero ? \"+\" : \"\") : value < 0n ? \"-\" : \"+\";\n}\n\nexport function roundWithDecimals(\n  value: BigNumberish,\n  opts: { displayDecimals: number; decimals: number }\n): bigint {\n  if (opts.displayDecimals === opts.decimals) {\n    return BigInt(value);\n  }\n\n  let valueString = value.toString();\n  let isNegative = false;\n\n  if (valueString[0] === \"-\") {\n    valueString = valueString.slice(1);\n    isNegative = true;\n  }\n\n  if (valueString.length < opts.decimals) {\n    valueString = valueString.padStart(opts.decimals, \"0\");\n  }\n\n  const mainPart = valueString.slice(\n    0,\n    valueString.length - opts.decimals + opts.displayDecimals\n  );\n  const partToRound = valueString.slice(\n    valueString.length - opts.decimals + opts.displayDecimals\n  );\n\n  let mainPartBigInt = BigInt(mainPart);\n\n  let returnValue = mainPartBigInt;\n\n  if (partToRound.length !== 0) {\n    if (Number(partToRound[0]) >= 5) {\n      mainPartBigInt += 1n;\n    }\n\n    returnValue = BigInt(\n      mainPartBigInt.toString() +\n        new Array(partToRound.length).fill(\"0\").join(\"\")\n    );\n  }\n\n  return isNegative ? returnValue * -1n : returnValue;\n}\n\n// TODO: Remove this function\nexport function toBigNumberWithDecimals(\n  value: string,\n  decimals: number\n): bigint {\n  if (!value) return BN_ZERO;\n\n  const parts = value.split(\".\");\n  const integerPart = parts[0];\n  const decimalPart = parts.length > 1 ? parts[1] : \"\";\n\n  const paddingZeros = decimals - decimalPart.length;\n\n  if (paddingZeros >= 0) {\n    const result = integerPart + decimalPart + \"0\".repeat(paddingZeros);\n    return BigInt(result);\n  } else {\n    const result = integerPart + decimalPart.substring(0, decimals);\n    return BigInt(result);\n  }\n}\n\n/**\n *\n * @deprecated Use BigInt instead\n */\nexport function bigNumberify(n?: BigNumberish | null | undefined) {\n  try {\n    if (n === undefined) throw new Error(\"n is undefined\");\n    if (n === null) throw new Error(\"n is null\");\n\n    return BigInt(n);\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(\"bigNumberify error\", e);\n    return undefined;\n  }\n}\n\nexport const parseValue = (value: string, tokenDecimals: number) => {\n  const pValue = parseFloat(value);\n\n  if (isNaN(pValue)) {\n    return undefined;\n  }\n  value = limitDecimals(value, tokenDecimals);\n  const amount = parseUnits(value, tokenDecimals);\n  return bigNumberify(amount);\n};\n\nexport function roundUpDivision(a: bigint, b: bigint) {\n  return (a + b - 1n) / b;\n}\n\nexport function roundToTwoDecimals(n: number) {\n  return Math.round(n * 100) / 100;\n}\n\nexport function roundToOrder(n: bigint, significantDigits = 1) {\n  const decimals = Math.max(n.toString().length - significantDigits, 0);\n  return (n / expandDecimals(1, decimals)) * expandDecimals(1, decimals);\n}\n\nexport function roundBigIntToDecimals(\n  value: bigint,\n  tokenDecimals: number,\n  roundToDecimals: number\n): bigint {\n  const excessDecimals = tokenDecimals - roundToDecimals;\n  const divisor = BigInt(10 ** excessDecimals);\n  const scaledValue = value / divisor;\n  const remainder = scaledValue % 10n;\n  const roundedValue =\n    remainder >= 5n ? scaledValue + 10n - remainder : scaledValue - remainder;\n  return roundedValue * divisor;\n}\n\nexport function minBigNumber(...args: bigint[]) {\n  if (!args.length) return undefined;\n\n  return args.reduce((acc, num) => (num < acc ? num : acc), args[0]);\n}\n\nexport function maxbigint(...args: bigint[]) {\n  if (!args.length) return undefined;\n\n  return args.reduce((acc, num) => (num > acc ? num : acc), args[0]);\n}\n\nexport function removeTrailingZeros(amount: string | number) {\n  const amountWithoutZeros = Number(amount);\n  if (!amountWithoutZeros) return amount;\n  return amountWithoutZeros;\n}\n\ntype SerializedBigIntsInObject<T> = {\n  [P in keyof T]: T[P] extends bigint\n    ? { type: \"bigint\"; value: bigint }\n    : T[P] extends object\n    ? SerializedBigIntsInObject<T[P]>\n    : T[P];\n};\n\ntype DeserializeBigIntInObject<T> = {\n  [P in keyof T]: T[P] extends { type: \"bigint\"; value: bigint }\n    ? bigint\n    : T[P] extends object\n    ? DeserializeBigIntInObject<T[P]>\n    : T[P];\n};\n\nexport function serializeBigIntsInObject<T extends object>(\n  obj: T\n): SerializedBigIntsInObject<T> {\n  const result: any = Array.isArray(obj) ? [] : {};\n  for (const key in obj) {\n    const value = obj[key];\n    if (typeof value === \"bigint\") {\n      result[key] = { type: \"bigint\", value: String(value) };\n    } else if (value && typeof value === \"object\") {\n      result[key] = serializeBigIntsInObject(value);\n    } else {\n      result[key] = value;\n    }\n  }\n  return result;\n}\n\nexport function deserializeBigIntsInObject<T extends object>(\n  obj: T\n): DeserializeBigIntInObject<T> {\n  const result: any = Array.isArray(obj) ? [] : {};\n  for (const key in obj) {\n    const value = obj[key];\n    if (\n      typeof value === \"object\" &&\n      value !== null &&\n      ((\"type\" in value && value.type === \"bigint\") ||\n        (\"_type\" in value && value._type === \"BigNumber\"))\n    ) {\n      if (\"value\" in value && typeof value.value === \"string\") {\n        result[key] = BigInt(value.value);\n      } else if (\"hex\" in value && typeof value.hex === \"string\") {\n        if (value.hex.startsWith(\"-\")) {\n          result[key] = BigInt(value.hex.slice(1)) * -1n;\n        } else {\n          result[key] = BigInt(value.hex);\n        }\n      }\n    } else if (value && typeof value === \"object\") {\n      result[key] = deserializeBigIntsInObject(value);\n    } else {\n      result[key] = value;\n    }\n  }\n  return result;\n}\n\nexport function calculateDisplayDecimals(\n  price?: bigint,\n  decimals = USD_DECIMALS,\n  visualMultiplier = 1,\n  isStable = false\n) {\n  if (price === undefined || price === 0n) return 2;\n  const priceNumber = bigintToNumber(\n    bigMath.abs(price) * BigInt(visualMultiplier),\n    decimals\n  );\n\n  if (isNaN(priceNumber)) return 2;\n  if (isStable) {\n    if (priceNumber >= 0.1) return 2;\n    if (priceNumber >= 0.01) return 3;\n    if (priceNumber >= 0.001) return 4;\n    if (priceNumber >= 0.0001) return 5;\n    if (priceNumber >= 0.00001) return 6;\n    if (priceNumber >= 0.000001) return 7;\n    if (priceNumber >= 0.0000001) return 8;\n    if (priceNumber >= 0.00000001) return 9;\n  } else {\n    if (priceNumber >= 1000) return 2;\n    if (priceNumber >= 100) return 3;\n    if (priceNumber >= 1) return 4;\n    if (priceNumber >= 0.1) return 5;\n    if (priceNumber >= 0.01) return 6;\n    if (priceNumber >= 0.0001) return 7;\n    if (priceNumber >= 0.00001) return 8;\n  }\n\n  return 9;\n}\n\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(value, max));\n}\n\nexport function absDiffBps(value: bigint, base: bigint) {\n  if ((value === 0n && base !== 0n) || (value !== 0n && base === 0n)) {\n    return BASIS_POINTS_DIVISOR_BIGINT;\n  }\n\n  if (value === 0n && base === 0n) {\n    return 0n;\n  }\n\n  return bigMath.mulDiv(\n    bigMath.abs(value - base),\n    BASIS_POINTS_DIVISOR_BIGINT,\n    base\n  );\n}\n","import uniqueId from \"lodash/uniqueId\";\n\nimport { PositionOrderInfo } from \"domain/orders/types\";\nimport { bigMath } from \"lib/bigmath\";\nimport { USD_DECIMALS } from \"lib/numbers\";\nimport {\n  calculateDisplayDecimals,\n  formatAmount,\n  parseValue,\n  removeTrailingZeros,\n} from \"lib/numbers\";\n\nimport type { EntryField, InitialEntry, SidecarOrderEntryBase } from \"./types\";\n\nexport const MAX_PERCENTAGE = 100n;\nexport const PERCENTAGE_DECIMALS = 0;\n\nexport function getDefaultEntryField(\n  decimals: number | undefined,\n  { input, value, error }: Partial<EntryField> = {},\n  visualMultiplier?: number\n): EntryField {\n  let nextInput = \"\";\n  let nextValue: bigint | null = null;\n  let nextError = error ?? null;\n\n  if (input) {\n    nextInput = input;\n    nextValue = (decimals !== undefined && parseValue(input, decimals)) || null;\n    if (nextValue !== null && visualMultiplier !== undefined) {\n      nextValue = nextValue / BigInt(visualMultiplier);\n    }\n  } else if (value) {\n    nextInput = \"\";\n    if (decimals !== undefined) {\n      nextInput = String(\n        removeTrailingZeros(\n          formatAmount(\n            value,\n            decimals,\n            calculateDisplayDecimals(value, decimals, visualMultiplier),\n            undefined,\n            undefined,\n            visualMultiplier\n          )\n        )\n      );\n    }\n    nextValue = value;\n  }\n\n  return { input: nextInput, value: nextValue, error: nextError };\n}\n\nexport function getDefaultEntry<T extends SidecarOrderEntryBase>(\n  prefix: string,\n  override?: Partial<SidecarOrderEntryBase>\n): T {\n  return {\n    id: uniqueId(`${prefix}_`),\n    price: getDefaultEntryField(USD_DECIMALS),\n    sizeUsd: getDefaultEntryField(USD_DECIMALS),\n    percentage: getDefaultEntryField(PERCENTAGE_DECIMALS, {\n      value: MAX_PERCENTAGE,\n    }),\n    mode: \"keepPercentage\",\n    order: null,\n    txnType: null,\n    ...override,\n  } as T;\n}\n\nexport function prepareInitialEntries({\n  positionOrders,\n  sort = \"desc\",\n  visualMultiplier,\n}: {\n  positionOrders: PositionOrderInfo[] | undefined;\n  sort: \"desc\" | \"asc\";\n  visualMultiplier?: number;\n}): undefined | InitialEntry[] {\n  if (!positionOrders) return;\n\n  return positionOrders\n    .sort((a, b) => {\n      const [first, second] = sort === \"desc\" ? [a, b] : [b, a];\n      const diff = first.triggerPrice - second.triggerPrice;\n      if (diff > 0) return -1;\n      if (diff < 0) return 1;\n      return 0;\n    })\n    .map((order) => {\n      const entry: InitialEntry = {\n        sizeUsd: getDefaultEntryField(USD_DECIMALS, {\n          value: order.sizeDeltaUsd,\n        }),\n        price: getDefaultEntryField(\n          USD_DECIMALS,\n          { value: order.triggerPrice },\n          visualMultiplier\n        ),\n        order,\n      };\n\n      return entry;\n    });\n}\n\nexport function calculateEntryPercentage(\n  sizeUsd: bigint | null,\n  totalPositionSizeUsd: bigint | undefined\n): bigint | null {\n  if (\n    sizeUsd === undefined ||\n    sizeUsd === null ||\n    totalPositionSizeUsd === undefined ||\n    totalPositionSizeUsd <= 0\n  ) {\n    return null;\n  }\n\n  return bigMath.mulDiv(sizeUsd, MAX_PERCENTAGE, totalPositionSizeUsd);\n}\n\nexport function calculateEntrySizeUsd(\n  percentage: bigint | null,\n  totalPositionSizeUsd: bigint | undefined\n): bigint | null {\n  if (\n    percentage === undefined ||\n    percentage === null ||\n    percentage === 0n ||\n    totalPositionSizeUsd === undefined ||\n    totalPositionSizeUsd <= 0\n  ) {\n    return null;\n  }\n\n  return bigMath.mulDiv(totalPositionSizeUsd, percentage, MAX_PERCENTAGE);\n}\n\nexport function calculateEntryPrice(\n  priceValue: bigint | null,\n  visualMultiplier?: number\n): EntryField {\n  return getDefaultEntryField(\n    USD_DECIMALS,\n    { value: priceValue },\n    visualMultiplier\n  );\n}\n"]}