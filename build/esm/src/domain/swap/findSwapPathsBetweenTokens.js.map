{"version":3,"sources":["../../../../../src/lib/objects/index.ts","../../../../../src/configs/swap.ts","../../../../../src/domain/swap/findSwapPathsBetweenTokens.ts"],"names":["obj"],"mappings":"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","file":"findSwapPathsBetweenTokens.js","sourcesContent":["import isPlainObject from \"lodash/isPlainObject\";\n\nexport function setByKey<T>(obj: { [key: string]: T }, key: string, data: T) {\n  return { ...obj, [key]: data };\n}\n\nexport function updateByKey<T>(obj: { [key: string]: T }, key: string, data: Partial<T>) {\n  if (!obj[key]) return obj;\n\n  return { ...obj, [key]: { ...obj[key], ...data } };\n}\n\nexport function getByKey<T>(obj?: { [key: string]: T }, key?: string): T | undefined {\n  if (!obj || !key) return undefined;\n\n  return obj[key];\n}\n\nexport function deleteByKey<T>(obj: { [key: string]: T }, key: string) {\n  const newObj = { ...obj };\n  delete newObj[key];\n  return newObj;\n}\n\nexport function objectKeysDeep(obj: Record<string, any>, depth = 1): string[] {\n  const keys = new Set<string>();\n\n  const scanQueue: {\n    obj: Record<string, any>;\n    currentDepth: number;\n  }[] = [{ obj, currentDepth: 0 }];\n\n  while (scanQueue.length > 0) {\n    const { obj, currentDepth } = scanQueue.pop()!;\n\n    if (currentDepth > depth) {\n      continue;\n    }\n\n    for (const key of Object.keys(obj)) {\n      keys.add(key);\n\n      if (isPlainObject(obj[key])) {\n        scanQueue.push({ obj: obj[key], currentDepth: currentDepth + 1 });\n      }\n    }\n  }\n\n  return Array.from(keys);\n}\n","export const MAX_EDGE_PATH_LENGTH = 3;\nexport const DEFAULT_NAIVE_TOP_PATHS_COUNT = 3;\n","import type { SwapPaths } from \"domain/swap/types\";\nimport { objectKeysDeep } from \"lib/objects\";\n\nimport type { MarketsGraph } from \"./buildMarketsAdjacencyGraph\";\nimport { MAX_EDGE_PATH_LENGTH } from \"../../configs/swap\";\n\nexport function findSwapPathsBetweenTokens(graph: MarketsGraph): SwapPaths {\n  const swapRoutes: SwapPaths = {};\n\n  const allTokens = objectKeysDeep(graph, 1).sort();\n\n  for (const tokenAAddress of allTokens) {\n    swapRoutes[tokenAAddress] = {};\n\n    let empty = true;\n    for (const tokenBAddress of allTokens) {\n      if (\n        tokenAAddress === tokenBAddress ||\n        swapRoutes[tokenBAddress]?.[tokenAAddress]\n      ) {\n        continue;\n      }\n\n      const result: Record<string, string[]> = {};\n\n      type SwapPathNode = {\n        currentToken: string;\n        tokenPath: string[];\n      };\n\n      const searchQueue: SwapPathNode[] = [\n        {\n          currentToken: tokenAAddress,\n          tokenPath: [tokenAAddress],\n        },\n      ];\n\n      while (searchQueue.length > 0) {\n        const { currentToken, tokenPath } = searchQueue.shift()!;\n\n        // Example\n        // ... -> ANIME -> USDC -> ANIME\n        // There is only one edge from ANIME to USDC, so we skip this path\n        // Because its almost always a guaranteed loss\n        if (tokenPath.length >= 3) {\n          const lastToken = tokenPath[tokenPath.length - 1];\n          const secondLastToken = tokenPath[tokenPath.length - 2];\n          const thirdLastToken = tokenPath[tokenPath.length - 3];\n\n          if (lastToken === thirdLastToken) {\n            const lastEdge = graph[lastToken]?.[secondLastToken];\n            if (lastEdge && lastEdge.length === 1) {\n              continue;\n            }\n          }\n        }\n\n        if (tokenPath.length >= 2) {\n          const lastToken = tokenPath[tokenPath.length - 1];\n          const secondLastToken = tokenPath[tokenPath.length - 2];\n\n          if (lastToken === secondLastToken) {\n            continue;\n          }\n        }\n\n        if (currentToken === tokenBAddress) {\n          const intermediateTokenPath = tokenPath.slice(1, -1);\n          const pathKey = intermediateTokenPath.join(\",\");\n          if (!result[pathKey]) {\n            result[pathKey] = intermediateTokenPath;\n          }\n        }\n\n        if (tokenPath.length >= MAX_EDGE_PATH_LENGTH + 1) {\n          continue;\n        }\n\n        for (const nextToken in graph[currentToken]) {\n          searchQueue.push({\n            currentToken: nextToken,\n            tokenPath: [...tokenPath, nextToken],\n          });\n        }\n      }\n\n      if (Object.keys(result).length > 0) {\n        empty = false;\n        swapRoutes[tokenAAddress][tokenBAddress] = Object.values(result);\n      }\n    }\n\n    if (empty) {\n      delete swapRoutes[tokenAAddress];\n    }\n  }\n\n  return swapRoutes;\n}\n"]}