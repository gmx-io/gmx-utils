{"version":3,"sources":["../../../../../src/domain/swap/findSwapPathsBetweenTokens.ts"],"names":[],"mappings":"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","file":"findSwapPathsBetweenTokens.js","sourcesContent":["import type { SwapPaths } from \"domain/swap/types\";\nimport { objectKeysDeep } from \"lib/objects\";\n\nimport type { MarketsGraph } from \"./buildMarketsAdjacencyGraph\";\nimport { MAX_EDGE_PATH_LENGTH } from \"../../configs/swap\";\n\nexport function findSwapPathsBetweenTokens(graph: MarketsGraph): SwapPaths {\n  const swapRoutes: SwapPaths = {};\n\n  const allTokens = objectKeysDeep(graph, 1).sort();\n\n  for (const tokenAAddress of allTokens) {\n    swapRoutes[tokenAAddress] = {};\n\n    let empty = true;\n    for (const tokenBAddress of allTokens) {\n      if (\n        tokenAAddress === tokenBAddress ||\n        swapRoutes[tokenBAddress]?.[tokenAAddress]\n      ) {\n        continue;\n      }\n\n      const result: Record<string, string[]> = {};\n\n      type SwapPathNode = {\n        currentToken: string;\n        tokenPath: string[];\n      };\n\n      const searchQueue: SwapPathNode[] = [\n        {\n          currentToken: tokenAAddress,\n          tokenPath: [tokenAAddress],\n        },\n      ];\n\n      while (searchQueue.length > 0) {\n        const { currentToken, tokenPath } = searchQueue.shift()!;\n\n        // Example\n        // ... -> ANIME -> USDC -> ANIME\n        // There is only one edge from ANIME to USDC, so we skip this path\n        // Because its almost always a guaranteed loss\n        if (tokenPath.length >= 3) {\n          const lastToken = tokenPath[tokenPath.length - 1];\n          const secondLastToken = tokenPath[tokenPath.length - 2];\n          const thirdLastToken = tokenPath[tokenPath.length - 3];\n\n          if (lastToken === thirdLastToken) {\n            const lastEdge = graph[lastToken]?.[secondLastToken];\n            if (lastEdge && lastEdge.length === 1) {\n              continue;\n            }\n          }\n        }\n\n        if (tokenPath.length >= 2) {\n          const lastToken = tokenPath[tokenPath.length - 1];\n          const secondLastToken = tokenPath[tokenPath.length - 2];\n\n          if (lastToken === secondLastToken) {\n            continue;\n          }\n        }\n\n        if (currentToken === tokenBAddress) {\n          const intermediateTokenPath = tokenPath.slice(1, -1);\n          const pathKey = intermediateTokenPath.join(\",\");\n          if (!result[pathKey]) {\n            result[pathKey] = intermediateTokenPath;\n          }\n        }\n\n        if (tokenPath.length >= MAX_EDGE_PATH_LENGTH + 1) {\n          continue;\n        }\n\n        for (const nextToken in graph[currentToken]) {\n          searchQueue.push({\n            currentToken: nextToken,\n            tokenPath: [...tokenPath, nextToken],\n          });\n        }\n      }\n\n      if (Object.keys(result).length > 0) {\n        empty = false;\n        swapRoutes[tokenAAddress][tokenBAddress] = Object.values(result);\n      }\n    }\n\n    if (empty) {\n      delete swapRoutes[tokenAAddress];\n    }\n  }\n\n  return swapRoutes;\n}\n"]}