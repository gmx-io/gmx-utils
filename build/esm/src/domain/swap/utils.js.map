{"version":3,"sources":["../../../../../src/domain/swap/utils.ts"],"names":[],"mappings":";;;;;;AAeO,SAAS,YAAA,CAAa;AAAA,EAC3B,MAAA;AAAA,EACA,UAAA;AAAA,EACA,eAAA;AAAA,EACA,eAAA;AAAA,EACA;AACF,CAAA,EAMG;AACD,EAAA,IAAI,MAAA,EAAQ;AACV,IAAA,IAAI,CAAC,aAAa,OAAO,MAAA;AACzB,IAAA,OAAO,WAAA,CAAY,YAAA,CAAa,aAAA,EAAe,QAAA,CAAS,MAAA,IAAU,CAAA;AAAA,EACpE,WAAW,UAAA,EAAY;AACrB,IAAA,IAAI,CAAC,iBAAiB,OAAO,MAAA;AAC7B,IAAA,OAAO,eAAA,CAAgB,YAAA,CAAa,aAAA,EAAe,QAAA,CAAS,MAAA,IAAU,CAAA;AAAA,EACxE,CAAA,MAAO;AACL,IAAA,IAAI,eAAA,EAAiB,gBAAA,KAAqB,MAAA,EAAW,OAAO,MAAA;AAC5D,IAAA,OAAO,eAAA,CAAgB,gBAAA,KAAqB,wBAAA,CAAyB,MAAA,GACjE,CAAA,GACA,CAAA;AAAA,EACN;AACF;AAEO,SAAS,wBAAwB,CAAA,EAKxB;AACd,EAAA,MAAM,EAAE,SAAA,EAAW,OAAA,EAAS,eAAA,EAAiB,eAAc,GAAI,CAAA;AAE/D,EAAA,MAAM,qBACH,eAAA,GAAkB,SAAA,GAAa,cAAA,CAAe,CAAA,EAAG,UAAU,QAAQ,CAAA;AACtE,EAAA,MAAM,mBACH,aAAA,GAAgB,SAAA,GAAa,cAAA,CAAe,CAAA,EAAG,QAAQ,QAAQ,CAAA;AAElE,EAAA,MAAM,CAAC,aAAA,EAAe,YAAA,EAAc,eAAe,cAAc,CAAA,GAC/D,qBAAqB,gBAAA,GACjB,CAAC,SAAA,EAAW,OAAA,EAAS,oBAAoB,gBAAgB,CAAA,GACzD,CAAC,OAAA,EAAS,SAAA,EAAW,kBAAkB,kBAAkB,CAAA;AAE/D,EAAA,MAAM,KAAA,GACJ,cAAA,GAAiB,CAAA,GAAK,aAAA,GAAgB,YAAa,cAAA,GAAiB,EAAA;AAEtE,EAAA,OAAO,EAAE,KAAA,EAAO,YAAA,EAAc,aAAA,EAAc;AAC9C;AAEO,SAAS,+CAA+C,CAAA,EAOpC;AACzB,EAAA,MAAM;AAAA,IACJ,SAAA;AAAA,IACA,OAAA;AAAA,IACA,eAAA;AAAA,IACA,aAAA;AAAA,IACA,YAAA;AAAA,IACA;AAAA,GACF,GAAI,CAAA;AAEJ,EAAA,IAAI,sBAAA,GAAyB,iCAAA;AAC7B,EAAA,IAAI,aAAA,GAAgB,SAAA;AACpB,EAAA,IAAI,YAAA,GAAe,OAAA;AACnB,EAAA,IAAI,aAAA,GAAgB,eAAA;AACpB,EAAA,IAAI,cAAA,GAAiB,aAAA;AACrB,EAAA,IAAI,eAAA,GAAkB,EAAA;AACtB,EAAA,IAAI,KAAA,GAAQ,EAAA;AAEZ,EAAA,MAAM,qBACH,eAAA,GAAkB,SAAA,GAAa,cAAA,CAAe,CAAA,EAAG,UAAU,QAAQ,CAAA;AACtE,EAAA,MAAM,mBACH,eAAA,GAAkB,SAAA,GAAa,cAAA,CAAe,CAAA,EAAG,QAAQ,QAAQ,CAAA;AACpE,EAAA,MAAM,0BACH,eAAA,GAAkB,SAAA,GAAa,cAAA,CAAe,CAAA,EAAG,QAAQ,QAAQ,CAAA;AAEpE,EAAA,CAAC,eAAe,YAAA,EAAc,aAAA,EAAe,cAAc,CAAA,GACzD,qBAAqB,gBAAA,GACjB,CAAC,SAAA,EAAW,OAAA,EAAS,oBAAoB,gBAAgB,CAAA,GACzD,CAAC,OAAA,EAAS,SAAA,EAAW,kBAAkB,kBAAkB,CAAA;AAC/D,EAAA,KAAA,GACE,cAAA,GAAiB,CAAA,GAAK,aAAA,GAAgB,SAAA,GAAa,cAAA,GAAiB,EAAA;AAEtE,EAAA,IAAI,iBAAiB,EAAA,EAAI;AACvB,IAAA,sBAAA,GAAyB,iCAAA;AACzB,IAAA,eAAA,GAAkB,KAAA;AAAA,EACpB,CAAA,MAAO;AACL,IAAA,MAAM,uBACJ,kBAAA,GAAqB,gBAAA,GAChB,qBAAqB,SAAA,GAAa,YAAA,GAClC,qBAAqB,YAAA,GAAgB,SAAA;AAE5C,IAAA,sBAAA,GAAA,CACI,oBAAA,GAAuB,2BACvB,2BAAA,GACF,oBAAA;AACF,IAAA,eAAA,GAAkB,KAAA;AAClB,IAAA,KAAA,GAAQ,YAAA;AAAA,EACV;AAEA,EAAA,OAAO;AAAA,IACL,KAAA;AAAA,IACA,YAAA;AAAA,IACA,aAAA;AAAA,IACA,sBAAA;AAAA,IACA;AAAA,GACF;AACF;AAEO,SAAS,iBAAiB,CAAA,EAO9B;AACD,EAAA,MAAM;AAAA,IACJ,SAAA;AAAA,IACA,OAAA;AAAA,IACA,eAAA;AAAA,IACA,KAAA;AAAA,IACA,iBAAA;AAAA,IACA;AAAA,GACF,GAAI,CAAA;AAEJ,EAAA,IAAI,qBAAA,CAAsB,SAAA,EAAW,OAAO,CAAA,IAAK,oBAAoB,EAAA,EAAI;AACvE,IAAA,OAAO,CAAA,CAAE,eAAA;AAAA,EACX;AAEA,EAAA,MAAM,MAAA,GAAS,iBAAA,GAAqB,SAAA,GAAY,SAAA,GAAa,KAAA,GAAQ,KAAA;AAErE,EAAA,MAAM,qBAAA,GAAwB,iBAAA;AAAA,IAC5B,MAAA;AAAA,IACA,SAAA,CAAU,QAAA;AAAA,IACV,OAAA,CAAQ;AAAA,GACV;AACA,EAAA,MAAM,MAAA,GAAU,CAAA,CAAE,eAAA,GAAkB,qBAAA,GAAyB,SAAA;AAE7D,EAAA,MAAM,kBAAA,GACJ,sBAAA,KAA2B,MAAA,GACvB,OAAA,CAAQ,MAAA;AAAA,IACN,MAAA;AAAA,IACA,sBAAA;AAAA,IACA;AAAA,GACF,GACA,EAAA;AAEN,EAAA,OAAO,MAAA,GAAS,kBAAA;AAClB;AAEO,SAAS,sBAAsB,CAAA,EAKtB;AACd,EAAA,MAAM,EAAE,SAAA,EAAW,OAAA,EAAS,SAAA,EAAW,SAAQ,GAAI,CAAA;AAEnD,EAAA,MAAM,CAAC,YAAA,EAAc,aAAA,EAAe,cAAc,aAAa,CAAA,GAC7D,YAAY,OAAA,GACR,CAAC,SAAA,EAAW,OAAA,EAAS,WAAW,OAAO,CAAA,GACvC,CAAC,OAAA,EAAS,SAAA,EAAW,SAAS,SAAS,CAAA;AAE7C,EAAA,MAAM,KAAA,GAAS,eAAe,SAAA,GAAa,aAAA;AAE3C,EAAA,OAAO,EAAE,KAAA,EAAO,YAAA,EAAc,aAAA,EAAc;AAC9C","file":"utils.js","sourcesContent":["import { DEFAULT_ALLOWED_SWAP_SLIPPAGE_BPS } from \"configs/factors\";\nimport { DecreasePositionSwapType } from \"domain/decrease/types\";\nimport { DecreasePositionAmounts } from \"domain/decrease/types\";\nimport { IncreasePositionAmounts } from \"domain/increase/types\";\nimport {\n  SwapAmounts,\n  TokensRatio,\n  TokensRatioAndSlippage,\n} from \"domain/swap/types\";\nimport { Token } from \"domain/tokens/types\";\nimport { getIsEquivalentTokens } from \"domain/tokens/utils\";\nimport { bigMath } from \"lib/bigmath\";\nimport { BASIS_POINTS_DIVISOR_BIGINT } from \"lib/numbers\";\nimport { adjustForDecimals, expandDecimals, PRECISION } from \"lib/numbers\";\n\nexport function getSwapCount({\n  isSwap,\n  isIncrease,\n  increaseAmounts,\n  decreaseAmounts,\n  swapAmounts,\n}: {\n  isSwap: boolean;\n  isIncrease: boolean;\n  swapAmounts?: SwapAmounts;\n  increaseAmounts?: IncreasePositionAmounts;\n  decreaseAmounts?: DecreasePositionAmounts;\n}) {\n  if (isSwap) {\n    if (!swapAmounts) return undefined;\n    return swapAmounts.swapStrategy.swapPathStats?.swapPath.length ?? 0;\n  } else if (isIncrease) {\n    if (!increaseAmounts) return undefined;\n    return increaseAmounts.swapStrategy.swapPathStats?.swapPath.length ?? 0;\n  } else {\n    if (decreaseAmounts?.decreaseSwapType === undefined) return undefined;\n    return decreaseAmounts.decreaseSwapType !== DecreasePositionSwapType.NoSwap\n      ? 1\n      : 0;\n  }\n}\n\nexport function getTokensRatioByAmounts(p: {\n  fromToken: Token;\n  toToken: Token;\n  fromTokenAmount: bigint;\n  toTokenAmount: bigint;\n}): TokensRatio {\n  const { fromToken, toToken, fromTokenAmount, toTokenAmount } = p;\n\n  const adjustedFromAmount =\n    (fromTokenAmount * PRECISION) / expandDecimals(1, fromToken.decimals);\n  const adjustedToAmount =\n    (toTokenAmount * PRECISION) / expandDecimals(1, toToken.decimals);\n\n  const [smallestToken, largestToken, largestAmount, smallestAmount] =\n    adjustedFromAmount > adjustedToAmount\n      ? [fromToken, toToken, adjustedFromAmount, adjustedToAmount]\n      : [toToken, fromToken, adjustedToAmount, adjustedFromAmount];\n\n  const ratio =\n    smallestAmount > 0 ? (largestAmount * PRECISION) / smallestAmount : 0n;\n\n  return { ratio, largestToken, smallestToken };\n}\n\nexport function getTokensRatioByMinOutputAmountAndTriggerPrice(p: {\n  fromToken: Token;\n  toToken: Token;\n  fromTokenAmount: bigint;\n  toTokenAmount: bigint;\n  triggerPrice: bigint;\n  minOutputAmount: bigint;\n}): TokensRatioAndSlippage {\n  const {\n    fromToken,\n    toToken,\n    fromTokenAmount,\n    toTokenAmount,\n    triggerPrice,\n    minOutputAmount,\n  } = p;\n\n  let allowedSwapSlippageBps = DEFAULT_ALLOWED_SWAP_SLIPPAGE_BPS;\n  let smallestToken = fromToken;\n  let largestToken = toToken;\n  let largestAmount = fromTokenAmount;\n  let smallestAmount = toTokenAmount;\n  let acceptablePrice = 0n;\n  let ratio = 0n;\n\n  const adjustedFromAmount =\n    (fromTokenAmount * PRECISION) / expandDecimals(1, fromToken.decimals);\n  const adjustedToAmount =\n    (minOutputAmount * PRECISION) / expandDecimals(1, toToken.decimals);\n  const adjustedMinOutputAmount =\n    (minOutputAmount * PRECISION) / expandDecimals(1, toToken.decimals);\n\n  [smallestToken, largestToken, largestAmount, smallestAmount] =\n    adjustedFromAmount > adjustedToAmount\n      ? [fromToken, toToken, adjustedFromAmount, adjustedToAmount]\n      : [toToken, fromToken, adjustedToAmount, adjustedFromAmount];\n  ratio =\n    smallestAmount > 0 ? (largestAmount * PRECISION) / smallestAmount : 0n;\n\n  if (triggerPrice === 0n) {\n    allowedSwapSlippageBps = DEFAULT_ALLOWED_SWAP_SLIPPAGE_BPS;\n    acceptablePrice = ratio;\n  } else {\n    const outputAtTriggerPrice =\n      adjustedFromAmount > adjustedToAmount\n        ? (adjustedFromAmount * PRECISION) / triggerPrice\n        : (adjustedFromAmount * triggerPrice) / PRECISION;\n\n    allowedSwapSlippageBps =\n      ((outputAtTriggerPrice - adjustedMinOutputAmount) *\n        BASIS_POINTS_DIVISOR_BIGINT) /\n      outputAtTriggerPrice;\n    acceptablePrice = ratio;\n    ratio = triggerPrice;\n  }\n\n  return {\n    ratio,\n    largestToken,\n    smallestToken,\n    allowedSwapSlippageBps,\n    acceptablePrice,\n  };\n}\n\nexport function getAmountByRatio(p: {\n  fromToken: Token;\n  toToken: Token;\n  fromTokenAmount: bigint;\n  ratio: bigint;\n  shouldInvertRatio?: boolean;\n  allowedSwapSlippageBps?: bigint;\n}) {\n  const {\n    fromToken,\n    toToken,\n    fromTokenAmount,\n    ratio,\n    shouldInvertRatio,\n    allowedSwapSlippageBps,\n  } = p;\n\n  if (getIsEquivalentTokens(fromToken, toToken) || fromTokenAmount === 0n) {\n    return p.fromTokenAmount;\n  }\n\n  const _ratio = shouldInvertRatio ? (PRECISION * PRECISION) / ratio : ratio;\n\n  const adjustedDecimalsRatio = adjustForDecimals(\n    _ratio,\n    fromToken.decimals,\n    toToken.decimals\n  );\n  const amount = (p.fromTokenAmount * adjustedDecimalsRatio) / PRECISION;\n\n  const swapSlippageAmount =\n    allowedSwapSlippageBps !== undefined\n      ? bigMath.mulDiv(\n          amount,\n          allowedSwapSlippageBps,\n          BASIS_POINTS_DIVISOR_BIGINT\n        )\n      : 0n;\n\n  return amount - swapSlippageAmount;\n}\n\nexport function getTokensRatioByPrice(p: {\n  fromToken: Token;\n  toToken: Token;\n  fromPrice: bigint;\n  toPrice: bigint;\n}): TokensRatio {\n  const { fromToken, toToken, fromPrice, toPrice } = p;\n\n  const [largestToken, smallestToken, largestPrice, smallestPrice] =\n    fromPrice > toPrice\n      ? [fromToken, toToken, fromPrice, toPrice]\n      : [toToken, fromToken, toPrice, fromPrice];\n\n  const ratio = (largestPrice * PRECISION) / smallestPrice;\n\n  return { ratio, largestToken, smallestToken };\n}\n"]}