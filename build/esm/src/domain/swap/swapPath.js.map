{"version":3,"sources":["../../../../../src/domain/swap/swapPath.ts"],"names":[],"mappings":"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","file":"swapPath.js","sourcesContent":["import { MarketConfig, MARKETS } from \"configs/markets\";\nimport {\n  convertTokenAddress,\n  getWrappedToken,\n  NATIVE_TOKEN_ADDRESS,\n} from \"configs/tokens\";\nimport { GasLimitsConfig } from \"domain/executionFee/types\";\nimport { MarketsInfoData } from \"domain/markets/types\";\nimport { getIsMarketAvailableForExpressSwaps } from \"domain/markets/utils\";\nimport { FindSwapPath, SwapPathStats } from \"domain/swap/types\";\nimport { TokensData } from \"domain/tokens/types\";\nimport { LRUCache } from \"lib/LruCache\";\n\nimport {\n  buildMarketsAdjacencyGraph,\n  MarketsGraph,\n} from \"./buildMarketsAdjacencyGraph\";\nimport {\n  createMarketEdgeLiquidityGetter,\n  createNaiveNetworkEstimator,\n  createNaiveSwapEstimator,\n  createSwapEstimator,\n  getBestSwapPath,\n  getMarketAdjacencyGraph,\n  getMaxLiquidityMarketSwapPathFromTokenSwapPaths,\n  getNaiveBestMarketSwapPathsFromTokenSwapPaths,\n  getTokenSwapPathsForTokenPairPrebuilt,\n  marketRouteToMarketEdges,\n} from \"./swapRouting\";\nimport { getSwapPathStats } from \"./swapStats\";\n\nexport const getWrappedAddress = (\n  chainId: number,\n  address: string | undefined\n) => {\n  return address ? convertTokenAddress(chainId, address, \"wrapped\") : undefined;\n};\n\nconst DEBUG_MARKET_ADJACENCY_GRAPH_CACHE = new LRUCache<MarketsGraph>(100);\n\nfunction buildMarketAdjacencyGraph(\n  chainId: number,\n  disabledMarkets?: string[] | undefined\n) {\n  if (!disabledMarkets?.length) {\n    return getMarketAdjacencyGraph(chainId);\n  }\n\n  const cacheKey = `${chainId}-${JSON.stringify(disabledMarkets)}`;\n\n  const cachedGraph = DEBUG_MARKET_ADJACENCY_GRAPH_CACHE.get(cacheKey);\n\n  if (cachedGraph) {\n    return cachedGraph;\n  }\n\n  const disabledMarketAddresses = disabledMarkets;\n\n  const strippedMarkets = Object.fromEntries(\n    Object.entries(MARKETS[chainId]).filter(\n      ([marketAddress]) => !disabledMarketAddresses.includes(marketAddress)\n    )\n  );\n\n  const graph = buildMarketsAdjacencyGraph(\n    strippedMarkets as Record<string, MarketConfig>\n  );\n\n  DEBUG_MARKET_ADJACENCY_GRAPH_CACHE.set(cacheKey, graph);\n\n  return graph;\n}\n\nconst FALLBACK_FIND_SWAP_PATH: FindSwapPath = () => undefined;\n\nexport const createFindSwapPath = (params: {\n  chainId: number;\n  fromTokenAddress: string | undefined;\n  toTokenAddress: string | undefined;\n  marketsInfoData: MarketsInfoData | undefined;\n  /**\n   * Pass gas limits to take into account gas costs in swap path\n   */\n  gasEstimationParams?:\n    | {\n        gasPrice: bigint;\n        gasLimits: GasLimitsConfig;\n        tokensData: TokensData;\n      }\n    | undefined;\n  isExpressFeeSwap: boolean | undefined;\n  disabledMarkets?: string[] | undefined;\n  manualPath?: string[] | undefined;\n}): FindSwapPath => {\n  const {\n    chainId,\n    fromTokenAddress,\n    toTokenAddress,\n    marketsInfoData,\n    disabledMarkets,\n    manualPath,\n    gasEstimationParams,\n    isExpressFeeSwap,\n  } = params;\n  const wrappedFromAddress = getWrappedAddress(chainId, fromTokenAddress);\n  const wrappedToAddress = getWrappedAddress(chainId, toTokenAddress);\n  const wrappedToken = getWrappedToken(chainId);\n\n  let tokenSwapPaths =\n    wrappedFromAddress && wrappedToAddress\n      ? getTokenSwapPathsForTokenPairPrebuilt(\n          chainId,\n          wrappedFromAddress,\n          wrappedToAddress\n        )\n      : [];\n\n  const finalDisabledMarkets = [...(disabledMarkets ?? [])];\n\n  if (isExpressFeeSwap) {\n    const expressSwapUnavailableMarkets = Object.values(marketsInfoData ?? {})\n      .filter((market) => !getIsMarketAvailableForExpressSwaps(market))\n      .map((market) => market.marketTokenAddress);\n\n    finalDisabledMarkets.push(...expressSwapUnavailableMarkets);\n  }\n\n  const isAtomicSwap = Boolean(isExpressFeeSwap);\n\n  const marketAdjacencyGraph = buildMarketAdjacencyGraph(\n    chainId,\n    finalDisabledMarkets\n  );\n\n  const cache: Record<string, SwapPathStats | undefined> = {};\n\n  if (!marketsInfoData) {\n    return FALLBACK_FIND_SWAP_PATH;\n  }\n\n  const marketEdgeLiquidityGetter =\n    createMarketEdgeLiquidityGetter(marketsInfoData);\n  const naiveEstimator = createNaiveSwapEstimator(\n    marketsInfoData,\n    isAtomicSwap\n  );\n  const naiveNetworkEstimator = gasEstimationParams\n    ? createNaiveNetworkEstimator({\n        gasLimits: gasEstimationParams.gasLimits,\n        tokensData: gasEstimationParams.tokensData,\n        gasPrice: gasEstimationParams.gasPrice,\n        chainId,\n      })\n    : undefined;\n  const estimator = createSwapEstimator(marketsInfoData, isAtomicSwap);\n\n  const findSwapPath: FindSwapPath = (\n    usdIn: bigint,\n    opts?: { order?: (\"liquidity\" | \"length\")[] }\n  ) => {\n    if (\n      tokenSwapPaths.length === 0 ||\n      !fromTokenAddress ||\n      !wrappedFromAddress ||\n      !wrappedToAddress\n    ) {\n      return undefined;\n    }\n\n    const cacheKey = `${usdIn}-${opts?.order?.join(\"-\") || \"none\"}`;\n    if (cache[cacheKey]) {\n      return cache[cacheKey];\n    }\n\n    let swapPath: string[] | undefined = undefined;\n\n    if (manualPath !== undefined) {\n      swapPath = manualPath;\n    } else if (opts?.order || usdIn === 0n) {\n      const primaryOrder =\n        opts?.order?.at(0) === \"length\" ? \"length\" : \"liquidity\";\n\n      if (!marketEdgeLiquidityGetter) {\n        swapPath = undefined;\n      } else {\n        let applicableTokenSwapPaths = tokenSwapPaths;\n\n        if (primaryOrder === \"length\") {\n          const shortestLength = Math.min(\n            ...tokenSwapPaths.map((path) => path.length)\n          );\n          applicableTokenSwapPaths = tokenSwapPaths.filter(\n            (path) => path.length === shortestLength\n          );\n        }\n\n        const maxLiquidityPathInfo =\n          getMaxLiquidityMarketSwapPathFromTokenSwapPaths({\n            graph: marketAdjacencyGraph,\n            tokenSwapPaths: applicableTokenSwapPaths,\n            tokenInAddress: wrappedFromAddress,\n            tokenOutAddress: wrappedToAddress,\n            getLiquidity: marketEdgeLiquidityGetter,\n          });\n\n        if (maxLiquidityPathInfo) {\n          swapPath = maxLiquidityPathInfo.path;\n        }\n      }\n    } else {\n      if (naiveEstimator) {\n        const naiveSwapRoutes = getNaiveBestMarketSwapPathsFromTokenSwapPaths({\n          graph: marketAdjacencyGraph,\n          tokenSwapPaths,\n          usdIn,\n          tokenInAddress: wrappedFromAddress,\n          tokenOutAddress: wrappedToAddress,\n          estimator: naiveEstimator,\n          networkEstimator: naiveNetworkEstimator,\n        });\n\n        if (naiveSwapRoutes?.length) {\n          const edges = naiveSwapRoutes.map((path) =>\n            marketRouteToMarketEdges(path, wrappedFromAddress, marketsInfoData)\n          );\n\n          swapPath = getBestSwapPath({\n            routes: edges,\n            usdIn,\n            estimator,\n            networkEstimator: naiveNetworkEstimator,\n          })?.map((edge) => edge.marketAddress);\n        }\n      }\n    }\n\n    if (!swapPath) {\n      cache[cacheKey] = undefined;\n      return undefined;\n    }\n\n    let result: SwapPathStats | undefined = getSwapPathStats({\n      marketsInfoData,\n      swapPath,\n      initialCollateralAddress: fromTokenAddress,\n      wrappedNativeTokenAddress: wrappedToken.address,\n      shouldUnwrapNativeToken: toTokenAddress === NATIVE_TOKEN_ADDRESS,\n      shouldApplyPriceImpact: true,\n      usdIn,\n      isAtomicSwap,\n    });\n\n    cache[cacheKey] = result;\n\n    return result;\n  };\n\n  return findSwapPath;\n};\n"]}