{"version":3,"sources":["../../../../../src/lib/objects/index.ts","../../../../../src/configs/swap.ts","../../../../../src/domain/swap/findReachableTokens.ts"],"names":["obj"],"mappings":";;;AAwBO,SAAS,cAAA,CAAe,GAAA,EAA0B,KAAA,GAAQ,CAAA,EAAa;AAC5E,EAAA,MAAM,IAAA,uBAAW,GAAA,EAAY;AAE7B,EAAA,MAAM,YAGA,CAAC,EAAE,GAAA,EAAK,YAAA,EAAc,GAAG,CAAA;AAE/B,EAAA,OAAO,SAAA,CAAU,SAAS,CAAA,EAAG;AAC3B,IAAA,MAAM,EAAE,GAAA,EAAAA,IAAAA,EAAK,YAAA,EAAa,GAAI,UAAU,GAAA,EAAI;AAE5C,IAAA,IAAI,eAAe,KAAA,EAAO;AACxB,MAAA;AAAA,IACF;AAEA,IAAA,KAAA,MAAW,GAAA,IAAO,MAAA,CAAO,IAAA,CAAKA,IAAG,CAAA,EAAG;AAClC,MAAA,IAAA,CAAK,IAAI,GAAG,CAAA;AAEZ,MAAA,IAAI,aAAA,CAAcA,IAAAA,CAAI,GAAG,CAAC,CAAA,EAAG;AAC3B,QAAA,SAAA,CAAU,IAAA,CAAK,EAAE,GAAA,EAAKA,IAAAA,CAAI,GAAG,CAAA,EAAG,YAAA,EAAc,YAAA,GAAe,CAAA,EAAG,CAAA;AAAA,MAClE;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AACxB;;;ACjDO,IAAM,oBAAA,GAAuB,CAAA;;;ACK7B,SAAS,oBACd,KAAA,EAC0B;AAC1B,EAAA,MAAM,kBAA4C,EAAC;AAEnD,EAAA,MAAM,SAAA,GAAY,cAAA,CAAe,KAAA,EAAO,CAAC,EAAE,IAAA,EAAK;AAEhD,EAAA,KAAA,MAAW,cAAc,SAAA,EAAW;AAMlC,IAAA,MAAM,WAAA,GAAkC;AAAA,MACtC;AAAA,QACE,YAAA,EAAc,UAAA;AAAA,QACd,UAAA,EAAY;AAAA;AACd,KACF;AACA,IAAA,MAAM,aAAA,uBAAoB,GAAA,EAAY;AAEtC,IAAA,OAAO,WAAA,CAAY,SAAS,CAAA,EAAG;AAC7B,MAAA,MAAM,EAAE,YAAA,EAAc,UAAA,EAAW,GAAI,YAAY,KAAA,EAAM;AAEvD,MAAA,IAAI,aAAA,CAAc,GAAA,CAAI,YAAY,CAAA,EAAG;AACnC,QAAA;AAAA,MACF;AAEA,MAAA,aAAA,CAAc,IAAI,YAAY,CAAA;AAE9B,MAAA,IAAI,cAAc,oBAAA,EAAsB;AACtC,QAAA;AAAA,MACF;AAEA,MAAA,KAAA,MAAW,SAAA,IAAa,KAAA,CAAM,YAAY,CAAA,EAAG;AAC3C,QAAA,WAAA,CAAY,IAAA,CAAK;AAAA,UACf,YAAA,EAAc,SAAA;AAAA,UACd,YAAY,UAAA,GAAa;AAAA,SAC1B,CAAA;AAAA,MACH;AAAA,IACF;AAEA,IAAA,eAAA,CAAgB,UAAU,CAAA,GAAI,KAAA,CAAM,IAAA,CAAK,aAAa,CAAA;AAAA,EACxD;AAEA,EAAA,OAAO,eAAA;AACT","file":"findReachableTokens.js","sourcesContent":["import isPlainObject from \"lodash/isPlainObject\";\n\nexport function setByKey<T>(obj: { [key: string]: T }, key: string, data: T) {\n  return { ...obj, [key]: data };\n}\n\nexport function updateByKey<T>(obj: { [key: string]: T }, key: string, data: Partial<T>) {\n  if (!obj[key]) return obj;\n\n  return { ...obj, [key]: { ...obj[key], ...data } };\n}\n\nexport function getByKey<T>(obj?: { [key: string]: T }, key?: string): T | undefined {\n  if (!obj || !key) return undefined;\n\n  return obj[key];\n}\n\nexport function deleteByKey<T>(obj: { [key: string]: T }, key: string) {\n  const newObj = { ...obj };\n  delete newObj[key];\n  return newObj;\n}\n\nexport function objectKeysDeep(obj: Record<string, any>, depth = 1): string[] {\n  const keys = new Set<string>();\n\n  const scanQueue: {\n    obj: Record<string, any>;\n    currentDepth: number;\n  }[] = [{ obj, currentDepth: 0 }];\n\n  while (scanQueue.length > 0) {\n    const { obj, currentDepth } = scanQueue.pop()!;\n\n    if (currentDepth > depth) {\n      continue;\n    }\n\n    for (const key of Object.keys(obj)) {\n      keys.add(key);\n\n      if (isPlainObject(obj[key])) {\n        scanQueue.push({ obj: obj[key], currentDepth: currentDepth + 1 });\n      }\n    }\n  }\n\n  return Array.from(keys);\n}\n","export const MAX_EDGE_PATH_LENGTH = 3;\nexport const DEFAULT_NAIVE_TOP_PATHS_COUNT = 3;\n","import { objectKeysDeep } from \"lib/objects\";\n\nimport type { MarketsGraph } from \"./buildMarketsAdjacencyGraph\";\nimport { MAX_EDGE_PATH_LENGTH } from \"../../configs/swap\";\n\nexport function findReachableTokens(\n  graph: MarketsGraph\n): Record<string, string[]> {\n  const reachableTokens: Record<string, string[]> = {};\n\n  const allTokens = objectKeysDeep(graph, 1).sort();\n\n  for (const startToken of allTokens) {\n    type TokenSearchState = {\n      currentToken: string;\n      pathLength: number;\n    };\n\n    const searchQueue: TokenSearchState[] = [\n      {\n        currentToken: startToken,\n        pathLength: 0,\n      },\n    ];\n    const visitedTokens = new Set<string>();\n\n    while (searchQueue.length > 0) {\n      const { currentToken, pathLength } = searchQueue.shift()!;\n\n      if (visitedTokens.has(currentToken)) {\n        continue;\n      }\n\n      visitedTokens.add(currentToken);\n\n      if (pathLength >= MAX_EDGE_PATH_LENGTH) {\n        continue;\n      }\n\n      for (const nextToken in graph[currentToken]) {\n        searchQueue.push({\n          currentToken: nextToken,\n          pathLength: pathLength + 1,\n        });\n      }\n    }\n\n    reachableTokens[startToken] = Array.from(visitedTokens);\n  }\n\n  return reachableTokens;\n}\n"]}