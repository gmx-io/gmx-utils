{"version":3,"sources":["../../../../../src/domain/swap/swapStats.ts"],"names":["capacityUsd","swapFeeUsd","usdInAfterFees","isOutCapacity"],"mappings":"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","file":"swapStats.js","sourcesContent":["import { maxUint256 } from \"viem\";\n\nimport { NATIVE_TOKEN_ADDRESS } from \"configs/tokens\";\nimport {\n  applySwapImpactWithCap,\n  getPriceImpactForSwap,\n  getSwapFee,\n} from \"domain/executionFee\";\nimport { MarketInfo, MarketsInfoData } from \"domain/markets/types\";\nimport {\n  getAvailableUsdLiquidityForCollateral,\n  getOppositeCollateral,\n  getTokenPoolType,\n} from \"domain/markets/utils\";\nimport { SwapPathStats, SwapStats } from \"domain/swap/types\";\nimport {\n  convertToTokenAmount,\n  convertToUsd,\n  getMidPrice,\n} from \"domain/tokens/utils\";\nimport { getByKey } from \"lib/objects\";\n\nexport function getSwapCapacityUsd(marketInfo: MarketInfo, isLong: boolean) {\n  const poolAmount = isLong\n    ? marketInfo.longPoolAmount\n    : marketInfo.shortPoolAmount;\n  const maxPoolAmount = isLong\n    ? marketInfo.maxLongPoolAmount\n    : marketInfo.maxShortPoolAmount;\n\n  const capacityAmount = maxPoolAmount - poolAmount;\n  const token = isLong ? marketInfo.longToken : marketInfo.shortToken;\n\n  const capacityUsd = convertToUsd(\n    capacityAmount,\n    token.decimals,\n    getMidPrice(token.prices)\n  )!;\n\n  return capacityUsd;\n}\n\nexport function getSwapPathOutputAddresses(p: {\n  marketsInfoData: MarketsInfoData;\n  initialCollateralAddress: string;\n  swapPath: string[];\n  wrappedNativeTokenAddress: string;\n  shouldUnwrapNativeToken: boolean;\n  isIncrease: boolean;\n}) {\n  const {\n    marketsInfoData,\n    initialCollateralAddress,\n    swapPath,\n    wrappedNativeTokenAddress,\n    shouldUnwrapNativeToken,\n    isIncrease,\n  } = p;\n\n  if (swapPath.length === 0) {\n    // Increase\n    if (isIncrease) {\n      // During increase target collateral token is always ERC20 token, it can not be native token.\n      // Thus we do not need to check if initial collateral token is wrapped token to unwrap it.\n      // So we can safely return initial collateral token address as out token address, when there is no swap path.\n\n      return {\n        outTokenAddress: initialCollateralAddress,\n        outMarketAddress: undefined,\n      };\n    }\n\n    // Decrease\n    if (\n      shouldUnwrapNativeToken &&\n      initialCollateralAddress === wrappedNativeTokenAddress\n    ) {\n      return {\n        outTokenAddress: NATIVE_TOKEN_ADDRESS,\n        outMarketAddress: undefined,\n      };\n    }\n\n    return {\n      outTokenAddress: initialCollateralAddress,\n      outMarketAddress: undefined,\n    };\n  }\n\n  const [firstMarketAddress, ...marketAddresses] = swapPath;\n\n  let outMarket = getByKey(marketsInfoData, firstMarketAddress);\n\n  if (!outMarket) {\n    return {\n      outTokenAddress: undefined,\n      outMarketAddress: undefined,\n    };\n  }\n\n  let outTokenType = getTokenPoolType(outMarket, initialCollateralAddress);\n  let outToken =\n    outTokenType === \"long\" ? outMarket.shortToken : outMarket.longToken;\n\n  for (const marketAddress of marketAddresses) {\n    outMarket = getByKey(marketsInfoData, marketAddress);\n\n    if (!outMarket) {\n      return {\n        outTokenAddress: undefined,\n        outMarketAddress: undefined,\n      };\n    }\n\n    outTokenType =\n      outMarket.longTokenAddress === outToken.address ? \"short\" : \"long\";\n    outToken =\n      outTokenType === \"long\" ? outMarket.longToken : outMarket.shortToken;\n  }\n\n  let outTokenAddress: string;\n  if (isIncrease) {\n    // Here swap path is not empty, this means out token came from swapping tokens,\n    // thus it can not be native token by design.\n    outTokenAddress = outToken.address;\n  } else {\n    if (\n      shouldUnwrapNativeToken &&\n      outToken.address === wrappedNativeTokenAddress\n    ) {\n      outTokenAddress = NATIVE_TOKEN_ADDRESS;\n    } else {\n      outTokenAddress = outToken.address;\n    }\n  }\n\n  return {\n    outTokenAddress,\n    outMarketAddress: outMarket.marketTokenAddress,\n  };\n}\n\nexport function getSwapPathStats(p: {\n  marketsInfoData: MarketsInfoData;\n  swapPath: string[];\n  initialCollateralAddress: string;\n  wrappedNativeTokenAddress: string;\n  usdIn: bigint;\n  shouldUnwrapNativeToken: boolean;\n  shouldApplyPriceImpact: boolean;\n  isAtomicSwap: boolean;\n}): SwapPathStats | undefined {\n  const {\n    marketsInfoData,\n    swapPath,\n    initialCollateralAddress,\n    usdIn,\n    shouldUnwrapNativeToken,\n    shouldApplyPriceImpact,\n    wrappedNativeTokenAddress,\n    isAtomicSwap,\n  } = p;\n\n  if (swapPath.length === 0) {\n    return undefined;\n  }\n\n  const swapSteps: SwapStats[] = [];\n\n  let usdOut = usdIn;\n\n  let tokenInAddress = initialCollateralAddress;\n  let tokenOutAddress = initialCollateralAddress;\n\n  let totalSwapPriceImpactDeltaUsd = 0n;\n  let totalSwapFeeUsd = 0n;\n\n  for (let i = 0; i < swapPath.length; i++) {\n    const marketAddress = swapPath[i];\n    const marketInfo = marketsInfoData[marketAddress];\n\n    if (!marketInfo) {\n      return undefined;\n    }\n\n    const nextTokenOutAddress = getOppositeCollateral(\n      marketInfo,\n      tokenInAddress\n    )?.address;\n\n    if (!nextTokenOutAddress) {\n      return undefined;\n    }\n\n    tokenOutAddress = nextTokenOutAddress;\n\n    if (\n      i === swapPath.length - 1 &&\n      shouldUnwrapNativeToken &&\n      tokenOutAddress === wrappedNativeTokenAddress\n    ) {\n      tokenOutAddress = NATIVE_TOKEN_ADDRESS;\n    }\n\n    const swapStep = getSwapStats({\n      marketInfo,\n      tokenInAddress,\n      tokenOutAddress,\n      usdIn: usdOut,\n      shouldApplyPriceImpact,\n      isAtomicSwap,\n    });\n\n    tokenInAddress = swapStep.tokenOutAddress;\n    usdOut = swapStep.usdOut;\n\n    totalSwapPriceImpactDeltaUsd =\n      totalSwapPriceImpactDeltaUsd + swapStep.priceImpactDeltaUsd;\n    totalSwapFeeUsd = totalSwapFeeUsd + swapStep.swapFeeUsd;\n\n    swapSteps.push(swapStep);\n  }\n\n  const lastStep = swapSteps[swapSteps.length - 1];\n  const targetMarketAddress = lastStep.marketAddress;\n  const amountOut = lastStep.amountOut;\n\n  const totalFeesDeltaUsd = 0n - totalSwapFeeUsd + totalSwapPriceImpactDeltaUsd;\n\n  return {\n    swapPath,\n    tokenInAddress: initialCollateralAddress,\n    tokenOutAddress,\n    targetMarketAddress,\n    swapSteps,\n    usdOut,\n    amountOut,\n    totalSwapFeeUsd,\n    totalSwapPriceImpactDeltaUsd,\n    totalFeesDeltaUsd,\n  };\n}\n\nexport function getSwapStats(p: {\n  marketInfo: MarketInfo;\n  tokenInAddress: string;\n  tokenOutAddress: string;\n  usdIn: bigint;\n  shouldApplyPriceImpact: boolean;\n  isAtomicSwap: boolean;\n}): SwapStats {\n  const {\n    marketInfo,\n    tokenInAddress,\n    tokenOutAddress,\n    usdIn,\n    shouldApplyPriceImpact,\n    isAtomicSwap,\n  } = p;\n\n  const isWrap = tokenInAddress === NATIVE_TOKEN_ADDRESS;\n  const isUnwrap = tokenOutAddress === NATIVE_TOKEN_ADDRESS;\n\n  const tokenIn =\n    getTokenPoolType(marketInfo, tokenInAddress) === \"long\"\n      ? marketInfo.longToken\n      : marketInfo.shortToken;\n\n  const tokenOut =\n    getTokenPoolType(marketInfo, tokenOutAddress) === \"long\"\n      ? marketInfo.longToken\n      : marketInfo.shortToken;\n\n  const priceIn = tokenIn.prices.minPrice;\n  const priceOut = tokenOut.prices.maxPrice;\n\n  const amountIn = convertToTokenAmount(usdIn, tokenIn.decimals, priceIn)!;\n\n  let priceImpactDeltaUsd: bigint;\n  let balanceWasImproved: boolean;\n\n  try {\n    const priceImpactValues = getPriceImpactForSwap(\n      marketInfo,\n      tokenIn,\n      tokenOut,\n      usdIn,\n      usdIn * -1n\n    );\n    priceImpactDeltaUsd = priceImpactValues.priceImpactDeltaUsd;\n    balanceWasImproved = priceImpactValues.balanceWasImproved;\n  } catch (e) {\n    // Approximate if the market would be out of capacity\n    const capacityUsd = getSwapCapacityUsd(\n      marketInfo,\n      getTokenPoolType(marketInfo, tokenInAddress) === \"long\"\n    );\n    const swapFeeUsd = getSwapFee(marketInfo, usdIn, false, isAtomicSwap);\n    const usdInAfterFees = usdIn - swapFeeUsd;\n    const isOutCapacity = capacityUsd < usdInAfterFees;\n\n    return {\n      swapFeeUsd: 0n,\n      swapFeeAmount: 0n,\n      isWrap,\n      isUnwrap,\n      marketAddress: marketInfo.marketTokenAddress,\n      tokenInAddress,\n      tokenOutAddress,\n      priceImpactDeltaUsd: 0n,\n      amountIn,\n      amountInAfterFees: amountIn,\n      usdIn,\n      amountOut: 0n,\n      usdOut: 0n,\n      isOutLiquidity: true,\n      isOutCapacity,\n    };\n  }\n\n  const swapFeeAmount = getSwapFee(\n    marketInfo,\n    amountIn,\n    balanceWasImproved,\n    isAtomicSwap\n  );\n  const swapFeeUsd = getSwapFee(\n    marketInfo,\n    usdIn,\n    balanceWasImproved,\n    isAtomicSwap\n  );\n\n  const amountInAfterFees = amountIn - swapFeeAmount;\n  const usdInAfterFees = usdIn - swapFeeUsd;\n\n  let usdOut = usdInAfterFees;\n  let amountOut = convertToTokenAmount(usdOut, tokenOut.decimals, priceOut)!;\n\n  let cappedImpactDeltaUsd: bigint;\n\n  if (priceImpactDeltaUsd > 0) {\n    const { impactDeltaAmount: positiveImpactAmountTokenOut, cappedDiffUsd } =\n      applySwapImpactWithCap(marketInfo, tokenOut, priceImpactDeltaUsd);\n    cappedImpactDeltaUsd = convertToUsd(\n      positiveImpactAmountTokenOut,\n      tokenOut.decimals,\n      priceOut\n    )!;\n\n    // https://github.com/gmx-io/gmx-synthetics/blob/3df10f1eab2734cf1b5f0a5dff12b79cbb19907d/contracts/swap/SwapUtils.sol#L290-L291\n    if (cappedDiffUsd > 0) {\n      const { impactDeltaAmount: positiveImpactAmountTokenIn } =\n        applySwapImpactWithCap(marketInfo, tokenIn, cappedDiffUsd);\n      if (positiveImpactAmountTokenIn > 0) {\n        cappedImpactDeltaUsd += convertToUsd(\n          positiveImpactAmountTokenIn,\n          tokenIn.decimals,\n          priceIn\n        )!;\n      }\n    }\n  } else {\n    const { impactDeltaAmount: negativeImpactAmount } = applySwapImpactWithCap(\n      marketInfo,\n      tokenIn,\n      priceImpactDeltaUsd\n    );\n    cappedImpactDeltaUsd = convertToUsd(\n      negativeImpactAmount,\n      tokenIn.decimals,\n      priceIn\n    )!;\n  }\n\n  if (shouldApplyPriceImpact) {\n    usdOut = usdOut + cappedImpactDeltaUsd;\n  }\n\n  if (usdOut < 0) {\n    usdOut = 0n;\n  }\n\n  amountOut = convertToTokenAmount(usdOut, tokenOut.decimals, priceOut)!;\n\n  const capacityUsd = getSwapCapacityUsd(\n    marketInfo,\n    getTokenPoolType(marketInfo, tokenInAddress) === \"long\"\n  );\n\n  const isOutCapacity = capacityUsd < usdInAfterFees;\n\n  const liquidity = getAvailableUsdLiquidityForCollateral(\n    marketInfo,\n    getTokenPoolType(marketInfo, tokenOutAddress) === \"long\"\n  );\n\n  const isOutLiquidity = liquidity < usdOut;\n\n  return {\n    swapFeeUsd,\n    swapFeeAmount,\n    isWrap,\n    isUnwrap,\n    marketAddress: marketInfo.marketTokenAddress,\n    tokenInAddress,\n    tokenOutAddress,\n    priceImpactDeltaUsd: cappedImpactDeltaUsd,\n    amountIn,\n    amountInAfterFees,\n    usdIn,\n    amountOut,\n    usdOut,\n    isOutLiquidity,\n    isOutCapacity,\n  };\n}\n\nexport function getMaxSwapPathLiquidity(p: {\n  marketsInfoData: MarketsInfoData;\n  swapPath: string[];\n  initialCollateralAddress: string;\n}) {\n  const { marketsInfoData, swapPath, initialCollateralAddress } = p;\n\n  if (swapPath.length === 0) {\n    return 0n;\n  }\n\n  let minMarketLiquidity = maxUint256;\n  let tokenInAddress = initialCollateralAddress;\n\n  for (const marketAddress of swapPath) {\n    const marketInfo = getByKey(marketsInfoData, marketAddress);\n\n    if (!marketInfo) {\n      return 0n;\n    }\n\n    const tokenOut = getOppositeCollateral(marketInfo, tokenInAddress);\n\n    if (!tokenOut) {\n      return 0n;\n    }\n\n    const isTokenOutLong =\n      getTokenPoolType(marketInfo, tokenOut.address) === \"long\";\n    const liquidity = getAvailableUsdLiquidityForCollateral(\n      marketInfo,\n      isTokenOutLong\n    );\n\n    if (liquidity < minMarketLiquidity) {\n      minMarketLiquidity = liquidity;\n    }\n\n    tokenInAddress = tokenOut.address;\n  }\n\n  if (minMarketLiquidity === maxUint256) {\n    return 0n;\n  }\n\n  return minMarketLiquidity;\n}\n"]}