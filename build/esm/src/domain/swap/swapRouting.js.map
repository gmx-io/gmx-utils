{"version":3,"sources":["../../../../../src/domain/swap/swapRouting.ts"],"names":[],"mappings":"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","file":"swapRouting.js","sourcesContent":["import { maxUint256 } from \"viem\";\n\nimport { DEFAULT_NAIVE_TOP_PATHS_COUNT } from \"configs/swap\";\nimport {\n  estimateOrderOraclePriceCount,\n  getExecutionFee,\n} from \"domain/executionFee\";\nimport { getNaiveEstimatedGasBySwapCount } from \"domain/executionFee/getNaiveEstimatedGasBySwapCount\";\nimport { GasLimitsConfig } from \"domain/executionFee/types\";\nimport { MarketsInfoData } from \"domain/markets/types\";\nimport {\n  getAvailableUsdLiquidityForCollateral,\n  getTokenPoolType,\n} from \"domain/markets/utils\";\nimport { MarketsGraph } from \"domain/swap/buildMarketsAdjacencyGraph\";\nimport {\n  MARKETS_ADJACENCY_GRAPH,\n  REACHABLE_TOKENS,\n  TOKEN_SWAP_PATHS,\n} from \"domain/swap/preparedSwapData\";\nimport {\n  MarketEdge,\n  MarketEdgeLiquidityGetter,\n  NaiveNetworkEstimator,\n  NaiveSwapEstimator,\n  SwapEstimator,\n  SwapPaths,\n} from \"domain/swap/types\";\nimport { TokensData } from \"domain/tokens/types\";\nimport { bigMath } from \"lib/bigmath\";\nimport { PRECISION, PRECISION_DECIMALS, bigintToNumber } from \"lib/numbers\";\nimport { getByKey } from \"lib/objects\";\n\nimport { getSwapStats } from \"./swapStats\";\n\nexport const createSwapEstimator = (\n  marketsInfoData: MarketsInfoData,\n  isAtomicSwap: boolean\n): SwapEstimator => {\n  return (e: MarketEdge, usdIn: bigint) => {\n    const marketInfo = marketsInfoData[e.marketAddress];\n\n    if (!marketInfo || marketInfo.isDisabled) {\n      return {\n        usdOut: 0n,\n      };\n    }\n\n    const swapStats = getSwapStats({\n      marketInfo,\n      usdIn,\n      tokenInAddress: e.from,\n      tokenOutAddress: e.to,\n      shouldApplyPriceImpact: true,\n      isAtomicSwap,\n    });\n\n    const isOutLiquidity = swapStats?.isOutLiquidity;\n    const isOutCapacity = swapStats?.isOutCapacity;\n    const usdOut = swapStats?.usdOut;\n\n    if (usdOut === undefined || isOutLiquidity || isOutCapacity) {\n      return {\n        usdOut: 0n,\n      };\n    }\n\n    return {\n      usdOut,\n    };\n  };\n};\n\nexport const createMarketEdgeLiquidityGetter = (\n  marketsInfoData: MarketsInfoData\n): MarketEdgeLiquidityGetter => {\n  return (e: MarketEdge) => {\n    const marketInfo = getByKey(marketsInfoData, e.marketAddress);\n\n    if (!marketInfo || marketInfo.isDisabled) {\n      return 0n;\n    }\n\n    const isTokenOutLong = getTokenPoolType(marketInfo, e.to) === \"long\";\n    const liquidity = getAvailableUsdLiquidityForCollateral(\n      marketInfo,\n      isTokenOutLong\n    );\n\n    return liquidity;\n  };\n};\n\nexport const createNaiveSwapEstimator = (\n  marketsInfoData: MarketsInfoData,\n  isAtomicSwap: boolean\n): NaiveSwapEstimator => {\n  return (e: MarketEdge, usdIn: bigint) => {\n    let marketInfo = marketsInfoData[e.marketAddress];\n\n    if (marketInfo === undefined || marketInfo.isDisabled) {\n      return { swapYield: 0 };\n    }\n\n    const swapStats = getSwapStats({\n      marketInfo,\n      usdIn,\n      tokenInAddress: e.from,\n      tokenOutAddress: e.to,\n      shouldApplyPriceImpact: true,\n      isAtomicSwap,\n    });\n\n    const usdOut = swapStats?.usdOut;\n\n    if (\n      usdOut === undefined ||\n      usdOut === 0n ||\n      swapStats.isOutCapacity ||\n      swapStats.isOutLiquidity\n    ) {\n      return { swapYield: 0 };\n    }\n\n    const swapYield = bigintToNumber(\n      (usdOut * PRECISION) / usdIn,\n      PRECISION_DECIMALS\n    );\n\n    return { swapYield };\n  };\n};\n\nexport const createNaiveNetworkEstimator = ({\n  gasLimits,\n  tokensData,\n  gasPrice,\n  chainId,\n}: {\n  gasLimits: GasLimitsConfig;\n  tokensData: TokensData;\n  gasPrice: bigint;\n  chainId: number;\n}): NaiveNetworkEstimator => {\n  return (usdIn: bigint, swapsCount: number) => {\n    const estimatedGas = getNaiveEstimatedGasBySwapCount(\n      gasLimits.singleSwap,\n      swapsCount\n    );\n    if (estimatedGas === null || estimatedGas === undefined)\n      return { networkYield: 1.0, usdOut: usdIn };\n\n    const oraclePriceCount = estimateOrderOraclePriceCount(swapsCount);\n\n    const feeUsd = getExecutionFee(\n      chainId,\n      gasLimits,\n      tokensData,\n      estimatedGas,\n      gasPrice,\n      oraclePriceCount\n    )?.feeUsd;\n    if (feeUsd === undefined) return { networkYield: 1.0, usdOut: usdIn };\n\n    const networkYield = bigintToNumber(\n      bigMath.mulDiv(usdIn, PRECISION, usdIn + feeUsd),\n      PRECISION_DECIMALS\n    );\n\n    return { networkYield, usdOut: usdIn - feeUsd };\n  };\n};\n\nexport function getBestSwapPath({\n  routes,\n  usdIn,\n  estimator,\n  networkEstimator,\n}: {\n  routes: MarketEdge[][];\n  usdIn: bigint;\n  estimator: SwapEstimator;\n  networkEstimator?: NaiveNetworkEstimator;\n}): MarketEdge[] | undefined {\n  if (routes.length === 0) {\n    return undefined;\n  }\n\n  let bestRoute = routes[0];\n  let bestUsdOut = 0n;\n\n  for (const route of routes) {\n    try {\n      let pathUsdOut = route.reduce((prevUsdOut, edge) => {\n        const { usdOut } = estimator(edge, prevUsdOut);\n        return usdOut;\n      }, usdIn);\n\n      if (networkEstimator) {\n        const { usdOut } = networkEstimator(pathUsdOut, route.length);\n        pathUsdOut = usdOut;\n      }\n\n      if (pathUsdOut > bestUsdOut) {\n        bestRoute = route;\n        bestUsdOut = pathUsdOut;\n      }\n    } catch (e) {\n      continue;\n    }\n  }\n\n  return bestRoute;\n}\n\nexport function getNaiveBestMarketSwapPathsFromTokenSwapPaths({\n  graph,\n  tokenSwapPaths,\n  usdIn,\n  tokenInAddress,\n  tokenOutAddress,\n  estimator,\n  topPathsCount = DEFAULT_NAIVE_TOP_PATHS_COUNT,\n  networkEstimator,\n}: {\n  graph: MarketsGraph;\n  tokenSwapPaths: string[][];\n  usdIn: bigint;\n  tokenInAddress: string;\n  tokenOutAddress: string;\n  estimator: NaiveSwapEstimator;\n  topPathsCount?: number;\n  networkEstimator?: NaiveNetworkEstimator;\n}): string[][] {\n  // This seems to be true, because for any path if we have performed swaps to and from token\n  // The best markets sequence is the same\n  const cachedBestMarketForTokenEdge: Record<\n    // Key: tokenHopFromAddress-tokenHopToAddress-count\n    string,\n    {\n      marketAddress: string;\n      swapYield: number;\n    }\n  > = {};\n\n  const calculatedCache: Record<\n    // From token address\n    string,\n    Record<\n      // To token address\n      string,\n      Record<\n        // Market address\n        string,\n        number\n      >\n    >\n  > = {};\n\n  const topPaths: {\n    marketPath: string[];\n    swapYield: number;\n  }[] = [];\n\n  const networkYieldCache: Record<number, number> = {};\n\n  for (const pathType of tokenSwapPaths) {\n    const marketPath: string[] = [];\n    let pathTypeSwapYield = 1;\n    let bad = false;\n\n    // Just how many times we have swapped from token A to token B\n    const tokenSwapCounter: Record<\n      // From token address\n      string,\n      Record<\n        // To token address\n        string,\n        number\n      >\n    > = {};\n\n    for (let hopIndex = 0; hopIndex <= pathType.length; hopIndex++) {\n      const tokenHopFromAddress =\n        hopIndex === 0 ? tokenInAddress : pathType[hopIndex - 1];\n      const tokenHopToAddress =\n        hopIndex === pathType.length ? tokenOutAddress : pathType[hopIndex];\n\n      // prevTokenAddress -> tokenAddress\n      // get all markets for prevTokenAddress -> tokenAddress\n      const marketAddresses = getMarketsForTokenPair(\n        graph,\n        tokenHopFromAddress,\n        tokenHopToAddress\n      );\n\n      if (marketAddresses.length === 0) {\n        bad = true;\n        break;\n      }\n\n      const tokenSwapCount =\n        tokenSwapCounter[tokenHopFromAddress]?.[tokenHopToAddress] || 0;\n\n      const key = `${tokenHopFromAddress}-${tokenHopToAddress}-${tokenSwapCount}`;\n\n      let bestMarketInfo:\n        | {\n            marketAddress: string;\n            swapYield: number;\n          }\n        | undefined = cachedBestMarketForTokenEdge[key];\n\n      if (!bestMarketInfo) {\n        calculatedCache[tokenHopFromAddress] =\n          calculatedCache[tokenHopFromAddress] || {};\n        calculatedCache[tokenHopFromAddress][tokenHopToAddress] =\n          calculatedCache[tokenHopFromAddress][tokenHopToAddress] || {};\n\n        bestMarketInfo = getBestMarketForTokenEdge({\n          marketAddresses,\n          usdIn,\n          tokenInAddress: tokenHopFromAddress,\n          tokenOutAddress: tokenHopToAddress,\n          estimator,\n          marketPath,\n          calculatedCache:\n            calculatedCache[tokenHopFromAddress][tokenHopToAddress],\n        });\n\n        if (!bestMarketInfo) {\n          bad = true;\n          break;\n        }\n\n        cachedBestMarketForTokenEdge[key] = bestMarketInfo;\n      }\n\n      if (bestMarketInfo.swapYield === 0) {\n        bad = true;\n        break;\n      }\n\n      pathTypeSwapYield *= bestMarketInfo.swapYield;\n      marketPath.push(bestMarketInfo.marketAddress);\n\n      tokenSwapCounter[tokenHopFromAddress] =\n        tokenSwapCounter[tokenHopFromAddress] || {};\n      tokenSwapCounter[tokenHopFromAddress][tokenHopToAddress] =\n        (tokenSwapCounter[tokenHopFromAddress][tokenHopToAddress] || 0) + 1;\n    }\n\n    if (bad) {\n      continue;\n    }\n\n    if (topPaths.length < topPathsCount) {\n      topPaths.push({ marketPath: marketPath, swapYield: pathTypeSwapYield });\n    } else {\n      let adjustedPathTypeSwapYield = pathTypeSwapYield;\n\n      if (networkEstimator) {\n        let networkYield = networkYieldCache[marketPath.length];\n\n        if (networkYield === undefined) {\n          networkYield = networkEstimator(\n            usdIn,\n            marketPath.length\n          ).networkYield;\n\n          networkYieldCache[marketPath.length] = networkYield;\n        }\n\n        adjustedPathTypeSwapYield = adjustedPathTypeSwapYield * networkYield;\n      }\n\n      //  if yield is greater than any of the top paths, replace the one with the lowest yield\n      let minSwapYield = topPaths[0].swapYield;\n      let minSwapYieldIndex = 0;\n      for (let i = 1; i < topPaths.length; i++) {\n        if (topPaths[i].swapYield < minSwapYield) {\n          minSwapYield = topPaths[i].swapYield;\n          minSwapYieldIndex = i;\n        }\n      }\n      if (adjustedPathTypeSwapYield > minSwapYield) {\n        topPaths[minSwapYieldIndex] = {\n          marketPath: marketPath,\n          swapYield: adjustedPathTypeSwapYield,\n        };\n      }\n    }\n  }\n\n  return topPaths.map((p) => p.marketPath);\n}\n\nexport function getMarketsForTokenPair(\n  graph: MarketsGraph,\n  tokenAAddress: string,\n  tokenBAddress: string\n): string[] {\n  if (graph[tokenAAddress]?.[tokenBAddress]) {\n    return graph[tokenAAddress][tokenBAddress];\n  }\n\n  if (graph[tokenBAddress]?.[tokenAAddress]) {\n    return graph[tokenBAddress][tokenAAddress];\n  }\n\n  return [];\n}\n\nexport function getBestMarketForTokenEdge({\n  marketAddresses,\n  usdIn,\n  tokenInAddress,\n  tokenOutAddress,\n  estimator,\n  marketPath,\n  calculatedCache,\n}: {\n  marketAddresses: string[];\n  usdIn: bigint;\n  tokenInAddress: string;\n  tokenOutAddress: string;\n  estimator: NaiveSwapEstimator;\n  marketPath?: string[];\n  calculatedCache?: Record<\n    // Key: market address\n    string,\n    number\n  >;\n}):\n  | {\n      marketAddress: string;\n      swapYield: number;\n    }\n  | undefined {\n  let bestMarketAddress = marketAddresses[0];\n  let bestYield = 0;\n  let found = false;\n\n  for (const marketAddress of marketAddresses) {\n    if (marketPath && marketPath.includes(marketAddress)) {\n      continue;\n    }\n\n    let swapYield: number | undefined = undefined;\n\n    const key = marketAddress;\n    if (calculatedCache) {\n      swapYield = calculatedCache[key];\n    }\n\n    if (swapYield === undefined) {\n      swapYield = estimator(\n        {\n          marketAddress,\n          from: tokenInAddress,\n          to: tokenOutAddress,\n        },\n        usdIn\n      ).swapYield;\n\n      if (calculatedCache) {\n        calculatedCache[key] = swapYield;\n      }\n    }\n\n    if (swapYield > bestYield) {\n      bestYield = swapYield;\n      bestMarketAddress = marketAddress;\n      found = true;\n    }\n  }\n\n  if (!found) {\n    return undefined;\n  }\n\n  return {\n    marketAddress: bestMarketAddress,\n    swapYield: bestYield,\n  };\n}\n\nexport function marketRouteToMarketEdges(\n  marketPath: string[],\n  from: string,\n  marketsInfoData: MarketsInfoData\n): MarketEdge[] {\n  let edges: MarketEdge[] = [];\n\n  for (let i = 0; i < marketPath.length; i++) {\n    const currentFrom = i === 0 ? from : edges[i - 1].to;\n    const currentTo =\n      marketsInfoData[marketPath[i]].longTokenAddress === currentFrom\n        ? marketsInfoData[marketPath[i]].shortTokenAddress\n        : marketsInfoData[marketPath[i]].longTokenAddress;\n\n    edges.push({\n      from: currentFrom,\n      to: currentTo,\n      marketAddress: marketPath[i],\n    });\n  }\n\n  return edges;\n}\n\nexport function getTokenSwapPathsForTokenPair(\n  tokenSwapPaths: SwapPaths,\n  tokenAAddress: string,\n  tokenBAddress: string\n): string[][] {\n  if (tokenSwapPaths[tokenAAddress]?.[tokenBAddress]) {\n    return tokenSwapPaths[tokenAAddress][tokenBAddress];\n  }\n\n  if (tokenSwapPaths[tokenBAddress]?.[tokenAAddress]) {\n    return tokenSwapPaths[tokenBAddress][tokenAAddress].map((route) =>\n      [...route].reverse()\n    );\n  }\n\n  return [];\n}\n\nexport function getTokenSwapPathsForTokenPairPrebuilt(\n  chainId: number,\n  from: string,\n  to: string\n): string[][] {\n  return getTokenSwapPathsForTokenPair(TOKEN_SWAP_PATHS[chainId], from, to);\n}\n\nexport function getMarketAdjacencyGraph(chainId: number): MarketsGraph {\n  return MARKETS_ADJACENCY_GRAPH[chainId];\n}\n\nexport function findAllReachableTokens(\n  chainId: number,\n  from: string\n): string[] {\n  return REACHABLE_TOKENS[chainId][from];\n}\n\nexport function getMaxLiquidityMarketSwapPathFromTokenSwapPaths({\n  graph,\n  tokenSwapPaths,\n  tokenInAddress,\n  tokenOutAddress,\n  getLiquidity,\n}: {\n  graph: MarketsGraph;\n  tokenSwapPaths: string[][];\n  tokenInAddress: string;\n  tokenOutAddress: string;\n  getLiquidity: MarketEdgeLiquidityGetter;\n}): { path: string[]; liquidity: bigint } | undefined {\n  // go through all edges and find best yield market for it\n\n  const cachedMaxLiquidityMarketForTokenEdge: Record<\n    string,\n    Record<\n      string,\n      {\n        marketAddress: string;\n        liquidity: bigint;\n      }\n    >\n  > = {};\n\n  let bestMarketPath: string[] | undefined = undefined;\n  let bestLiquidity = 0n;\n\n  for (const pathType of tokenSwapPaths) {\n    let bad = false;\n    let bestMarketPathForPathType: string[] = [];\n    let pathTypeBestLiquidity = maxUint256;\n\n    for (let hopIndex = 0; hopIndex <= pathType.length; hopIndex++) {\n      const tokenFromAddress =\n        hopIndex === 0 ? tokenInAddress : pathType[hopIndex - 1];\n      const tokenToAddress =\n        hopIndex === pathType.length ? tokenOutAddress : pathType[hopIndex];\n\n      // prevTokenAddress -> tokenAddress\n      // get all markets for prevTokenAddress -> tokenAddress\n      const markets = getMarketsForTokenPair(\n        graph,\n        tokenFromAddress,\n        tokenToAddress\n      );\n\n      if (markets.length === 0) {\n        bad = true;\n        break;\n      }\n\n      let bestMarketInfo:\n        | {\n            marketAddress: string;\n            liquidity: bigint;\n          }\n        | undefined =\n        cachedMaxLiquidityMarketForTokenEdge[tokenFromAddress]?.[\n          tokenToAddress\n        ];\n\n      if (!bestMarketInfo) {\n        bestMarketInfo = getMaxLiquidityMarketForTokenEdge({\n          markets,\n          tokenInAddress,\n          tokenOutAddress,\n          getLiquidity,\n        });\n\n        cachedMaxLiquidityMarketForTokenEdge[tokenFromAddress] =\n          cachedMaxLiquidityMarketForTokenEdge[tokenFromAddress] || {};\n        cachedMaxLiquidityMarketForTokenEdge[tokenFromAddress][tokenToAddress] =\n          bestMarketInfo;\n      }\n\n      bestMarketPathForPathType.push(bestMarketInfo.marketAddress);\n\n      if (bestMarketInfo.liquidity < pathTypeBestLiquidity) {\n        pathTypeBestLiquidity = bestMarketInfo.liquidity;\n      }\n\n      if (pathTypeBestLiquidity < bestLiquidity) {\n        bad = true;\n        break;\n      }\n    }\n\n    if (bad) {\n      continue;\n    }\n\n    if (pathTypeBestLiquidity > bestLiquidity) {\n      bestLiquidity = pathTypeBestLiquidity;\n      bestMarketPath = bestMarketPathForPathType;\n    }\n  }\n\n  return bestMarketPath\n    ? { path: bestMarketPath, liquidity: bestLiquidity }\n    : undefined;\n}\n\nexport function getMaxLiquidityMarketForTokenEdge({\n  markets,\n  tokenInAddress,\n  tokenOutAddress,\n  getLiquidity,\n}: {\n  markets: string[];\n  tokenInAddress: string;\n  tokenOutAddress: string;\n  getLiquidity: MarketEdgeLiquidityGetter;\n}): {\n  marketAddress: string;\n  liquidity: bigint;\n} {\n  let bestMarketAddress = markets[0];\n  let bestLiquidity = 0n;\n\n  for (const market of markets) {\n    const liquidity = getLiquidity({\n      marketAddress: market,\n      from: tokenInAddress,\n      to: tokenOutAddress,\n    });\n\n    if (liquidity > bestLiquidity) {\n      bestLiquidity = liquidity;\n      bestMarketAddress = market;\n    }\n  }\n\n  return {\n    marketAddress: bestMarketAddress,\n    liquidity: bestLiquidity,\n  };\n}\n"]}