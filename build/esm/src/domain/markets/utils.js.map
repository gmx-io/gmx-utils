{"version":3,"sources":["../../../../../src/domain/markets/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourcesContent":["import { getTokenVisualMultiplier, NATIVE_TOKEN_ADDRESS } from \"configs/tokens\";\nimport { Token, TokenPrices, TokenData } from \"domain/tokens/types\";\nimport {\n  convertToUsd,\n  getMidPrice,\n  convertToTokenAmount,\n} from \"domain/tokens/utils\";\nimport { bigMath } from \"lib/bigmath\";\nimport { BASIS_POINTS_DIVISOR } from \"lib/numbers\";\nimport {\n  applyFactor,\n  PRECISION,\n  expandDecimals,\n  USD_DECIMALS,\n} from \"lib/numbers\";\n\nimport { MarketInfo } from \"./types\";\n\nexport function getMarketFullName(p: {\n  longToken: Token;\n  shortToken: Token;\n  indexToken: Token;\n  isSpotOnly: boolean;\n}) {\n  const { indexToken, longToken, shortToken, isSpotOnly } = p;\n\n  return `${getMarketIndexName({\n    indexToken,\n    isSpotOnly,\n  })} [${getMarketPoolName({ longToken, shortToken })}]`;\n}\n\nexport function getMarketIndexName(\n  p: ({ indexToken: Token } | { glvToken: Token }) & { isSpotOnly: boolean }\n) {\n  if (p.isSpotOnly) {\n    return `SWAP-ONLY`;\n  }\n\n  return `${getMarketBaseName(p)}/USD`;\n}\n\nexport function getMarketBaseName(\n  p: ({ indexToken: Token } | { glvToken: Token }) & { isSpotOnly: boolean }\n) {\n  const { isSpotOnly } = p;\n\n  const firstToken = \"indexToken\" in p ? p.indexToken : p.glvToken;\n\n  if (isSpotOnly) {\n    return `SWAP-ONLY`;\n  }\n\n  const prefix = getTokenVisualMultiplier(firstToken);\n\n  return `${prefix}${firstToken.baseSymbol || firstToken.symbol}`;\n}\n\nexport function getMarketPoolName(\n  p: { longToken: Token; shortToken: Token },\n  separator = \"-\"\n) {\n  const { longToken, shortToken } = p;\n\n  return `${longToken.symbol}${separator}${shortToken.symbol}`;\n}\n\nexport function getTokenPoolType(\n  marketInfo: {\n    longToken: Token;\n    shortToken: Token;\n  },\n  tokenAddress: string\n): \"long\" | \"short\" | undefined {\n  const { longToken, shortToken } = marketInfo;\n\n  if (\n    longToken.address === shortToken.address &&\n    tokenAddress === longToken.address\n  ) {\n    return \"long\";\n  }\n\n  if (\n    tokenAddress === longToken.address ||\n    (tokenAddress === NATIVE_TOKEN_ADDRESS && longToken.isWrapped)\n  ) {\n    return \"long\";\n  }\n\n  if (\n    tokenAddress === shortToken.address ||\n    (tokenAddress === NATIVE_TOKEN_ADDRESS && shortToken.isWrapped)\n  ) {\n    return \"short\";\n  }\n\n  return undefined;\n}\n\nexport function getPoolUsdWithoutPnl(\n  marketInfo: MarketInfo,\n  isLong: boolean,\n  priceType: \"minPrice\" | \"maxPrice\" | \"midPrice\"\n) {\n  const poolAmount = isLong\n    ? marketInfo.longPoolAmount\n    : marketInfo.shortPoolAmount;\n  const token = isLong ? marketInfo.longToken : marketInfo.shortToken;\n\n  let price: bigint | undefined;\n\n  if (priceType === \"minPrice\") {\n    price = token.prices?.minPrice;\n  } else if (priceType === \"maxPrice\") {\n    price = token.prices?.maxPrice;\n  } else {\n    price = getMidPrice(token.prices);\n  }\n\n  return convertToUsd(poolAmount, token.decimals, price)!;\n}\n\nexport function getCappedPoolPnl(p: {\n  marketInfo: MarketInfo;\n  poolUsd: bigint;\n  poolPnl: bigint;\n  isLong: boolean;\n}) {\n  const { marketInfo, poolUsd, poolPnl, isLong } = p;\n\n  if (poolPnl < 0) {\n    return poolPnl;\n  }\n\n  const maxPnlFactor: bigint = isLong\n    ? marketInfo.maxPnlFactorForTradersLong\n    : marketInfo.maxPnlFactorForTradersShort;\n  const maxPnl = applyFactor(poolUsd, maxPnlFactor);\n\n  return poolPnl > maxPnl ? maxPnl : poolPnl;\n}\n\nexport function getMaxLeverageByMinCollateralFactor(\n  minCollateralFactor: bigint | undefined\n) {\n  if (minCollateralFactor === undefined) return 100 * BASIS_POINTS_DIVISOR;\n  if (minCollateralFactor === 0n) return 100 * BASIS_POINTS_DIVISOR;\n\n  const x = Number(PRECISION / minCollateralFactor);\n  const rounded = Math.round(x / 10) * 10;\n  return rounded * BASIS_POINTS_DIVISOR;\n}\n\nexport function getMaxAllowedLeverageByMinCollateralFactor(\n  minCollateralFactor: bigint | undefined\n) {\n  return getMaxLeverageByMinCollateralFactor(minCollateralFactor) / 2;\n}\n\nexport function getOppositeCollateral(\n  marketInfo: MarketInfo,\n  tokenAddress: string\n) {\n  const poolType = getTokenPoolType(marketInfo, tokenAddress);\n\n  if (poolType === \"long\") {\n    return marketInfo.shortToken;\n  }\n\n  if (poolType === \"short\") {\n    return marketInfo.longToken;\n  }\n\n  return undefined;\n}\n\nexport function getAvailableUsdLiquidityForCollateral(\n  marketInfo: MarketInfo,\n  isLong: boolean\n) {\n  const poolUsd = getPoolUsdWithoutPnl(marketInfo, isLong, \"minPrice\");\n\n  if (marketInfo.isSpotOnly) {\n    return poolUsd;\n  }\n\n  const reservedUsd = getReservedUsd(marketInfo, isLong);\n  const maxReserveFactor = isLong\n    ? marketInfo.reserveFactorLong\n    : marketInfo.reserveFactorShort;\n\n  if (maxReserveFactor === 0n) {\n    return 0n;\n  }\n\n  const minPoolUsd = (reservedUsd * PRECISION) / maxReserveFactor;\n\n  const liquidity = poolUsd - minPoolUsd;\n\n  return liquidity;\n}\n\nexport function getReservedUsd(marketInfo: MarketInfo, isLong: boolean) {\n  const { indexToken } = marketInfo;\n\n  if (isLong) {\n    return convertToUsd(\n      marketInfo.longInterestInTokens,\n      marketInfo.indexToken.decimals,\n      indexToken.prices.maxPrice\n    )!;\n  } else {\n    return marketInfo.shortInterestUsd;\n  }\n}\n\nexport function getMarketDivisor({\n  longTokenAddress,\n  shortTokenAddress,\n}: {\n  longTokenAddress: string;\n  shortTokenAddress: string;\n}) {\n  return longTokenAddress === shortTokenAddress ? 2n : 1n;\n}\n\nexport function getMarketPnl(\n  marketInfo: MarketInfo,\n  isLong: boolean,\n  forMaxPoolValue: boolean\n) {\n  const maximize = !forMaxPoolValue;\n  const openInterestUsd = getOpenInterestUsd(marketInfo, isLong);\n  const openInterestInTokens = getOpenInterestInTokens(marketInfo, isLong);\n\n  if (openInterestUsd === 0n || openInterestInTokens === 0n) {\n    return 0n;\n  }\n\n  const price = getPriceForPnl(marketInfo.indexToken.prices, isLong, maximize);\n\n  const openInterestValue = convertToUsd(\n    openInterestInTokens,\n    marketInfo.indexToken.decimals,\n    price\n  )!;\n  const pnl = isLong\n    ? openInterestValue - openInterestUsd\n    : openInterestUsd - openInterestValue;\n\n  return pnl;\n}\n\nexport function getOpenInterestUsd(marketInfo: MarketInfo, isLong: boolean) {\n  return isLong ? marketInfo.longInterestUsd : marketInfo.shortInterestUsd;\n}\n\nexport function getOpenInterestInTokens(\n  marketInfo: MarketInfo,\n  isLong: boolean\n) {\n  return isLong\n    ? marketInfo.longInterestInTokens\n    : marketInfo.shortInterestInTokens;\n}\n\nexport function getOpenInterestForBalance(\n  marketInfo: MarketInfo,\n  isLong: boolean\n): bigint {\n  if (marketInfo.useOpenInterestInTokensForBalance) {\n    const interestInTokens = isLong\n      ? marketInfo.longInterestInTokens\n      : marketInfo.shortInterestInTokens;\n    const indexTokenPrice = getMidPrice(marketInfo.indexToken.prices);\n\n    return convertToUsd(\n      interestInTokens,\n      marketInfo.indexToken.decimals,\n      indexTokenPrice\n    )!;\n  }\n\n  return isLong ? marketInfo.longInterestUsd : marketInfo.shortInterestUsd;\n}\n\nexport function getPriceForPnl(\n  prices: TokenPrices,\n  isLong: boolean,\n  maximize: boolean\n) {\n  if (isLong) {\n    return maximize ? prices.maxPrice : prices.minPrice;\n  }\n\n  return maximize ? prices.minPrice : prices.maxPrice;\n}\n\nexport function getIsMarketAvailableForExpressSwaps(marketInfo: MarketInfo) {\n  return [\n    marketInfo.indexToken,\n    marketInfo.longToken,\n    marketInfo.shortToken,\n  ].every((token) => token.hasPriceFeedProvider);\n}\n\nexport function usdToMarketTokenAmount(\n  marketInfo: MarketInfo,\n  marketToken: TokenData,\n  usdValue: bigint\n) {\n  const supply = marketToken.totalSupply!;\n  const poolValue = marketInfo.poolValueMax!;\n  if (supply == 0n && poolValue == 0n) {\n    return convertToTokenAmount(\n      usdValue,\n      marketToken.decimals,\n      expandDecimals(1, USD_DECIMALS)\n    )!;\n  }\n\n  if (supply == 0n && poolValue > 0) {\n    return convertToTokenAmount(\n      usdValue + poolValue,\n      marketToken.decimals,\n      expandDecimals(1, USD_DECIMALS)\n    )!;\n  }\n\n  if (poolValue == 0n) {\n    return 0n;\n  }\n\n  return bigMath.mulDiv(supply, usdValue, poolValue);\n}\n\nexport function marketTokenAmountToUsd(\n  marketInfo: MarketInfo,\n  marketToken: TokenData,\n  amount: bigint\n) {\n  const supply = marketToken.totalSupply!;\n  const poolValue = marketInfo.poolValueMax!;\n\n  const price =\n    supply == 0n\n      ? expandDecimals(1, USD_DECIMALS)\n      : bigMath.mulDiv(\n          poolValue,\n          expandDecimals(1, marketToken.decimals),\n          supply\n        );\n\n  return (amount * price) / expandDecimals(1, marketToken.decimals);\n}\n"]}