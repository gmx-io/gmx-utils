{"version":3,"sources":["../../../../../src/configs/chains.ts","../../../../../src/lib/bigmath/index.ts","../../../../../src/lib/errors/index.ts","../../../../../src/lib/metrics/index.ts","../../../../../src/lib/numbers/index.ts","../../../../../src/lib/gas/gasPrice.ts"],"names":[],"mappings":"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","file":"gasPrice.js","sourcesContent":["import { defineChain } from \"viem\";\nimport {\n  arbitrum,\n  arbitrumSepolia,\n  avalanche,\n  avalancheFuji,\n  base,\n  bsc,\n  Chain,\n  optimismSepolia,\n  sepolia,\n} from \"viem/chains\";\n\nimport { ContractsChainConfig, SourceChainConfig } from \"domain/chains/types\";\n\nimport {\n  ARBITRUM,\n  ARBITRUM_SEPOLIA,\n  AVALANCHE,\n  AVALANCHE_FUJI,\n  BOTANIX,\n  ETH_MAINNET,\n  SOURCE_BASE_MAINNET,\n  SOURCE_BSC_MAINNET,\n  SOURCE_OPTIMISM_SEPOLIA,\n  SOURCE_SEPOLIA,\n} from \"./chainIds\";\n\nexport {\n  ARBITRUM,\n  ARBITRUM_SEPOLIA,\n  AVALANCHE,\n  AVALANCHE_FUJI,\n  BOTANIX,\n  ETH_MAINNET,\n  SOURCE_BASE_MAINNET,\n  SOURCE_BSC_MAINNET,\n  SOURCE_OPTIMISM_SEPOLIA,\n  SOURCE_SEPOLIA,\n};\n\nexport const CONTRACTS_CHAIN_IDS = [ARBITRUM, AVALANCHE, BOTANIX] as const;\nexport const CONTRACTS_CHAIN_IDS_DEV = [\n  ...CONTRACTS_CHAIN_IDS,\n  AVALANCHE_FUJI,\n  ARBITRUM_SEPOLIA,\n] as const;\nexport const SETTLEMENT_CHAIN_IDS = [ARBITRUM, AVALANCHE] as const;\nexport const SETTLEMENT_CHAIN_IDS_DEV = [\n  ...SETTLEMENT_CHAIN_IDS,\n  ARBITRUM_SEPOLIA,\n] as const;\nexport const SOURCE_CHAIN_IDS = [\n  SOURCE_OPTIMISM_SEPOLIA,\n  SOURCE_SEPOLIA,\n  SOURCE_BASE_MAINNET,\n  SOURCE_BSC_MAINNET,\n] as const;\n\nexport type ContractsChainId = (typeof CONTRACTS_CHAIN_IDS_DEV)[number];\nexport type ContractsChainIdProduction = (typeof CONTRACTS_CHAIN_IDS)[number];\nexport type SettlementChainId = (typeof SETTLEMENT_CHAIN_IDS_DEV)[number];\nexport type SourceChainId = (typeof SOURCE_CHAIN_IDS)[number];\n\nexport type AnyChainId = ContractsChainId | SettlementChainId | SourceChainId;\n\nconst CONTRACTS_CHAIN_CONFIGS = {\n  [ARBITRUM]: {\n    chainId: ARBITRUM,\n    name: \"Arbitrum\",\n    slug: \"arbitrum\",\n    explorerUrl: \"https://arbiscan.io/\",\n    nativeTokenSymbol: \"ETH\",\n    wrappedTokenSymbol: \"WETH\",\n    defaultCollateralSymbol: \"USDC.e\",\n    highExecutionFee: 5,\n    shouldUseMaxPriorityFeePerGas: false,\n    defaultExecutionFeeBufferBps: 3000, // 30%\n    maxFeePerGas: undefined,\n    gasPricePremium: 0n,\n    maxPriorityFeePerGas: 1500000000n, // 1.5 gwei\n    excessiveExecutionFee: 10, // 10 USD\n    minExecutionFee: undefined,\n    gasPriceBuffer: 2000n, // 20%\n    isDisabled: false,\n  },\n  [AVALANCHE]: {\n    chainId: AVALANCHE,\n    name: \"Avalanche\",\n    slug: \"avalanche\",\n    explorerUrl: \"https://snowtrace.io/\",\n    nativeTokenSymbol: \"AVAX\",\n    wrappedTokenSymbol: \"WAVAX\",\n    defaultCollateralSymbol: \"USDC\",\n    highExecutionFee: 5,\n    shouldUseMaxPriorityFeePerGas: true,\n    defaultExecutionFeeBufferBps: 1000, // 10%\n    maxFeePerGas: 200000000000n, // 200 gwei\n    gasPricePremium: 6000000000n, // 6 gwei\n    maxPriorityFeePerGas: 1500000000n, // 1.5 gwei\n    excessiveExecutionFee: 10, // 10 USD\n    minExecutionFee: undefined,\n    gasPriceBuffer: undefined,\n    isDisabled: false,\n  },\n  [AVALANCHE_FUJI]: {\n    chainId: AVALANCHE_FUJI,\n    name: \"Avalanche Fuji\",\n    slug: \"fuji\",\n    explorerUrl: \"https://testnet.snowtrace.io/\",\n    nativeTokenSymbol: \"AVAX\",\n    wrappedTokenSymbol: \"WAVAX\",\n    defaultCollateralSymbol: \"USDC\",\n    highExecutionFee: 5,\n    shouldUseMaxPriorityFeePerGas: true,\n    defaultExecutionFeeBufferBps: 1000, // 10%\n    maxFeePerGas: undefined,\n    gasPricePremium: undefined,\n    maxPriorityFeePerGas: 1500000000n,\n    excessiveExecutionFee: 10, // 10 USD\n    minExecutionFee: undefined,\n    gasPriceBuffer: undefined,\n    isDisabled: false,\n  },\n  [ARBITRUM_SEPOLIA]: {\n    chainId: ARBITRUM_SEPOLIA,\n    name: \"Arbitrum Sepolia\",\n    slug: \"arbitrum-sepolia\",\n    explorerUrl: \"https://sepolia.arbiscan.io/\",\n    nativeTokenSymbol: \"ETH\",\n    wrappedTokenSymbol: \"WETH\",\n    defaultCollateralSymbol: \"USDC\",\n    highExecutionFee: 5,\n    shouldUseMaxPriorityFeePerGas: false,\n    defaultExecutionFeeBufferBps: 1000, // 10%\n    maxFeePerGas: undefined,\n    gasPricePremium: undefined,\n    maxPriorityFeePerGas: 1500000000n,\n    excessiveExecutionFee: 10, // 10 USD\n    minExecutionFee: undefined,\n    gasPriceBuffer: undefined,\n    isDisabled: false,\n  },\n  [BOTANIX]: {\n    chainId: BOTANIX,\n    name: \"Botanix\",\n    slug: \"botanix\",\n    explorerUrl: \"https://botanixscan.io/\",\n    nativeTokenSymbol: \"BTC\",\n    wrappedTokenSymbol: \"PBTC\",\n    defaultCollateralSymbol: \"USDC.E\",\n    highExecutionFee: 5,\n    shouldUseMaxPriorityFeePerGas: true,\n    defaultExecutionFeeBufferBps: 3000, // 30%\n    maxFeePerGas: 20n,\n    gasPricePremium: undefined,\n    maxPriorityFeePerGas: 7n,\n    excessiveExecutionFee: 10, // 10 USD\n    /**\n     * avoid botanix gas spikes when chain is not actively used\n     * if set, execution fee value should not be less than this in USD equivalent\n     */\n    minExecutionFee: 1000000000000000000000000000n, // 1e27 $0.001\n    gasPriceBuffer: undefined,\n    isDisabled: false,\n  },\n  // Use this notation to correctly infer chain names, etc. from config\n} as const satisfies Record<ContractsChainId, ContractsChainConfig>;\n\nconst SOURCE_CHAIN_CONFIGS = {\n  [SOURCE_OPTIMISM_SEPOLIA]: {\n    chainId: SOURCE_OPTIMISM_SEPOLIA,\n    name: \"Optimism Sepolia\",\n    slug: \"optimism-sepolia\",\n    explorerUrl: \"https://sepolia-optimism.etherscan.io/\",\n  },\n  [SOURCE_SEPOLIA]: {\n    chainId: SOURCE_SEPOLIA,\n    name: \"Sepolia\",\n    slug: \"sepolia\",\n    explorerUrl: \"https://sepolia.etherscan.io/\",\n  },\n  [SOURCE_BASE_MAINNET]: {\n    chainId: SOURCE_BASE_MAINNET,\n    name: \"Base\",\n    slug: \"base-mainnet\",\n    explorerUrl: \"https://basescan.org/\",\n  },\n  [SOURCE_BSC_MAINNET]: {\n    chainId: SOURCE_BSC_MAINNET,\n    name: \"BNB\",\n    slug: \"bnb-mainnet\",\n    explorerUrl: \"https://bscscan.com/\",\n  },\n  // Use this notation to correctly infer chain names, etc. from config\n} as const satisfies Record<SourceChainId, SourceChainConfig>;\n\nconst ALL_CHAIN_CONFIGS = {\n  ...CONTRACTS_CHAIN_CONFIGS,\n  ...SOURCE_CHAIN_CONFIGS,\n};\n\nexport type ContractsChainName =\n  (typeof CONTRACTS_CHAIN_CONFIGS)[keyof typeof CONTRACTS_CHAIN_CONFIGS][\"name\"];\nexport type SourceChainName =\n  (typeof SOURCE_CHAIN_CONFIGS)[keyof typeof SOURCE_CHAIN_CONFIGS][\"name\"];\nexport type ChainName = ContractsChainName | SourceChainName | \"Unknown\";\n\nexport type ContractsChainSlug =\n  (typeof CONTRACTS_CHAIN_CONFIGS)[keyof typeof CONTRACTS_CHAIN_CONFIGS][\"slug\"];\nexport type SourceChainSlug =\n  (typeof SOURCE_CHAIN_CONFIGS)[keyof typeof SOURCE_CHAIN_CONFIGS][\"slug\"];\nexport type ChainSlug = ContractsChainSlug | SourceChainSlug | \"unknown\";\n\nexport const botanix: Chain = defineChain({\n  id: BOTANIX,\n  name: \"Botanix\",\n  nativeCurrency: {\n    name: \"Bitcoin\",\n    symbol: \"BTC\",\n    decimals: 18,\n  },\n  rpcUrls: {\n    default: {\n      http: [\n        // this rpc returns incorrect gas price\n        // \"https://rpc.botanixlabs.com\",\n\n        \"https://rpc.ankr.com/botanix_mainnet\",\n      ],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: \"BotanixScan\",\n      url: \"https://botanixscan.io\",\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: \"0x4BaA24f93a657f0c1b4A0Ffc72B91011E35cA46b\",\n    },\n  },\n});\n\nconst VIEM_CHAIN_BY_CHAIN_ID: Record<AnyChainId, Chain> = {\n  [AVALANCHE_FUJI]: avalancheFuji,\n  [ARBITRUM]: arbitrum,\n  [AVALANCHE]: avalanche,\n  [ARBITRUM_SEPOLIA]: arbitrumSepolia,\n  [BOTANIX]: botanix,\n  [SOURCE_OPTIMISM_SEPOLIA]: optimismSepolia,\n  [SOURCE_SEPOLIA]: sepolia,\n  [SOURCE_BASE_MAINNET]: base,\n  [SOURCE_BSC_MAINNET]: bsc,\n};\n\nexport function getChainName(chainId: number): ChainName {\n  return ALL_CHAIN_CONFIGS[chainId]?.name ?? \"Unknown\";\n}\n\nexport function getChainSlug(chainId: number): ChainSlug {\n  return ALL_CHAIN_CONFIGS[chainId]?.slug ?? \"unknown\";\n}\n\nexport function getChainIdBySlug(slug: string): AnyChainId | undefined {\n  const chainId = Object.values(ALL_CHAIN_CONFIGS).find(\n    (config) => config.slug === slug\n  )?.chainId;\n\n  return chainId;\n}\n\nexport const getViemChain = (chainId: number): Chain => {\n  return VIEM_CHAIN_BY_CHAIN_ID[chainId];\n};\n\nexport function getHighExecutionFee(chainId: number) {\n  return CONTRACTS_CHAIN_CONFIGS[chainId]?.highExecutionFee ?? 5;\n}\n\nexport function getExcessiveExecutionFee(chainId: number) {\n  return CONTRACTS_CHAIN_CONFIGS[chainId]?.excessiveExecutionFee ?? 10;\n}\n\nexport function isContractsChain(\n  chainId: number,\n  dev = false\n): chainId is ContractsChainId {\n  return (dev ? CONTRACTS_CHAIN_IDS_DEV : CONTRACTS_CHAIN_IDS).includes(\n    chainId as any\n  );\n}\n\nexport function isTestnetChain(chainId: number): boolean {\n  return [AVALANCHE_FUJI, ARBITRUM_SEPOLIA].includes(chainId);\n}\n\nexport function getMaxFeePerGas(chainId: ContractsChainId): bigint | undefined {\n  return CONTRACTS_CHAIN_CONFIGS[chainId].maxFeePerGas;\n}\n\nexport function getGasPricePremium(\n  chainId: ContractsChainId\n): bigint | undefined {\n  return CONTRACTS_CHAIN_CONFIGS[chainId].gasPricePremium;\n}\n\nexport function getMaxPriorityFeePerGas(chainId: ContractsChainId) {\n  return CONTRACTS_CHAIN_CONFIGS[chainId].maxPriorityFeePerGas;\n}\n\nexport function getMinExecutionFeeUsd(chainId: ContractsChainId) {\n  return CONTRACTS_CHAIN_CONFIGS[chainId].minExecutionFee;\n}\n\nexport function getGasPriceBuffer(chainId: ContractsChainId) {\n  return CONTRACTS_CHAIN_CONFIGS[chainId].gasPriceBuffer;\n}\n\nexport function isChainDisabled(chainId: ContractsChainId) {\n  return CONTRACTS_CHAIN_CONFIGS[chainId]?.isDisabled ?? false;\n}\n\nexport function getChainNativeTokenSymbol(chainId: ContractsChainId) {\n  return CONTRACTS_CHAIN_CONFIGS[chainId].nativeTokenSymbol;\n}\n\nexport function getChainWrappedTokenSymbol(chainId: ContractsChainId) {\n  return CONTRACTS_CHAIN_CONFIGS[chainId].wrappedTokenSymbol;\n}\n\nexport function getChainDefaultCollateralSymbol(chainId: ContractsChainId) {\n  return CONTRACTS_CHAIN_CONFIGS[chainId].defaultCollateralSymbol;\n}\n\nexport function getExplorerUrl(\n  chainId: number | \"layerzero\" | \"layerzero-testnet\"\n): string {\n  switch (chainId as AnyChainId | \"layerzero\" | \"layerzero-testnet\") {\n    case \"layerzero\":\n      return \"https://layerzeroscan.com/\";\n    case \"layerzero-testnet\":\n      return \"https://testnet.layerzeroscan.com/\";\n    default:\n      return ALL_CHAIN_CONFIGS[chainId]?.explorerUrl ?? \"\";\n  }\n}\n\nexport function getTokenExplorerUrl(chainId: number, tokenAddress: string) {\n  return `${getExplorerUrl(chainId)}token/${tokenAddress}`;\n}\n\nexport function getExecutionFeeConfig(chainId: ContractsChainId):\n  | {\n      shouldUseMaxPriorityFeePerGas: boolean;\n      defaultBufferBps: number | undefined;\n    }\n  | undefined {\n  const config = CONTRACTS_CHAIN_CONFIGS[chainId];\n\n  if (!config) {\n    return undefined;\n  }\n\n  return {\n    shouldUseMaxPriorityFeePerGas: config.shouldUseMaxPriorityFeePerGas,\n    defaultBufferBps: config.defaultExecutionFeeBufferBps,\n  };\n}\n","export const bigMath = {\n  abs(x: bigint) {\n    return x < 0n ? -x : x;\n  },\n  mulDiv(x: bigint, y: bigint, z: bigint, roundUpMagnitude = false) {\n    const result = (x * y) / z;\n\n    if (roundUpMagnitude && this.mulmod(x, y, z) > 0n) {\n      return result + 1n;\n    }\n\n    return result;\n  },\n  max(max: bigint, ...rest: bigint[]) {\n    return rest.reduce((currentMax, val) => (currentMax < val ? val : currentMax), max);\n  },\n  min(min: bigint, ...rest: bigint[]) {\n    return rest.reduce((currentMin, val) => (currentMin > val ? val : currentMin), min);\n  },\n  avg(...values: (bigint | undefined)[]) {\n    let sum = 0n;\n    let count = 0n;\n    for (const value of values) {\n      if (value !== undefined) {\n        sum += value;\n        count += 1n;\n      }\n    }\n\n    if (count === 0n) {\n      return undefined;\n    }\n\n    return sum / count;\n  },\n  divRound(x: bigint, y: bigint) {\n    return x / y + ((x % y) * 2n > y ? 1n : 0n);\n  },\n  divRoundUp(x: bigint, y: bigint) {\n    return (x + y - 1n) / y;\n  },\n  mulmod(x: bigint, y: bigint, m: bigint): bigint {\n    return (x * y) % m;\n  },\n  clamp(value: bigint, min: bigint, max: bigint): bigint {\n    return bigMath.max(min, bigMath.min(value, max));\n  },\n};\n","export * from \"./parseError\";\nexport * from \"./transactionsErrors\";\n","export * from \"./emitMetricEvent\";\nexport * from \"./Metrics\";\nexport * from \"./types\";\nexport * from \"./utils\";\n\n\n\n\n\n","import { formatUnits, parseUnits } from \"viem\";\n\nimport { bigMath } from \"../bigmath\";\n\nexport type Numeric = number | bigint;\nexport type BigNumberish = string | Numeric;\n\nexport const USD_DECIMALS = 30;\n\nexport const BASIS_POINTS_DIVISOR = 10000;\nexport const BASIS_POINTS_DIVISOR_BIGINT = 10000n;\nexport const BASIS_POINTS_DECIMALS = 4;\n\nexport const PRECISION_DECIMALS = 30;\nexport const PRECISION = expandDecimals(1, PRECISION_DECIMALS);\n\nexport const BN_ZERO = 0n;\nexport const BN_ONE = 1n;\nexport const BN_NEGATIVE_ONE = -1n;\n\nexport const MaxUint256 = BigInt(\n  \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n);\n\nexport const PERCENT_PRECISION_DECIMALS = PRECISION_DECIMALS - 2;\n\nconst MAX_EXCEEDING_THRESHOLD = \"1000000000\";\nconst MIN_EXCEEDING_THRESHOLD = \"0.01\";\n\nexport const TRIGGER_PREFIX_ABOVE = \">\";\nexport const TRIGGER_PREFIX_BELOW = \"<\";\n\ndeclare const __nonZero: unique symbol;\nexport type NonZero<T extends number | bigint> = T & {\n  readonly [__nonZero]: true;\n};\n\nexport function isNonZero<T extends number | bigint>(\n  value: T\n): value is NonZero<T> {\n  return value !== 0 && value !== 0n;\n}\n\nexport function safeDivide<T extends number | bigint>(a: T, b: NonZero<T>): T {\n  return (a / b) as T;\n}\n\nexport function expandDecimals(n: BigNumberish, decimals: number): bigint {\n  return BigInt(n) * 10n ** BigInt(decimals);\n}\n\nexport function basisPointsToFloat(basisPoints: bigint) {\n  return (basisPoints * PRECISION) / BASIS_POINTS_DIVISOR_BIGINT;\n}\n\nexport function getBasisPoints(\n  numerator: bigint,\n  denominator: bigint,\n  shouldRoundUp = false\n) {\n  const result = (numerator * BASIS_POINTS_DIVISOR_BIGINT) / denominator;\n\n  if (shouldRoundUp) {\n    const remainder = (numerator * BASIS_POINTS_DIVISOR_BIGINT) % denominator;\n    if (remainder !== 0n) {\n      return result < 0n ? result - 1n : result + 1n;\n    }\n  }\n\n  return result;\n}\n\nexport function roundUpMagnitudeDivision(a: bigint, b: bigint) {\n  if (a < 0n) {\n    return (a - b + 1n) / b;\n  }\n\n  return (a + b - 1n) / b;\n}\n\nexport function applyFactor(value: bigint, factor: bigint) {\n  return (value * factor) / PRECISION;\n}\n\nexport function numberToBigint(value: number, decimals: number) {\n  const negative = value < 0;\n  if (negative) value *= -1;\n\n  const int = Math.trunc(value);\n  let frac = value - int;\n\n  let res = BigInt(int);\n\n  for (let i = 0; i < decimals; i++) {\n    res *= 10n;\n    if (frac !== 0) {\n      frac *= 10;\n      const fracInt = Math.trunc(frac);\n      res += BigInt(fracInt);\n      frac -= fracInt;\n    }\n  }\n\n  return negative ? -res : res;\n}\n\nexport const trimZeroDecimals = (amount: string) => {\n  if (parseFloat(amount) === parseInt(amount)) {\n    return parseInt(amount).toString();\n  }\n  return amount;\n};\n\nexport function bigintToNumber(value: bigint, decimals: number) {\n  const negative = value < 0;\n  if (negative) value *= -1n;\n  const precision = 10n ** BigInt(decimals);\n  const int = value / precision;\n  const frac = value % precision;\n\n  const num = parseFloat(`${int}.${frac.toString().padStart(decimals, \"0\")}`);\n  return negative ? -num : num;\n}\n\nexport function adjustForDecimals(\n  amount: bigint,\n  divDecimals: number,\n  mulDecimals: number\n) {\n  return (\n    (amount * expandDecimals(1, mulDecimals)) / expandDecimals(1, divDecimals)\n  );\n}\n\nexport function formatUsd(\n  usd?: bigint,\n  opts: {\n    fallbackToZero?: boolean;\n    displayDecimals?: number;\n    maxThreshold?: string | null;\n    minThreshold?: string;\n    displayPlus?: boolean;\n    visualMultiplier?: number;\n  } = {}\n) {\n  const { fallbackToZero = false, displayDecimals = 2 } = opts;\n\n  if (typeof usd !== \"bigint\") {\n    if (fallbackToZero) {\n      usd = 0n;\n    } else {\n      return undefined;\n    }\n  }\n\n  if (opts.visualMultiplier) {\n    usd *= BigInt(opts.visualMultiplier);\n  }\n\n  const defaultMinThreshold =\n    displayDecimals > 1\n      ? \"0.\" + \"0\".repeat(displayDecimals - 1) + \"1\"\n      : undefined;\n\n  const exceedingInfo = getLimitedDisplay(usd, USD_DECIMALS, {\n    maxThreshold: opts.maxThreshold,\n    minThreshold: opts.minThreshold ?? defaultMinThreshold,\n  });\n\n  const maybePlus = opts.displayPlus ? \"+\" : \"\";\n  const sign = usd < 0n ? \"-\" : maybePlus;\n  const symbol = exceedingInfo.symbol ? `${exceedingInfo.symbol}\\u00a0` : \"\";\n  const displayUsd = formatAmount(\n    exceedingInfo.value,\n    USD_DECIMALS,\n    displayDecimals,\n    true\n  );\n  return `${symbol}${sign}$\\u200a${displayUsd}`;\n}\n\nexport function formatBigUsd(\n  amount: bigint,\n  opts: { displayDecimals?: number } = {}\n) {\n  return formatUsd(amount, {\n    maxThreshold: \"9999999999999999999999999\",\n    displayDecimals: opts.displayDecimals ?? 0,\n  });\n}\n\nexport function formatDeltaUsd(\n  deltaUsd?: bigint,\n  percentage?: bigint,\n  opts: { fallbackToZero?: boolean; showPlusForZero?: boolean } = {}\n) {\n  if (typeof deltaUsd !== \"bigint\") {\n    if (opts.fallbackToZero) {\n      return `${formatUsd(0n)} (${formatAmount(0n, 2, 2)}%)`;\n    }\n\n    return undefined;\n  }\n\n  const sign = getPlusOrMinusSymbol(deltaUsd, {\n    showPlusForZero: opts.showPlusForZero,\n  });\n\n  const exceedingInfo = getLimitedDisplay(deltaUsd, USD_DECIMALS);\n  const percentageStr =\n    percentage !== undefined\n      ? ` (${sign}${formatPercentage(bigMath.abs(percentage))})`\n      : \"\";\n  const deltaUsdStr = formatAmount(exceedingInfo.value, USD_DECIMALS, 2, true);\n  const symbol = exceedingInfo.symbol ? `${exceedingInfo.symbol} ` : \"\";\n\n  return `${symbol}${sign}$\\u200a${deltaUsdStr}${percentageStr}`;\n}\n\nexport function formatPercentage(\n  percentage?: bigint,\n  opts: {\n    fallbackToZero?: boolean;\n    signed?: boolean;\n    displayDecimals?: number;\n    bps?: boolean;\n    showPlus?: boolean;\n  } = {}\n) {\n  const {\n    fallbackToZero = false,\n    signed = false,\n    displayDecimals = 2,\n    bps = true,\n    showPlus = true,\n  } = opts;\n\n  if (percentage === undefined) {\n    if (fallbackToZero) {\n      return `${formatAmount(\n        0n,\n        PERCENT_PRECISION_DECIMALS,\n        displayDecimals\n      )}%`;\n    }\n\n    return undefined;\n  }\n\n  const sign = signed ? `${getPlusOrMinusSymbol(percentage)}` : \"\";\n  const displaySign = !showPlus && sign === \"+\" ? \"\" : `${sign}`;\n\n  return `${displaySign}${displaySign ? \"\\u200a\" : \"\"}${formatAmount(\n    bigMath.abs(percentage),\n    bps ? 2 : PERCENT_PRECISION_DECIMALS,\n    displayDecimals\n  )}%`;\n}\n\nexport function formatTokenAmount(\n  amount?: bigint,\n  tokenDecimals?: number,\n  symbol?: string,\n  opts: {\n    showAllSignificant?: boolean;\n    displayDecimals?: number;\n    fallbackToZero?: boolean;\n    useCommas?: boolean;\n    minThreshold?: string;\n    maxThreshold?: string;\n    displayPlus?: boolean;\n    isStable?: boolean;\n  } = {}\n) {\n  const {\n    showAllSignificant = false,\n    fallbackToZero = false,\n    useCommas = false,\n    minThreshold = \"0\",\n    maxThreshold,\n  } = opts;\n\n  const displayDecimals = opts.displayDecimals ?? (opts.isStable ? 2 : 4);\n\n  const symbolStr = symbol ? ` ${symbol}` : \"\";\n\n  if (typeof amount !== \"bigint\" || !tokenDecimals) {\n    if (fallbackToZero) {\n      amount = 0n;\n      tokenDecimals = displayDecimals;\n    } else {\n      return undefined;\n    }\n  }\n\n  let amountStr: string;\n\n  const maybePlus = opts.displayPlus ? \"+\" : \"\";\n  const sign = amount < 0n ? \"-\" : maybePlus;\n\n  if (showAllSignificant) {\n    amountStr = formatAmountFree(amount, tokenDecimals, tokenDecimals);\n  } else {\n    const exceedingInfo = getLimitedDisplay(amount, tokenDecimals, {\n      maxThreshold,\n      minThreshold,\n    });\n    const symbol = exceedingInfo.symbol ? `${exceedingInfo.symbol} ` : \"\";\n    amountStr = `${symbol}${sign}${formatAmount(\n      exceedingInfo.value,\n      tokenDecimals,\n      displayDecimals,\n      useCommas,\n      undefined\n    )}`;\n  }\n\n  return `${amountStr}${symbolStr}`;\n}\n\nexport function formatTokenAmountWithUsd(\n  tokenAmount?: bigint,\n  usdAmount?: bigint,\n  tokenSymbol?: string,\n  tokenDecimals?: number,\n  opts: {\n    fallbackToZero?: boolean;\n    displayDecimals?: number;\n    displayPlus?: boolean;\n    isStable?: boolean;\n  } = {}\n) {\n  if (\n    typeof tokenAmount !== \"bigint\" ||\n    typeof usdAmount !== \"bigint\" ||\n    !tokenSymbol ||\n    !tokenDecimals\n  ) {\n    if (!opts.fallbackToZero) {\n      return undefined;\n    }\n  }\n\n  const tokenStr = formatTokenAmount(tokenAmount, tokenDecimals, tokenSymbol, {\n    ...opts,\n    useCommas: true,\n    displayPlus: opts.displayPlus,\n  });\n\n  const usdStr = formatUsd(usdAmount, {\n    fallbackToZero: opts.fallbackToZero,\n    displayPlus: opts.displayPlus,\n  });\n\n  return `${tokenStr} (${usdStr})`;\n}\n\n/**\n *\n * @param opts.signed - Default `true`. whether to display a `+` or `-` sign for all non-zero values.\n */\nexport function formatRatePercentage(\n  rate?: bigint,\n  opts?: { displayDecimals?: number; signed?: boolean }\n) {\n  if (typeof rate !== \"bigint\") {\n    return \"-\";\n  }\n\n  const signed = opts?.signed ?? true;\n  const plurOrMinus = signed ? getPlusOrMinusSymbol(rate) : \"\";\n\n  const amount = bigMath.abs(rate * 100n);\n  return `${plurOrMinus}\\u200a${formatAmount(\n    amount,\n    30,\n    opts?.displayDecimals ?? 4\n  )}%`;\n}\n\nexport function formatUsdPrice(\n  price?: bigint,\n  opts: Parameters<typeof formatUsd>[1] = {}\n) {\n  if (price === undefined) {\n    return;\n  }\n\n  if (price < 0n) {\n    return \"NA\";\n  }\n\n  const decimals = calculateDisplayDecimals(\n    price,\n    undefined,\n    opts.visualMultiplier\n  );\n\n  return formatUsd(price, {\n    ...opts,\n    displayDecimals: decimals,\n  });\n}\n\nexport function formatPercentageDisplay(\n  percentage: number,\n  hideThreshold?: number\n) {\n  if (hideThreshold && percentage < hideThreshold) {\n    return \"\";\n  }\n\n  return `${percentage}%`;\n}\n\nexport function formatAmountHuman(\n  amount: BigNumberish | undefined,\n  tokenDecimals: number,\n  showDollar = false,\n  displayDecimals = 1\n) {\n  if (amount === undefined) {\n    return \"...\";\n  }\n\n  let n = Number(formatAmount(amount, tokenDecimals));\n  // For large numbers, we can neglect the decimals to avoid decimals in cases like 9999999.99999\n  if (n >= 1_000_000) {\n    n = Math.round(n);\n  }\n  const isNegative = n < 0;\n  const absN = Math.abs(n);\n  const sign = showDollar ? \"$\\u200a\" : \"\";\n\n  if (absN >= 1_000_000_000) {\n    return `${isNegative ? \"-\" : \"\"}${sign}${(absN / 1_000_000_000).toFixed(\n      displayDecimals\n    )}b`;\n  }\n\n  if (absN >= 1_000_000) {\n    return `${isNegative ? \"-\" : \"\"}${sign}${(absN / 1_000_000).toFixed(\n      displayDecimals\n    )}m`;\n  }\n\n  if (absN >= 1000) {\n    return `${isNegative ? \"-\" : \"\"}${sign}${(absN / 1_000).toFixed(\n      displayDecimals\n    )}k`;\n  }\n\n  return `${isNegative ? \"-\" : \"\"}${sign}${absN.toFixed(displayDecimals)}`;\n}\n\nexport function formatBalanceAmount(\n  amount: bigint,\n  tokenDecimals: number,\n  tokenSymbol?: string,\n  {\n    showZero = false,\n    toExponential = true,\n    isStable = false,\n    signed = false,\n  }: {\n    showZero?: boolean;\n    toExponential?: boolean;\n    isStable?: boolean;\n    signed?: boolean;\n  } = {}\n): string {\n  if (amount === undefined) return \"-\";\n\n  if (amount === 0n) {\n    if (showZero === true) {\n      if (tokenSymbol) {\n        if (isStable) {\n          return `0.00 ${tokenSymbol}`;\n        }\n        return `0.0000 ${tokenSymbol}`;\n      }\n      if (isStable) {\n        return \"0.00\";\n      }\n      return \"0.0000\";\n    }\n\n    return \"-\";\n  }\n\n  const sign = signed || amount < 0n ? getPlusOrMinusSymbol(amount) : \"\";\n  const absAmount = bigMath.abs(amount);\n  const absAmountFloat = bigintToNumber(absAmount, tokenDecimals);\n\n  let value = \"\";\n\n  const baseDecimals = isStable ? 2 : 4;\n  if (absAmountFloat >= 1)\n    value = formatAmount(absAmount, tokenDecimals, baseDecimals, true);\n  else if (absAmountFloat >= 0.1)\n    value = formatAmount(absAmount, tokenDecimals, baseDecimals + 1, true);\n  else if (absAmountFloat >= 0.01)\n    value = formatAmount(absAmount, tokenDecimals, baseDecimals + 2, true);\n  else if (absAmountFloat >= 0.001)\n    value = formatAmount(absAmount, tokenDecimals, baseDecimals + 3, true);\n  else if (absAmountFloat >= 1e-8)\n    value = formatAmount(absAmount, tokenDecimals, 8, true);\n  else {\n    if (toExponential) {\n      value = bigintToNumber(absAmount, tokenDecimals).toExponential(2);\n    } else {\n      value = bigintToNumber(absAmount, tokenDecimals).toFixed(8);\n    }\n  }\n\n  if (tokenSymbol) {\n    // Non-breaking space\n    return `${sign}${value} ${tokenSymbol}`;\n  }\n\n  return `${sign}${value}`;\n}\n\nexport function formatFactor(factor: bigint) {\n  if (factor == 0n) {\n    return \"0\";\n  }\n\n  if (bigMath.abs(factor) > PRECISION * 1000n) {\n    return (factor / PRECISION).toString();\n  }\n\n  const trailingZeroes =\n    bigMath\n      .abs(factor)\n      .toString()\n      .match(/^(.+?)(?<zeroes>0*)$/)?.groups?.zeroes?.length || 0;\n  const factorDecimals = 30 - trailingZeroes;\n  return formatAmount(factor, 30, factorDecimals);\n}\nexport function numberWithCommas(\n  x: BigNumberish,\n  { showDollar = false }: { showDollar?: boolean } = {}\n) {\n  if (x === undefined || x === null) {\n    return \"...\";\n  }\n\n  const parts = x.toString().split(\".\");\n  parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n  return `${showDollar ? \"$\\u200a\" : \"\"}${parts.join(\".\")}`;\n}\n\nexport const formatAmount = (\n  amount: BigNumberish | undefined,\n  tokenDecimals: number,\n  displayDecimals?: number,\n  useCommas?: boolean,\n  defaultValue?: string,\n  visualMultiplier?: number\n) => {\n  if (defaultValue === undefined || defaultValue === null) {\n    defaultValue = \"...\";\n  }\n  if (amount === undefined || amount === null || amount === \"\") {\n    return defaultValue;\n  }\n  if (displayDecimals === undefined) {\n    displayDecimals = 4;\n  }\n  const amountBigInt = roundWithDecimals(\n    BigInt(amount) * BigInt(visualMultiplier ?? 1),\n    {\n      displayDecimals,\n      decimals: tokenDecimals,\n    }\n  );\n  let amountStr = formatUnits(amountBigInt, tokenDecimals);\n  amountStr = limitDecimals(amountStr, displayDecimals);\n  if (displayDecimals !== 0) {\n    amountStr = padDecimals(amountStr, displayDecimals);\n  }\n  if (useCommas) {\n    return numberWithCommas(amountStr);\n  }\n  return amountStr;\n};\n\nexport const formatKeyAmount = <T extends {}>(\n  map: T | undefined,\n  key: keyof T,\n  tokenDecimals: number,\n  displayDecimals: number,\n  useCommas?: boolean\n) => {\n  const value = map ? map[key] ?? undefined : undefined;\n  if (value === undefined || value === null) {\n    return \"...\";\n  }\n\n  return formatAmount(\n    value as bigint,\n    tokenDecimals,\n    displayDecimals,\n    useCommas\n  );\n};\n\nexport const formatArrayAmount = (\n  arr: any[],\n  index: number,\n  tokenDecimals: number,\n  displayDecimals?: number,\n  useCommas?: boolean\n) => {\n  if (!arr || arr[index] === undefined || arr[index] === null) {\n    return \"...\";\n  }\n\n  return formatAmount(arr[index], tokenDecimals, displayDecimals, useCommas);\n};\n\nexport const formatAmountFree = (\n  amount: BigNumberish,\n  tokenDecimals: number,\n  displayDecimals?: number\n) => {\n  if (amount === undefined || amount === null) {\n    return \"...\";\n  }\n\n  amount = BigInt(amount);\n\n  let amountStr = formatUnits(amount, tokenDecimals);\n  amountStr = limitDecimals(amountStr, displayDecimals);\n  return trimZeroDecimals(amountStr);\n};\n\nexport function getLimitedDisplay(\n  amount: bigint,\n  tokenDecimals: number,\n  opts: { maxThreshold?: BigNumberish | null; minThreshold?: BigNumberish } = {}\n) {\n  const {\n    maxThreshold = MAX_EXCEEDING_THRESHOLD,\n    minThreshold = MIN_EXCEEDING_THRESHOLD,\n  } = opts;\n  const max =\n    maxThreshold === null\n      ? null\n      : expandDecimals(BigInt(maxThreshold), tokenDecimals);\n  const min = parseUnits(minThreshold.toString(), tokenDecimals);\n  const absAmount = bigMath.abs(amount);\n\n  if (absAmount == 0n) {\n    return {\n      symbol: \"\",\n      value: absAmount,\n    };\n  }\n\n  const symbol =\n    max !== null && absAmount > max\n      ? TRIGGER_PREFIX_ABOVE\n      : absAmount < min\n      ? TRIGGER_PREFIX_BELOW\n      : \"\";\n  const value =\n    max !== null && absAmount > max ? max : absAmount < min ? min : absAmount;\n\n  return {\n    symbol,\n    value,\n  };\n}\n\nexport const limitDecimals = (amount: BigNumberish, maxDecimals?: number) => {\n  let amountStr = amount.toString();\n  if (maxDecimals === undefined) {\n    return amountStr;\n  }\n  if (maxDecimals === 0) {\n    return amountStr.split(\".\")[0];\n  }\n  const dotIndex = amountStr.indexOf(\".\");\n  if (dotIndex !== -1) {\n    let decimals = amountStr.length - dotIndex - 1;\n    if (decimals > maxDecimals) {\n      amountStr = amountStr.substr(\n        0,\n        amountStr.length - (decimals - maxDecimals)\n      );\n    }\n  }\n\n  return amountStr;\n};\n\nexport const padDecimals = (amount: BigNumberish, minDecimals: number) => {\n  let amountStr = amount.toString();\n  const dotIndex = amountStr.indexOf(\".\");\n  if (dotIndex !== -1) {\n    const decimals = amountStr.length - dotIndex - 1;\n    if (decimals < minDecimals) {\n      amountStr = amountStr.padEnd(\n        amountStr.length + (minDecimals - decimals),\n        \"0\"\n      );\n    }\n  } else {\n    amountStr = amountStr + \".\" + \"0\".repeat(minDecimals);\n  }\n  return amountStr;\n};\n\nexport function getPlusOrMinusSymbol(\n  value?: bigint,\n  opts: { showPlusForZero?: boolean } = {}\n): string {\n  if (value === undefined) {\n    return \"\";\n  }\n\n  const { showPlusForZero = false } = opts;\n  return value === 0n ? (showPlusForZero ? \"+\" : \"\") : value < 0n ? \"-\" : \"+\";\n}\n\nexport function roundWithDecimals(\n  value: BigNumberish,\n  opts: { displayDecimals: number; decimals: number }\n): bigint {\n  if (opts.displayDecimals === opts.decimals) {\n    return BigInt(value);\n  }\n\n  let valueString = value.toString();\n  let isNegative = false;\n\n  if (valueString[0] === \"-\") {\n    valueString = valueString.slice(1);\n    isNegative = true;\n  }\n\n  if (valueString.length < opts.decimals) {\n    valueString = valueString.padStart(opts.decimals, \"0\");\n  }\n\n  const mainPart = valueString.slice(\n    0,\n    valueString.length - opts.decimals + opts.displayDecimals\n  );\n  const partToRound = valueString.slice(\n    valueString.length - opts.decimals + opts.displayDecimals\n  );\n\n  let mainPartBigInt = BigInt(mainPart);\n\n  let returnValue = mainPartBigInt;\n\n  if (partToRound.length !== 0) {\n    if (Number(partToRound[0]) >= 5) {\n      mainPartBigInt += 1n;\n    }\n\n    returnValue = BigInt(\n      mainPartBigInt.toString() +\n        new Array(partToRound.length).fill(\"0\").join(\"\")\n    );\n  }\n\n  return isNegative ? returnValue * -1n : returnValue;\n}\n\n// TODO: Remove this function\nexport function toBigNumberWithDecimals(\n  value: string,\n  decimals: number\n): bigint {\n  if (!value) return BN_ZERO;\n\n  const parts = value.split(\".\");\n  const integerPart = parts[0];\n  const decimalPart = parts.length > 1 ? parts[1] : \"\";\n\n  const paddingZeros = decimals - decimalPart.length;\n\n  if (paddingZeros >= 0) {\n    const result = integerPart + decimalPart + \"0\".repeat(paddingZeros);\n    return BigInt(result);\n  } else {\n    const result = integerPart + decimalPart.substring(0, decimals);\n    return BigInt(result);\n  }\n}\n\n/**\n *\n * @deprecated Use BigInt instead\n */\nexport function bigNumberify(n?: BigNumberish | null | undefined) {\n  try {\n    if (n === undefined) throw new Error(\"n is undefined\");\n    if (n === null) throw new Error(\"n is null\");\n\n    return BigInt(n);\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(\"bigNumberify error\", e);\n    return undefined;\n  }\n}\n\nexport const parseValue = (value: string, tokenDecimals: number) => {\n  const pValue = parseFloat(value);\n\n  if (isNaN(pValue)) {\n    return undefined;\n  }\n  value = limitDecimals(value, tokenDecimals);\n  const amount = parseUnits(value, tokenDecimals);\n  return bigNumberify(amount);\n};\n\nexport function roundUpDivision(a: bigint, b: bigint) {\n  return (a + b - 1n) / b;\n}\n\nexport function roundToTwoDecimals(n: number) {\n  return Math.round(n * 100) / 100;\n}\n\nexport function roundToOrder(n: bigint, significantDigits = 1) {\n  const decimals = Math.max(n.toString().length - significantDigits, 0);\n  return (n / expandDecimals(1, decimals)) * expandDecimals(1, decimals);\n}\n\nexport function roundBigIntToDecimals(\n  value: bigint,\n  tokenDecimals: number,\n  roundToDecimals: number\n): bigint {\n  const excessDecimals = tokenDecimals - roundToDecimals;\n  const divisor = BigInt(10 ** excessDecimals);\n  const scaledValue = value / divisor;\n  const remainder = scaledValue % 10n;\n  const roundedValue =\n    remainder >= 5n ? scaledValue + 10n - remainder : scaledValue - remainder;\n  return roundedValue * divisor;\n}\n\nexport function minBigNumber(...args: bigint[]) {\n  if (!args.length) return undefined;\n\n  return args.reduce((acc, num) => (num < acc ? num : acc), args[0]);\n}\n\nexport function maxbigint(...args: bigint[]) {\n  if (!args.length) return undefined;\n\n  return args.reduce((acc, num) => (num > acc ? num : acc), args[0]);\n}\n\nexport function removeTrailingZeros(amount: string | number) {\n  const amountWithoutZeros = Number(amount);\n  if (!amountWithoutZeros) return amount;\n  return amountWithoutZeros;\n}\n\ntype SerializedBigIntsInObject<T> = {\n  [P in keyof T]: T[P] extends bigint\n    ? { type: \"bigint\"; value: bigint }\n    : T[P] extends object\n    ? SerializedBigIntsInObject<T[P]>\n    : T[P];\n};\n\ntype DeserializeBigIntInObject<T> = {\n  [P in keyof T]: T[P] extends { type: \"bigint\"; value: bigint }\n    ? bigint\n    : T[P] extends object\n    ? DeserializeBigIntInObject<T[P]>\n    : T[P];\n};\n\nexport function serializeBigIntsInObject<T extends object>(\n  obj: T\n): SerializedBigIntsInObject<T> {\n  const result: any = Array.isArray(obj) ? [] : {};\n  for (const key in obj) {\n    const value = obj[key];\n    if (typeof value === \"bigint\") {\n      result[key] = { type: \"bigint\", value: String(value) };\n    } else if (value && typeof value === \"object\") {\n      result[key] = serializeBigIntsInObject(value);\n    } else {\n      result[key] = value;\n    }\n  }\n  return result;\n}\n\nexport function deserializeBigIntsInObject<T extends object>(\n  obj: T\n): DeserializeBigIntInObject<T> {\n  const result: any = Array.isArray(obj) ? [] : {};\n  for (const key in obj) {\n    const value = obj[key];\n    if (\n      typeof value === \"object\" &&\n      value !== null &&\n      ((\"type\" in value && value.type === \"bigint\") ||\n        (\"_type\" in value && value._type === \"BigNumber\"))\n    ) {\n      if (\"value\" in value && typeof value.value === \"string\") {\n        result[key] = BigInt(value.value);\n      } else if (\"hex\" in value && typeof value.hex === \"string\") {\n        if (value.hex.startsWith(\"-\")) {\n          result[key] = BigInt(value.hex.slice(1)) * -1n;\n        } else {\n          result[key] = BigInt(value.hex);\n        }\n      }\n    } else if (value && typeof value === \"object\") {\n      result[key] = deserializeBigIntsInObject(value);\n    } else {\n      result[key] = value;\n    }\n  }\n  return result;\n}\n\nexport function calculateDisplayDecimals(\n  price?: bigint,\n  decimals = USD_DECIMALS,\n  visualMultiplier = 1,\n  isStable = false\n) {\n  if (price === undefined || price === 0n) return 2;\n  const priceNumber = bigintToNumber(\n    bigMath.abs(price) * BigInt(visualMultiplier),\n    decimals\n  );\n\n  if (isNaN(priceNumber)) return 2;\n  if (isStable) {\n    if (priceNumber >= 0.1) return 2;\n    if (priceNumber >= 0.01) return 3;\n    if (priceNumber >= 0.001) return 4;\n    if (priceNumber >= 0.0001) return 5;\n    if (priceNumber >= 0.00001) return 6;\n    if (priceNumber >= 0.000001) return 7;\n    if (priceNumber >= 0.0000001) return 8;\n    if (priceNumber >= 0.00000001) return 9;\n  } else {\n    if (priceNumber >= 1000) return 2;\n    if (priceNumber >= 100) return 3;\n    if (priceNumber >= 1) return 4;\n    if (priceNumber >= 0.1) return 5;\n    if (priceNumber >= 0.01) return 6;\n    if (priceNumber >= 0.0001) return 7;\n    if (priceNumber >= 0.00001) return 8;\n  }\n\n  return 9;\n}\n\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(value, max));\n}\n\nexport function absDiffBps(value: bigint, base: bigint) {\n  if ((value === 0n && base !== 0n) || (value !== 0n && base === 0n)) {\n    return BASIS_POINTS_DIVISOR_BIGINT;\n  }\n\n  if (value === 0n && base === 0n) {\n    return 0n;\n  }\n\n  return bigMath.mulDiv(\n    bigMath.abs(value - base),\n    BASIS_POINTS_DIVISOR_BIGINT,\n    base\n  );\n}\n","import { withRetry } from \"viem\";\n\nimport {\n  ContractsChainId,\n  getGasPriceBuffer,\n  getGasPricePremium,\n  getMaxFeePerGas,\n  getMaxPriorityFeePerGas,\n} from \"configs/chains\";\nimport { bigMath } from \"lib/bigmath\";\nimport { extendError } from \"lib/errors\";\nimport { emitMetricCounter } from \"lib/metrics\";\nimport { BASIS_POINTS_DIVISOR_BIGINT } from \"lib/numbers\";\nimport { iRpc } from \"lib/rpc/types\";\n\nexport type GasPriceData =\n  | {\n      gasPrice: bigint;\n    }\n  // Avalanche\n  | {\n      maxFeePerGas: bigint;\n      maxPriorityFeePerGas: bigint;\n    };\n\nexport async function getGasPrice(\n  chainId: number,\n  rpc: iRpc\n): Promise<GasPriceData> {\n  try {\n    let maxFeePerGas = getMaxFeePerGas(chainId as ContractsChainId);\n\n    const premium: bigint =\n      getGasPricePremium(chainId as ContractsChainId) || 0n;\n\n    const feeData = await withRetry(\n      () =>\n        rpc.estimateFeesPerGas({\n          chainId,\n        }),\n      {\n        delay: 200,\n        retryCount: 2,\n        shouldRetry: ({ error }) => {\n          const isInvalidBlockError = error?.message?.includes(\n            \"invalid value for value.hash\"\n          );\n\n          if (isInvalidBlockError) {\n            emitMetricCounter({ event: \"error.getFeeData.value.hash\" });\n          }\n\n          return isInvalidBlockError;\n        },\n      }\n    );\n\n    const gasPrice = feeData.gasPrice;\n\n    if (maxFeePerGas !== undefined) {\n      if (gasPrice !== undefined && gasPrice !== null) {\n        maxFeePerGas = bigMath.max(gasPrice, maxFeePerGas);\n      }\n\n      // Fetch the latest block to get baseFeePerGas for EIP-1559 fee data\n      const block = await rpc.getBlock({ blockTag: \"pending\" });\n      if (block.baseFeePerGas !== undefined && block.baseFeePerGas !== null) {\n        const baseFeePerGas = block.baseFeePerGas;\n\n        const maxPriorityFeePerGas = bigMath.max(\n          feeData.maxPriorityFeePerGas ?? 0n,\n          getMaxPriorityFeePerGas(chainId as ContractsChainId) || 0n\n        );\n\n        // Calculate maxFeePerGas\n        const calculatedMaxFeePerGas =\n          baseFeePerGas + maxPriorityFeePerGas + premium;\n\n        return {\n          maxFeePerGas: bigMath.max(maxFeePerGas, calculatedMaxFeePerGas),\n          maxPriorityFeePerGas: maxPriorityFeePerGas + premium,\n        };\n      }\n    }\n\n    if (gasPrice === null || gasPrice === undefined) {\n      throw new Error(\"Can't fetch gas price\");\n    }\n\n    const bufferBps: bigint =\n      getGasPriceBuffer(chainId as ContractsChainId) || 0n;\n\n    const buffer = bigMath.mulDiv(\n      gasPrice,\n      bufferBps,\n      BASIS_POINTS_DIVISOR_BIGINT\n    );\n\n    return {\n      gasPrice: gasPrice + buffer + premium,\n    };\n  } catch (error: any) {\n    throw extendError(error, {\n      errorContext: \"gasPrice\",\n    });\n  }\n}\n"]}