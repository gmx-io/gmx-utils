{"version":3,"sources":["../../../../../src/lib/bigmath/index.ts"],"names":[],"mappings":"AAAO,MAAM,OAAA,GAAU;AAAA,EACrB,IAAI,CAAA,EAAW;AACb,IAAA,OAAO,CAAA,GAAI,EAAA,GAAK,CAAC,CAAA,GAAI,CAAA;AAAA,EACvB,CAAA;AAAA,EACA,MAAA,CAAO,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW,mBAAmB,KAAA,EAAO;AAChE,IAAA,MAAM,MAAA,GAAU,IAAI,CAAA,GAAK,CAAA;AAEzB,IAAA,IAAI,oBAAoB,IAAA,CAAK,MAAA,CAAO,GAAG,CAAA,EAAG,CAAC,IAAI,EAAA,EAAI;AACjD,MAAA,OAAO,MAAA,GAAS,EAAA;AAAA,IAClB;AAEA,IAAA,OAAO,MAAA;AAAA,EACT,CAAA;AAAA,EACA,GAAA,CAAI,QAAgB,IAAA,EAAgB;AAClC,IAAA,OAAO,IAAA,CAAK,OAAO,CAAC,UAAA,EAAY,QAAS,UAAA,GAAa,GAAA,GAAM,GAAA,GAAM,UAAA,EAAa,GAAG,CAAA;AAAA,EACpF,CAAA;AAAA,EACA,GAAA,CAAI,QAAgB,IAAA,EAAgB;AAClC,IAAA,OAAO,IAAA,CAAK,OAAO,CAAC,UAAA,EAAY,QAAS,UAAA,GAAa,GAAA,GAAM,GAAA,GAAM,UAAA,EAAa,GAAG,CAAA;AAAA,EACpF,CAAA;AAAA,EACA,OAAO,MAAA,EAAgC;AACrC,IAAA,IAAI,GAAA,GAAM,EAAA;AACV,IAAA,IAAI,KAAA,GAAQ,EAAA;AACZ,IAAA,KAAA,MAAW,SAAS,MAAA,EAAQ;AAC1B,MAAA,IAAI,UAAU,MAAA,EAAW;AACvB,QAAA,GAAA,IAAO,KAAA;AACP,QAAA,KAAA,IAAS,EAAA;AAAA,MACX;AAAA,IACF;AAEA,IAAA,IAAI,UAAU,EAAA,EAAI;AAChB,MAAA,OAAO,MAAA;AAAA,IACT;AAEA,IAAA,OAAO,GAAA,GAAM,KAAA;AAAA,EACf,CAAA;AAAA,EACA,QAAA,CAAS,GAAW,CAAA,EAAW;AAC7B,IAAA,OAAO,IAAI,CAAA,IAAM,CAAA,GAAI,CAAA,GAAK,EAAA,GAAK,IAAI,EAAA,GAAK,EAAA,CAAA;AAAA,EAC1C,CAAA;AAAA,EACA,UAAA,CAAW,GAAW,CAAA,EAAW;AAC/B,IAAA,OAAA,CAAQ,CAAA,GAAI,IAAI,EAAA,IAAM,CAAA;AAAA,EACxB,CAAA;AAAA,EACA,MAAA,CAAO,CAAA,EAAW,CAAA,EAAW,CAAA,EAAmB;AAC9C,IAAA,OAAQ,IAAI,CAAA,GAAK,CAAA;AAAA,EACnB,CAAA;AAAA,EACA,KAAA,CAAM,KAAA,EAAe,GAAA,EAAa,GAAA,EAAqB;AACrD,IAAA,OAAO,QAAQ,GAAA,CAAI,GAAA,EAAK,QAAQ,GAAA,CAAI,KAAA,EAAO,GAAG,CAAC,CAAA;AAAA,EACjD;AACF","file":"index.js","sourcesContent":["export const bigMath = {\n  abs(x: bigint) {\n    return x < 0n ? -x : x;\n  },\n  mulDiv(x: bigint, y: bigint, z: bigint, roundUpMagnitude = false) {\n    const result = (x * y) / z;\n\n    if (roundUpMagnitude && this.mulmod(x, y, z) > 0n) {\n      return result + 1n;\n    }\n\n    return result;\n  },\n  max(max: bigint, ...rest: bigint[]) {\n    return rest.reduce((currentMax, val) => (currentMax < val ? val : currentMax), max);\n  },\n  min(min: bigint, ...rest: bigint[]) {\n    return rest.reduce((currentMin, val) => (currentMin > val ? val : currentMin), min);\n  },\n  avg(...values: (bigint | undefined)[]) {\n    let sum = 0n;\n    let count = 0n;\n    for (const value of values) {\n      if (value !== undefined) {\n        sum += value;\n        count += 1n;\n      }\n    }\n\n    if (count === 0n) {\n      return undefined;\n    }\n\n    return sum / count;\n  },\n  divRound(x: bigint, y: bigint) {\n    return x / y + ((x % y) * 2n > y ? 1n : 0n);\n  },\n  divRoundUp(x: bigint, y: bigint) {\n    return (x + y - 1n) / y;\n  },\n  mulmod(x: bigint, y: bigint, m: bigint): bigint {\n    return (x * y) % m;\n  },\n  clamp(value: bigint, min: bigint, max: bigint): bigint {\n    return bigMath.max(min, bigMath.min(value, max));\n  },\n};\n"]}