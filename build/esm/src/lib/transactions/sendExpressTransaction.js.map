{"version":3,"sources":["../../../../../src/lib/transactions/sendExpressTransaction.ts"],"names":[],"mappings":"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","file":"sendExpressTransaction.js","sourcesContent":["import { Address, encodePacked } from \"viem\";\n\nimport { ContractsChainId } from \"configs/chains\";\nimport { GELATO_API_KEYS } from \"configs/express\";\nimport { gelatoRelay } from \"lib/gelatoRelay/gelatoRelay\";\nimport { emitMetricTiming } from \"lib/metrics\";\nimport { sleep } from \"lib/sleep/sleep\";\n\nimport {\n  TaskState,\n  type GelatoTaskStatus,\n  type TransactionWaiterResult,\n} from \"./types\";\n\nexport type ExpressTxnData = {\n  callData: string;\n  to: string;\n  feeToken: string;\n  feeAmount: bigint;\n};\n\nexport type ExpressTxnResult = {\n  taskId: string;\n  wait: () => Promise<TransactionWaiterResult>;\n};\n\nexport async function sendExpressTransaction(p: {\n  chainId: ContractsChainId;\n  txnData: ExpressTxnData;\n  isSponsoredCall: boolean;\n}) {\n  const data = encodePacked(\n    [\"bytes\", \"address\", \"address\", \"uint256\"],\n    [\n      p.txnData.callData as Address,\n      p.txnData.to as Address,\n      p.txnData.feeToken as Address,\n      p.txnData.feeAmount,\n    ]\n  );\n\n  let gelatoPromise: Promise<{ taskId: string }> | undefined;\n\n  const apiKey = GELATO_API_KEYS[p.chainId];\n\n  gelatoPromise = sendTxnToGelato({\n    chainId: p.chainId,\n    target: p.txnData.to,\n    data,\n    feeToken: p.txnData.feeToken,\n    sponsorApiKey: apiKey,\n    retries: 0,\n    isSponsoredCall: apiKey ? p.isSponsoredCall : false,\n  });\n\n  return gelatoPromise?.then((res) => {\n    return {\n      taskId: res.taskId,\n      wait: makeExpressTxnResultWaiter(res),\n    };\n  });\n}\n\nfunction makeExpressTxnResultWaiter(res: { taskId: string }) {\n  return async () => {\n    return new Promise<TransactionWaiterResult>((resolve, reject) => {\n      pollGelatoTask(res.taskId, async (status, error) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        switch (status?.taskState) {\n          case \"ExecSuccess\":\n          case \"ExecReverted\":\n          case \"Cancelled\": {\n            const result: TransactionWaiterResult = {\n              transactionHash: status.transactionHash,\n              blockNumber: status?.blockNumber,\n              status: status.taskState === \"ExecSuccess\" ? \"success\" : \"failed\",\n              relayStatus: {\n                taskId: res.taskId,\n                taskState: status.taskState,\n              },\n            };\n            resolve(result);\n            break;\n          }\n          case \"CheckPending\":\n          case \"ExecPending\":\n          case \"WaitingForConfirmation\":\n          default:\n            break;\n        }\n      });\n    });\n  };\n}\n\nconst GELATO_API = \"https://api.gelato.digital\";\n\nexport async function sendTxnToGelato({\n  chainId,\n  target,\n  data,\n  feeToken,\n  sponsorApiKey,\n  retries,\n  isSponsoredCall,\n}: {\n  chainId: number;\n  target: string;\n  data: string;\n  feeToken: string;\n  sponsorApiKey: string | undefined;\n  retries: number;\n  isSponsoredCall: boolean;\n}) {\n  if (isSponsoredCall && !sponsorApiKey) {\n    throw new Error(\"Sponsor API key is required for sponsored call\");\n  }\n\n  const url = isSponsoredCall\n    ? `${GELATO_API}/relays/v2/sponsored-call`\n    : `${GELATO_API}/relays/v2/call-with-sync-fee`;\n\n  const res = await fetch(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      chainId,\n      target,\n      data,\n      feeToken,\n      sponsorApiKey,\n      retries,\n    }),\n  });\n\n  if (!res.ok) {\n    throw new Error(`Failed to call with sync fee: ${res.statusText}`);\n  }\n\n  const result = (await res.json()) as { taskId: string };\n\n  gelatoRelay.subscribeTaskStatusUpdate(result.taskId);\n\n  return result;\n}\n\nconst finalStatuses = [\n  TaskState.ExecSuccess,\n  TaskState.ExecReverted,\n  TaskState.Cancelled,\n];\n\nexport async function pollGelatoTask(\n  taskId: string,\n  cb: (status: GelatoTaskStatus | undefined, error?: Error) => void\n) {\n  const pollInterval = 500;\n  const maxAttempts = 60;\n\n  let attempts = 0;\n  let lastStatus: GelatoTaskStatus | undefined;\n\n  const startTime = Date.now();\n\n  while (attempts < maxAttempts) {\n    try {\n      const res = await fetch(`${GELATO_API}/tasks/status/${taskId}`);\n      const { task: status } = (await res.json()) as { task: GelatoTaskStatus };\n      lastStatus = status;\n\n      cb(status);\n\n      if (finalStatuses.includes(status.taskState)) {\n        const elapsedTime = Date.now() - startTime;\n        emitMetricTiming({\n          event: \"express.pollGelatoTask.finalStatus\",\n          time: elapsedTime,\n          data: {\n            status: status.taskState,\n          },\n        });\n        return;\n      }\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.error(e);\n    } finally {\n      await sleep(pollInterval);\n      attempts++;\n    }\n  }\n\n  cb(lastStatus, new Error(\"Gelato Task timeout\"));\n}\n\nexport async function getGelatoTaskDebugInfo(\n  taskId: string,\n  accountSlug?: string,\n  projectSlug?: string\n) {\n  const accountParams =\n    accountSlug && projectSlug\n      ? `?tenderlyUsername=${accountSlug}&tenderlyProjectName=${projectSlug}`\n      : \"\";\n\n  try {\n    const res = await fetch(\n      `${GELATO_API}/tasks/status/${taskId}/debug${accountParams}`\n    );\n    const debugData = await res.json();\n    return debugData;\n  } catch (error) {\n    return undefined;\n  }\n}\n"]}