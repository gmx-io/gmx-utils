{"version":3,"sources":["../../../../../src/lib/numbers/index.ts","../../../../../src/lib/time.ts","../../../../../src/configs/express.ts","../../../../../src/lib/gelatoRelay/gelatoRelay.ts","../../../../../src/lib/metrics/index.ts","../../../../../src/lib/sleep/sleep.ts","../../../../../src/lib/transactions/sendExpressTransaction.ts"],"names":[],"mappings":"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","file":"sendExpressTransaction.js","sourcesContent":["import { formatUnits, parseUnits } from \"viem\";\n\nimport { bigMath } from \"../bigmath\";\n\nexport type Numeric = number | bigint;\nexport type BigNumberish = string | Numeric;\n\nexport const USD_DECIMALS = 30;\n\nexport const BASIS_POINTS_DIVISOR = 10000;\nexport const BASIS_POINTS_DIVISOR_BIGINT = 10000n;\nexport const BASIS_POINTS_DECIMALS = 4;\n\nexport const PRECISION_DECIMALS = 30;\nexport const PRECISION = expandDecimals(1, PRECISION_DECIMALS);\n\nexport const BN_ZERO = 0n;\nexport const BN_ONE = 1n;\nexport const BN_NEGATIVE_ONE = -1n;\n\nexport const MaxUint256 = BigInt(\n  \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n);\n\nexport const PERCENT_PRECISION_DECIMALS = PRECISION_DECIMALS - 2;\n\nconst MAX_EXCEEDING_THRESHOLD = \"1000000000\";\nconst MIN_EXCEEDING_THRESHOLD = \"0.01\";\n\nexport const TRIGGER_PREFIX_ABOVE = \">\";\nexport const TRIGGER_PREFIX_BELOW = \"<\";\n\ndeclare const __nonZero: unique symbol;\nexport type NonZero<T extends number | bigint> = T & {\n  readonly [__nonZero]: true;\n};\n\nexport function isNonZero<T extends number | bigint>(\n  value: T\n): value is NonZero<T> {\n  return value !== 0 && value !== 0n;\n}\n\nexport function safeDivide<T extends number | bigint>(a: T, b: NonZero<T>): T {\n  return (a / b) as T;\n}\n\nexport function expandDecimals(n: BigNumberish, decimals: number): bigint {\n  return BigInt(n) * 10n ** BigInt(decimals);\n}\n\nexport function basisPointsToFloat(basisPoints: bigint) {\n  return (basisPoints * PRECISION) / BASIS_POINTS_DIVISOR_BIGINT;\n}\n\nexport function getBasisPoints(\n  numerator: bigint,\n  denominator: bigint,\n  shouldRoundUp = false\n) {\n  const result = (numerator * BASIS_POINTS_DIVISOR_BIGINT) / denominator;\n\n  if (shouldRoundUp) {\n    const remainder = (numerator * BASIS_POINTS_DIVISOR_BIGINT) % denominator;\n    if (remainder !== 0n) {\n      return result < 0n ? result - 1n : result + 1n;\n    }\n  }\n\n  return result;\n}\n\nexport function roundUpMagnitudeDivision(a: bigint, b: bigint) {\n  if (a < 0n) {\n    return (a - b + 1n) / b;\n  }\n\n  return (a + b - 1n) / b;\n}\n\nexport function applyFactor(value: bigint, factor: bigint) {\n  return (value * factor) / PRECISION;\n}\n\nexport function numberToBigint(value: number, decimals: number) {\n  const negative = value < 0;\n  if (negative) value *= -1;\n\n  const int = Math.trunc(value);\n  let frac = value - int;\n\n  let res = BigInt(int);\n\n  for (let i = 0; i < decimals; i++) {\n    res *= 10n;\n    if (frac !== 0) {\n      frac *= 10;\n      const fracInt = Math.trunc(frac);\n      res += BigInt(fracInt);\n      frac -= fracInt;\n    }\n  }\n\n  return negative ? -res : res;\n}\n\nexport const trimZeroDecimals = (amount: string) => {\n  if (parseFloat(amount) === parseInt(amount)) {\n    return parseInt(amount).toString();\n  }\n  return amount;\n};\n\nexport function bigintToNumber(value: bigint, decimals: number) {\n  const negative = value < 0;\n  if (negative) value *= -1n;\n  const precision = 10n ** BigInt(decimals);\n  const int = value / precision;\n  const frac = value % precision;\n\n  const num = parseFloat(`${int}.${frac.toString().padStart(decimals, \"0\")}`);\n  return negative ? -num : num;\n}\n\nexport function adjustForDecimals(\n  amount: bigint,\n  divDecimals: number,\n  mulDecimals: number\n) {\n  return (\n    (amount * expandDecimals(1, mulDecimals)) / expandDecimals(1, divDecimals)\n  );\n}\n\nexport function formatUsd(\n  usd?: bigint,\n  opts: {\n    fallbackToZero?: boolean;\n    displayDecimals?: number;\n    maxThreshold?: string | null;\n    minThreshold?: string;\n    displayPlus?: boolean;\n    visualMultiplier?: number;\n  } = {}\n) {\n  const { fallbackToZero = false, displayDecimals = 2 } = opts;\n\n  if (typeof usd !== \"bigint\") {\n    if (fallbackToZero) {\n      usd = 0n;\n    } else {\n      return undefined;\n    }\n  }\n\n  if (opts.visualMultiplier) {\n    usd *= BigInt(opts.visualMultiplier);\n  }\n\n  const defaultMinThreshold =\n    displayDecimals > 1\n      ? \"0.\" + \"0\".repeat(displayDecimals - 1) + \"1\"\n      : undefined;\n\n  const exceedingInfo = getLimitedDisplay(usd, USD_DECIMALS, {\n    maxThreshold: opts.maxThreshold,\n    minThreshold: opts.minThreshold ?? defaultMinThreshold,\n  });\n\n  const maybePlus = opts.displayPlus ? \"+\" : \"\";\n  const sign = usd < 0n ? \"-\" : maybePlus;\n  const symbol = exceedingInfo.symbol ? `${exceedingInfo.symbol}\\u00a0` : \"\";\n  const displayUsd = formatAmount(\n    exceedingInfo.value,\n    USD_DECIMALS,\n    displayDecimals,\n    true\n  );\n  return `${symbol}${sign}$\\u200a${displayUsd}`;\n}\n\nexport function formatBigUsd(\n  amount: bigint,\n  opts: { displayDecimals?: number } = {}\n) {\n  return formatUsd(amount, {\n    maxThreshold: \"9999999999999999999999999\",\n    displayDecimals: opts.displayDecimals ?? 0,\n  });\n}\n\nexport function formatDeltaUsd(\n  deltaUsd?: bigint,\n  percentage?: bigint,\n  opts: { fallbackToZero?: boolean; showPlusForZero?: boolean } = {}\n) {\n  if (typeof deltaUsd !== \"bigint\") {\n    if (opts.fallbackToZero) {\n      return `${formatUsd(0n)} (${formatAmount(0n, 2, 2)}%)`;\n    }\n\n    return undefined;\n  }\n\n  const sign = getPlusOrMinusSymbol(deltaUsd, {\n    showPlusForZero: opts.showPlusForZero,\n  });\n\n  const exceedingInfo = getLimitedDisplay(deltaUsd, USD_DECIMALS);\n  const percentageStr =\n    percentage !== undefined\n      ? ` (${sign}${formatPercentage(bigMath.abs(percentage))})`\n      : \"\";\n  const deltaUsdStr = formatAmount(exceedingInfo.value, USD_DECIMALS, 2, true);\n  const symbol = exceedingInfo.symbol ? `${exceedingInfo.symbol} ` : \"\";\n\n  return `${symbol}${sign}$\\u200a${deltaUsdStr}${percentageStr}`;\n}\n\nexport function formatPercentage(\n  percentage?: bigint,\n  opts: {\n    fallbackToZero?: boolean;\n    signed?: boolean;\n    displayDecimals?: number;\n    bps?: boolean;\n    showPlus?: boolean;\n  } = {}\n) {\n  const {\n    fallbackToZero = false,\n    signed = false,\n    displayDecimals = 2,\n    bps = true,\n    showPlus = true,\n  } = opts;\n\n  if (percentage === undefined) {\n    if (fallbackToZero) {\n      return `${formatAmount(\n        0n,\n        PERCENT_PRECISION_DECIMALS,\n        displayDecimals\n      )}%`;\n    }\n\n    return undefined;\n  }\n\n  const sign = signed ? `${getPlusOrMinusSymbol(percentage)}` : \"\";\n  const displaySign = !showPlus && sign === \"+\" ? \"\" : `${sign}`;\n\n  return `${displaySign}${displaySign ? \"\\u200a\" : \"\"}${formatAmount(\n    bigMath.abs(percentage),\n    bps ? 2 : PERCENT_PRECISION_DECIMALS,\n    displayDecimals\n  )}%`;\n}\n\nexport function formatTokenAmount(\n  amount?: bigint,\n  tokenDecimals?: number,\n  symbol?: string,\n  opts: {\n    showAllSignificant?: boolean;\n    displayDecimals?: number;\n    fallbackToZero?: boolean;\n    useCommas?: boolean;\n    minThreshold?: string;\n    maxThreshold?: string;\n    displayPlus?: boolean;\n    isStable?: boolean;\n  } = {}\n) {\n  const {\n    showAllSignificant = false,\n    fallbackToZero = false,\n    useCommas = false,\n    minThreshold = \"0\",\n    maxThreshold,\n  } = opts;\n\n  const displayDecimals = opts.displayDecimals ?? (opts.isStable ? 2 : 4);\n\n  const symbolStr = symbol ? ` ${symbol}` : \"\";\n\n  if (typeof amount !== \"bigint\" || !tokenDecimals) {\n    if (fallbackToZero) {\n      amount = 0n;\n      tokenDecimals = displayDecimals;\n    } else {\n      return undefined;\n    }\n  }\n\n  let amountStr: string;\n\n  const maybePlus = opts.displayPlus ? \"+\" : \"\";\n  const sign = amount < 0n ? \"-\" : maybePlus;\n\n  if (showAllSignificant) {\n    amountStr = formatAmountFree(amount, tokenDecimals, tokenDecimals);\n  } else {\n    const exceedingInfo = getLimitedDisplay(amount, tokenDecimals, {\n      maxThreshold,\n      minThreshold,\n    });\n    const symbol = exceedingInfo.symbol ? `${exceedingInfo.symbol} ` : \"\";\n    amountStr = `${symbol}${sign}${formatAmount(\n      exceedingInfo.value,\n      tokenDecimals,\n      displayDecimals,\n      useCommas,\n      undefined\n    )}`;\n  }\n\n  return `${amountStr}${symbolStr}`;\n}\n\nexport function formatTokenAmountWithUsd(\n  tokenAmount?: bigint,\n  usdAmount?: bigint,\n  tokenSymbol?: string,\n  tokenDecimals?: number,\n  opts: {\n    fallbackToZero?: boolean;\n    displayDecimals?: number;\n    displayPlus?: boolean;\n    isStable?: boolean;\n  } = {}\n) {\n  if (\n    typeof tokenAmount !== \"bigint\" ||\n    typeof usdAmount !== \"bigint\" ||\n    !tokenSymbol ||\n    !tokenDecimals\n  ) {\n    if (!opts.fallbackToZero) {\n      return undefined;\n    }\n  }\n\n  const tokenStr = formatTokenAmount(tokenAmount, tokenDecimals, tokenSymbol, {\n    ...opts,\n    useCommas: true,\n    displayPlus: opts.displayPlus,\n  });\n\n  const usdStr = formatUsd(usdAmount, {\n    fallbackToZero: opts.fallbackToZero,\n    displayPlus: opts.displayPlus,\n  });\n\n  return `${tokenStr} (${usdStr})`;\n}\n\n/**\n *\n * @param opts.signed - Default `true`. whether to display a `+` or `-` sign for all non-zero values.\n */\nexport function formatRatePercentage(\n  rate?: bigint,\n  opts?: { displayDecimals?: number; signed?: boolean }\n) {\n  if (typeof rate !== \"bigint\") {\n    return \"-\";\n  }\n\n  const signed = opts?.signed ?? true;\n  const plurOrMinus = signed ? getPlusOrMinusSymbol(rate) : \"\";\n\n  const amount = bigMath.abs(rate * 100n);\n  return `${plurOrMinus}\\u200a${formatAmount(\n    amount,\n    30,\n    opts?.displayDecimals ?? 4\n  )}%`;\n}\n\nexport function formatUsdPrice(\n  price?: bigint,\n  opts: Parameters<typeof formatUsd>[1] = {}\n) {\n  if (price === undefined) {\n    return;\n  }\n\n  if (price < 0n) {\n    return \"NA\";\n  }\n\n  const decimals = calculateDisplayDecimals(\n    price,\n    undefined,\n    opts.visualMultiplier\n  );\n\n  return formatUsd(price, {\n    ...opts,\n    displayDecimals: decimals,\n  });\n}\n\nexport function formatPercentageDisplay(\n  percentage: number,\n  hideThreshold?: number\n) {\n  if (hideThreshold && percentage < hideThreshold) {\n    return \"\";\n  }\n\n  return `${percentage}%`;\n}\n\nexport function formatAmountHuman(\n  amount: BigNumberish | undefined,\n  tokenDecimals: number,\n  showDollar = false,\n  displayDecimals = 1\n) {\n  if (amount === undefined) {\n    return \"...\";\n  }\n\n  let n = Number(formatAmount(amount, tokenDecimals));\n  // For large numbers, we can neglect the decimals to avoid decimals in cases like 9999999.99999\n  if (n >= 1_000_000) {\n    n = Math.round(n);\n  }\n  const isNegative = n < 0;\n  const absN = Math.abs(n);\n  const sign = showDollar ? \"$\\u200a\" : \"\";\n\n  if (absN >= 1_000_000_000) {\n    return `${isNegative ? \"-\" : \"\"}${sign}${(absN / 1_000_000_000).toFixed(\n      displayDecimals\n    )}b`;\n  }\n\n  if (absN >= 1_000_000) {\n    return `${isNegative ? \"-\" : \"\"}${sign}${(absN / 1_000_000).toFixed(\n      displayDecimals\n    )}m`;\n  }\n\n  if (absN >= 1000) {\n    return `${isNegative ? \"-\" : \"\"}${sign}${(absN / 1_000).toFixed(\n      displayDecimals\n    )}k`;\n  }\n\n  return `${isNegative ? \"-\" : \"\"}${sign}${absN.toFixed(displayDecimals)}`;\n}\n\nexport function formatBalanceAmount(\n  amount: bigint,\n  tokenDecimals: number,\n  tokenSymbol?: string,\n  {\n    showZero = false,\n    toExponential = true,\n    isStable = false,\n    signed = false,\n  }: {\n    showZero?: boolean;\n    toExponential?: boolean;\n    isStable?: boolean;\n    signed?: boolean;\n  } = {}\n): string {\n  if (amount === undefined) return \"-\";\n\n  if (amount === 0n) {\n    if (showZero === true) {\n      if (tokenSymbol) {\n        if (isStable) {\n          return `0.00 ${tokenSymbol}`;\n        }\n        return `0.0000 ${tokenSymbol}`;\n      }\n      if (isStable) {\n        return \"0.00\";\n      }\n      return \"0.0000\";\n    }\n\n    return \"-\";\n  }\n\n  const sign = signed || amount < 0n ? getPlusOrMinusSymbol(amount) : \"\";\n  const absAmount = bigMath.abs(amount);\n  const absAmountFloat = bigintToNumber(absAmount, tokenDecimals);\n\n  let value = \"\";\n\n  const baseDecimals = isStable ? 2 : 4;\n  if (absAmountFloat >= 1)\n    value = formatAmount(absAmount, tokenDecimals, baseDecimals, true);\n  else if (absAmountFloat >= 0.1)\n    value = formatAmount(absAmount, tokenDecimals, baseDecimals + 1, true);\n  else if (absAmountFloat >= 0.01)\n    value = formatAmount(absAmount, tokenDecimals, baseDecimals + 2, true);\n  else if (absAmountFloat >= 0.001)\n    value = formatAmount(absAmount, tokenDecimals, baseDecimals + 3, true);\n  else if (absAmountFloat >= 1e-8)\n    value = formatAmount(absAmount, tokenDecimals, 8, true);\n  else {\n    if (toExponential) {\n      value = bigintToNumber(absAmount, tokenDecimals).toExponential(2);\n    } else {\n      value = bigintToNumber(absAmount, tokenDecimals).toFixed(8);\n    }\n  }\n\n  if (tokenSymbol) {\n    // Non-breaking space\n    return `${sign}${value} ${tokenSymbol}`;\n  }\n\n  return `${sign}${value}`;\n}\n\nexport function formatFactor(factor: bigint) {\n  if (factor == 0n) {\n    return \"0\";\n  }\n\n  if (bigMath.abs(factor) > PRECISION * 1000n) {\n    return (factor / PRECISION).toString();\n  }\n\n  const trailingZeroes =\n    bigMath\n      .abs(factor)\n      .toString()\n      .match(/^(.+?)(?<zeroes>0*)$/)?.groups?.zeroes?.length || 0;\n  const factorDecimals = 30 - trailingZeroes;\n  return formatAmount(factor, 30, factorDecimals);\n}\nexport function numberWithCommas(\n  x: BigNumberish,\n  { showDollar = false }: { showDollar?: boolean } = {}\n) {\n  if (x === undefined || x === null) {\n    return \"...\";\n  }\n\n  const parts = x.toString().split(\".\");\n  parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n  return `${showDollar ? \"$\\u200a\" : \"\"}${parts.join(\".\")}`;\n}\n\nexport const formatAmount = (\n  amount: BigNumberish | undefined,\n  tokenDecimals: number,\n  displayDecimals?: number,\n  useCommas?: boolean,\n  defaultValue?: string,\n  visualMultiplier?: number\n) => {\n  if (defaultValue === undefined || defaultValue === null) {\n    defaultValue = \"...\";\n  }\n  if (amount === undefined || amount === null || amount === \"\") {\n    return defaultValue;\n  }\n  if (displayDecimals === undefined) {\n    displayDecimals = 4;\n  }\n  const amountBigInt = roundWithDecimals(\n    BigInt(amount) * BigInt(visualMultiplier ?? 1),\n    {\n      displayDecimals,\n      decimals: tokenDecimals,\n    }\n  );\n  let amountStr = formatUnits(amountBigInt, tokenDecimals);\n  amountStr = limitDecimals(amountStr, displayDecimals);\n  if (displayDecimals !== 0) {\n    amountStr = padDecimals(amountStr, displayDecimals);\n  }\n  if (useCommas) {\n    return numberWithCommas(amountStr);\n  }\n  return amountStr;\n};\n\nexport const formatKeyAmount = <T extends {}>(\n  map: T | undefined,\n  key: keyof T,\n  tokenDecimals: number,\n  displayDecimals: number,\n  useCommas?: boolean\n) => {\n  const value = map ? map[key] ?? undefined : undefined;\n  if (value === undefined || value === null) {\n    return \"...\";\n  }\n\n  return formatAmount(\n    value as bigint,\n    tokenDecimals,\n    displayDecimals,\n    useCommas\n  );\n};\n\nexport const formatArrayAmount = (\n  arr: any[],\n  index: number,\n  tokenDecimals: number,\n  displayDecimals?: number,\n  useCommas?: boolean\n) => {\n  if (!arr || arr[index] === undefined || arr[index] === null) {\n    return \"...\";\n  }\n\n  return formatAmount(arr[index], tokenDecimals, displayDecimals, useCommas);\n};\n\nexport const formatAmountFree = (\n  amount: BigNumberish,\n  tokenDecimals: number,\n  displayDecimals?: number\n) => {\n  if (amount === undefined || amount === null) {\n    return \"...\";\n  }\n\n  amount = BigInt(amount);\n\n  let amountStr = formatUnits(amount, tokenDecimals);\n  amountStr = limitDecimals(amountStr, displayDecimals);\n  return trimZeroDecimals(amountStr);\n};\n\nexport function getLimitedDisplay(\n  amount: bigint,\n  tokenDecimals: number,\n  opts: { maxThreshold?: BigNumberish | null; minThreshold?: BigNumberish } = {}\n) {\n  const {\n    maxThreshold = MAX_EXCEEDING_THRESHOLD,\n    minThreshold = MIN_EXCEEDING_THRESHOLD,\n  } = opts;\n  const max =\n    maxThreshold === null\n      ? null\n      : expandDecimals(BigInt(maxThreshold), tokenDecimals);\n  const min = parseUnits(minThreshold.toString(), tokenDecimals);\n  const absAmount = bigMath.abs(amount);\n\n  if (absAmount == 0n) {\n    return {\n      symbol: \"\",\n      value: absAmount,\n    };\n  }\n\n  const symbol =\n    max !== null && absAmount > max\n      ? TRIGGER_PREFIX_ABOVE\n      : absAmount < min\n      ? TRIGGER_PREFIX_BELOW\n      : \"\";\n  const value =\n    max !== null && absAmount > max ? max : absAmount < min ? min : absAmount;\n\n  return {\n    symbol,\n    value,\n  };\n}\n\nexport const limitDecimals = (amount: BigNumberish, maxDecimals?: number) => {\n  let amountStr = amount.toString();\n  if (maxDecimals === undefined) {\n    return amountStr;\n  }\n  if (maxDecimals === 0) {\n    return amountStr.split(\".\")[0];\n  }\n  const dotIndex = amountStr.indexOf(\".\");\n  if (dotIndex !== -1) {\n    let decimals = amountStr.length - dotIndex - 1;\n    if (decimals > maxDecimals) {\n      amountStr = amountStr.substr(\n        0,\n        amountStr.length - (decimals - maxDecimals)\n      );\n    }\n  }\n\n  return amountStr;\n};\n\nexport const padDecimals = (amount: BigNumberish, minDecimals: number) => {\n  let amountStr = amount.toString();\n  const dotIndex = amountStr.indexOf(\".\");\n  if (dotIndex !== -1) {\n    const decimals = amountStr.length - dotIndex - 1;\n    if (decimals < minDecimals) {\n      amountStr = amountStr.padEnd(\n        amountStr.length + (minDecimals - decimals),\n        \"0\"\n      );\n    }\n  } else {\n    amountStr = amountStr + \".\" + \"0\".repeat(minDecimals);\n  }\n  return amountStr;\n};\n\nexport function getPlusOrMinusSymbol(\n  value?: bigint,\n  opts: { showPlusForZero?: boolean } = {}\n): string {\n  if (value === undefined) {\n    return \"\";\n  }\n\n  const { showPlusForZero = false } = opts;\n  return value === 0n ? (showPlusForZero ? \"+\" : \"\") : value < 0n ? \"-\" : \"+\";\n}\n\nexport function roundWithDecimals(\n  value: BigNumberish,\n  opts: { displayDecimals: number; decimals: number }\n): bigint {\n  if (opts.displayDecimals === opts.decimals) {\n    return BigInt(value);\n  }\n\n  let valueString = value.toString();\n  let isNegative = false;\n\n  if (valueString[0] === \"-\") {\n    valueString = valueString.slice(1);\n    isNegative = true;\n  }\n\n  if (valueString.length < opts.decimals) {\n    valueString = valueString.padStart(opts.decimals, \"0\");\n  }\n\n  const mainPart = valueString.slice(\n    0,\n    valueString.length - opts.decimals + opts.displayDecimals\n  );\n  const partToRound = valueString.slice(\n    valueString.length - opts.decimals + opts.displayDecimals\n  );\n\n  let mainPartBigInt = BigInt(mainPart);\n\n  let returnValue = mainPartBigInt;\n\n  if (partToRound.length !== 0) {\n    if (Number(partToRound[0]) >= 5) {\n      mainPartBigInt += 1n;\n    }\n\n    returnValue = BigInt(\n      mainPartBigInt.toString() +\n        new Array(partToRound.length).fill(\"0\").join(\"\")\n    );\n  }\n\n  return isNegative ? returnValue * -1n : returnValue;\n}\n\n// TODO: Remove this function\nexport function toBigNumberWithDecimals(\n  value: string,\n  decimals: number\n): bigint {\n  if (!value) return BN_ZERO;\n\n  const parts = value.split(\".\");\n  const integerPart = parts[0];\n  const decimalPart = parts.length > 1 ? parts[1] : \"\";\n\n  const paddingZeros = decimals - decimalPart.length;\n\n  if (paddingZeros >= 0) {\n    const result = integerPart + decimalPart + \"0\".repeat(paddingZeros);\n    return BigInt(result);\n  } else {\n    const result = integerPart + decimalPart.substring(0, decimals);\n    return BigInt(result);\n  }\n}\n\n/**\n *\n * @deprecated Use BigInt instead\n */\nexport function bigNumberify(n?: BigNumberish | null | undefined) {\n  try {\n    if (n === undefined) throw new Error(\"n is undefined\");\n    if (n === null) throw new Error(\"n is null\");\n\n    return BigInt(n);\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(\"bigNumberify error\", e);\n    return undefined;\n  }\n}\n\nexport const parseValue = (value: string, tokenDecimals: number) => {\n  const pValue = parseFloat(value);\n\n  if (isNaN(pValue)) {\n    return undefined;\n  }\n  value = limitDecimals(value, tokenDecimals);\n  const amount = parseUnits(value, tokenDecimals);\n  return bigNumberify(amount);\n};\n\nexport function roundUpDivision(a: bigint, b: bigint) {\n  return (a + b - 1n) / b;\n}\n\nexport function roundToTwoDecimals(n: number) {\n  return Math.round(n * 100) / 100;\n}\n\nexport function roundToOrder(n: bigint, significantDigits = 1) {\n  const decimals = Math.max(n.toString().length - significantDigits, 0);\n  return (n / expandDecimals(1, decimals)) * expandDecimals(1, decimals);\n}\n\nexport function roundBigIntToDecimals(\n  value: bigint,\n  tokenDecimals: number,\n  roundToDecimals: number\n): bigint {\n  const excessDecimals = tokenDecimals - roundToDecimals;\n  const divisor = BigInt(10 ** excessDecimals);\n  const scaledValue = value / divisor;\n  const remainder = scaledValue % 10n;\n  const roundedValue =\n    remainder >= 5n ? scaledValue + 10n - remainder : scaledValue - remainder;\n  return roundedValue * divisor;\n}\n\nexport function minBigNumber(...args: bigint[]) {\n  if (!args.length) return undefined;\n\n  return args.reduce((acc, num) => (num < acc ? num : acc), args[0]);\n}\n\nexport function maxbigint(...args: bigint[]) {\n  if (!args.length) return undefined;\n\n  return args.reduce((acc, num) => (num > acc ? num : acc), args[0]);\n}\n\nexport function removeTrailingZeros(amount: string | number) {\n  const amountWithoutZeros = Number(amount);\n  if (!amountWithoutZeros) return amount;\n  return amountWithoutZeros;\n}\n\ntype SerializedBigIntsInObject<T> = {\n  [P in keyof T]: T[P] extends bigint\n    ? { type: \"bigint\"; value: bigint }\n    : T[P] extends object\n    ? SerializedBigIntsInObject<T[P]>\n    : T[P];\n};\n\ntype DeserializeBigIntInObject<T> = {\n  [P in keyof T]: T[P] extends { type: \"bigint\"; value: bigint }\n    ? bigint\n    : T[P] extends object\n    ? DeserializeBigIntInObject<T[P]>\n    : T[P];\n};\n\nexport function serializeBigIntsInObject<T extends object>(\n  obj: T\n): SerializedBigIntsInObject<T> {\n  const result: any = Array.isArray(obj) ? [] : {};\n  for (const key in obj) {\n    const value = obj[key];\n    if (typeof value === \"bigint\") {\n      result[key] = { type: \"bigint\", value: String(value) };\n    } else if (value && typeof value === \"object\") {\n      result[key] = serializeBigIntsInObject(value);\n    } else {\n      result[key] = value;\n    }\n  }\n  return result;\n}\n\nexport function deserializeBigIntsInObject<T extends object>(\n  obj: T\n): DeserializeBigIntInObject<T> {\n  const result: any = Array.isArray(obj) ? [] : {};\n  for (const key in obj) {\n    const value = obj[key];\n    if (\n      typeof value === \"object\" &&\n      value !== null &&\n      ((\"type\" in value && value.type === \"bigint\") ||\n        (\"_type\" in value && value._type === \"BigNumber\"))\n    ) {\n      if (\"value\" in value && typeof value.value === \"string\") {\n        result[key] = BigInt(value.value);\n      } else if (\"hex\" in value && typeof value.hex === \"string\") {\n        if (value.hex.startsWith(\"-\")) {\n          result[key] = BigInt(value.hex.slice(1)) * -1n;\n        } else {\n          result[key] = BigInt(value.hex);\n        }\n      }\n    } else if (value && typeof value === \"object\") {\n      result[key] = deserializeBigIntsInObject(value);\n    } else {\n      result[key] = value;\n    }\n  }\n  return result;\n}\n\nexport function calculateDisplayDecimals(\n  price?: bigint,\n  decimals = USD_DECIMALS,\n  visualMultiplier = 1,\n  isStable = false\n) {\n  if (price === undefined || price === 0n) return 2;\n  const priceNumber = bigintToNumber(\n    bigMath.abs(price) * BigInt(visualMultiplier),\n    decimals\n  );\n\n  if (isNaN(priceNumber)) return 2;\n  if (isStable) {\n    if (priceNumber >= 0.1) return 2;\n    if (priceNumber >= 0.01) return 3;\n    if (priceNumber >= 0.001) return 4;\n    if (priceNumber >= 0.0001) return 5;\n    if (priceNumber >= 0.00001) return 6;\n    if (priceNumber >= 0.000001) return 7;\n    if (priceNumber >= 0.0000001) return 8;\n    if (priceNumber >= 0.00000001) return 9;\n  } else {\n    if (priceNumber >= 1000) return 2;\n    if (priceNumber >= 100) return 3;\n    if (priceNumber >= 1) return 4;\n    if (priceNumber >= 0.1) return 5;\n    if (priceNumber >= 0.01) return 6;\n    if (priceNumber >= 0.0001) return 7;\n    if (priceNumber >= 0.00001) return 8;\n  }\n\n  return 9;\n}\n\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(value, max));\n}\n\nexport function absDiffBps(value: bigint, base: bigint) {\n  if ((value === 0n && base !== 0n) || (value !== 0n && base === 0n)) {\n    return BASIS_POINTS_DIVISOR_BIGINT;\n  }\n\n  if (value === 0n && base === 0n) {\n    return 0n;\n  }\n\n  return bigMath.mulDiv(\n    bigMath.abs(value - base),\n    BASIS_POINTS_DIVISOR_BIGINT,\n    base\n  );\n}\n","const SECONDS_IN_PERIOD = {\n  \"1m\": 60,\n  \"5m\": 60 * 5,\n  \"15m\": 60 * 15,\n  \"1h\": 60 * 60,\n  \"4h\": 60 * 60 * 4,\n  \"1d\": 60 * 60 * 24,\n  \"1y\": 60 * 60 * 24 * 365,\n};\n\nexport function secondsFrom(period: keyof typeof SECONDS_IN_PERIOD) {\n  return SECONDS_IN_PERIOD[period];\n}\n\nexport function secondsToPeriod(\n  seconds: number,\n  period: keyof typeof SECONDS_IN_PERIOD,\n  roundUp = false\n) {\n  const secondsInPeriod = secondsFrom(period);\n\n  const roundedSeconds = roundUp\n    ? Math.ceil(seconds / secondsInPeriod)\n    : Math.floor(seconds / secondsInPeriod);\n\n  return roundedSeconds;\n}\n\nexport function periodToSeconds(\n  periodsCount: number,\n  period: keyof typeof SECONDS_IN_PERIOD\n) {\n  return periodsCount * secondsFrom(period);\n}\n\nexport function nowInSeconds() {\n  return Math.floor(Date.now() / 1000);\n}\n\nexport const TIMEZONE_OFFSET_SEC = -new Date().getTimezoneOffset() * 60;\n","import { Token } from \"domain/tokens/types\";\nimport { expandDecimals, USD_DECIMALS } from \"lib/numbers\";\nimport { periodToSeconds } from \"lib/time\";\n\nimport {\n  ARBITRUM,\n  ARBITRUM_SEPOLIA,\n  AVALANCHE,\n  AVALANCHE_FUJI,\n  BOTANIX,\n  ContractsChainId,\n} from \"./chains\";\nimport { getTokenBySymbol, getWrappedToken } from \"./tokens\";\n\nexport const SUBACCOUNT_MESSAGE =\n  \"Generate a GMX 1CT (One-Click Trading) session. Only sign this message on a trusted website.\";\nexport const SUBACCOUNT_DOCS_URL =\n  \"https://docs.gmx.io/docs/trading/v2/#one-click-trading\";\n\nexport const DEFAULT_SUBACCOUNT_EXPIRY_DURATION = periodToSeconds(7, \"1d\"); // 1 week\nexport const DEFAULT_SUBACCOUNT_MAX_ALLOWED_COUNT = 90;\n\nexport const DEFAULT_PERMIT_DEADLINE_DURATION = periodToSeconds(1, \"1h\");\nexport const DEFAULT_EXPRESS_ORDER_DEADLINE_DURATION = periodToSeconds(1, \"1h\");\n\nexport const GELATO_API_KEYS: Partial<Record<ContractsChainId, string>> = {\n  [ARBITRUM]: \"6dE6kOa9pc1ap4dQQC2iaK9i6nBFp8eYxQlm00VreWc_\",\n  [AVALANCHE]: \"FalsQh9loL6V0rwPy4gWgnQPR6uTHfWjSVT2qlTzUq4_\",\n  [BOTANIX]: \"s5GgkfX7dvd_2uYqsRSCjzMekUrXh0dibUvfLab1Anc_\",\n  [ARBITRUM_SEPOLIA]: \"nx5nyAg4h2kI_64YtOuPt7LSPDEXo4u8eJY_idF9xDw_\",\n};\n\nexport const MIN_GELATO_USD_BALANCE_FOR_SPONSORED_CALL = expandDecimals(\n  100,\n  USD_DECIMALS\n); // 100$\nexport const MIN_RELAYER_FEE_USD = 5n ** BigInt(USD_DECIMALS - 1); // 0.5$\n\nexport const EXPRESS_EXTRA_EXECUTION_FEE_BUFFER_BPS = 1000;\n\nexport const EXPRESS_DEFAULT_MIN_RESIDUAL_USD_NUMBER = 20;\nexport const EXPRESS_DEFAULT_MIN_RESIDUAL_USD = expandDecimals(\n  EXPRESS_DEFAULT_MIN_RESIDUAL_USD_NUMBER,\n  USD_DECIMALS\n);\nconst EXPRESS_DEFAULT_MAX_RESIDUAL_USD_NUMBER = 40;\nexport const EXPRESS_DEFAULT_MAX_RESIDUAL_USD = expandDecimals(\n  EXPRESS_DEFAULT_MAX_RESIDUAL_USD_NUMBER,\n  USD_DECIMALS\n);\nexport const EXPRESS_RESIDUAL_AMOUNT_MULTIPLIER = 20n;\n\nconst GAS_PAYMENT_TOKENS: Record<ContractsChainId, string[]> = {\n  [ARBITRUM]: [\n    getTokenBySymbol(ARBITRUM, \"USDC\").address,\n    getTokenBySymbol(ARBITRUM, \"WETH\").address,\n    getTokenBySymbol(ARBITRUM, \"USDT\").address,\n  ],\n  [AVALANCHE]: [\n    getTokenBySymbol(AVALANCHE, \"USDC\").address,\n    getTokenBySymbol(AVALANCHE, \"WAVAX\").address,\n    getTokenBySymbol(AVALANCHE, \"USDT\").address,\n  ],\n  [AVALANCHE_FUJI]: [\n    getTokenBySymbol(AVALANCHE_FUJI, \"USDC\").address,\n    getTokenBySymbol(AVALANCHE_FUJI, \"WAVAX\").address,\n  ],\n  [ARBITRUM_SEPOLIA]: [\n    getTokenBySymbol(ARBITRUM_SEPOLIA, \"USDC.SG\").address,\n    getTokenBySymbol(ARBITRUM_SEPOLIA, \"WETH\").address,\n  ],\n  [BOTANIX]: [getTokenBySymbol(BOTANIX, \"pBTC\").address],\n};\n\nexport function getGasPaymentTokens(chainId: number): string[] {\n  return GAS_PAYMENT_TOKENS[chainId];\n}\n\nexport function getDefaultGasPaymentToken(chainId: number): string {\n  return GAS_PAYMENT_TOKENS[chainId][0];\n}\n\nexport function getRelayerFeeToken(chainId: number): Token {\n  return getWrappedToken(chainId);\n}\n","import { GelatoRelay } from \"@gelatonetwork/relay-sdk\";\nimport noop from \"lodash/noop\";\n\nexport const gelatoRelay = new GelatoRelay();\ngelatoRelay.onError(noop);\n","export * from \"./emitMetricEvent\";\nexport * from \"./Metrics\";\nexport * from \"./types\";\nexport * from \"./utils\";\n\n\n\n\n\n","export function sleep(ms: number): Promise<void> {\n  return new Promise<void>((resolve) => {\n    setTimeout(() => resolve(), ms);\n  });\n}\n\nexport function sleepWithSignal(ms: number, signal: AbortSignal): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    if (signal.aborted) {\n      reject(createAbortError());\n      return;\n    }\n\n    const abortHandler = () => {\n      clearTimeout(timeout);\n      signal.removeEventListener(\"abort\", abortHandler);\n      reject(createAbortError());\n    };\n\n    const timeout = setTimeout(() => {\n      signal.removeEventListener(\"abort\", abortHandler);\n      resolve();\n    }, ms);\n\n    signal.addEventListener(\"abort\", abortHandler);\n  });\n}\n\nfunction createAbortError(): Error {\n  if (typeof DOMException !== \"undefined\") {\n    return new DOMException(\"Sleep aborted\", \"AbortError\");\n  }\n\n  const error = new Error(\"Sleep aborted\");\n  error.name = \"AbortError\";\n  return error;\n}\n","import { Address, encodePacked } from \"viem\";\n\nimport { ContractsChainId } from \"configs/chains\";\nimport { GELATO_API_KEYS } from \"configs/express\";\nimport { gelatoRelay } from \"lib/gelatoRelay/gelatoRelay\";\nimport { emitMetricTiming } from \"lib/metrics\";\nimport { sleep } from \"lib/sleep/sleep\";\n\nimport {\n  TaskState,\n  type GelatoTaskStatus,\n  type TransactionWaiterResult,\n} from \"./types\";\n\nexport type ExpressTxnData = {\n  callData: string;\n  to: string;\n  feeToken: string;\n  feeAmount: bigint;\n};\n\nexport type ExpressTxnResult = {\n  taskId: string;\n  wait: () => Promise<TransactionWaiterResult>;\n};\n\nexport async function sendExpressTransaction(p: {\n  chainId: ContractsChainId;\n  txnData: ExpressTxnData;\n  isSponsoredCall: boolean;\n}) {\n  const data = encodePacked(\n    [\"bytes\", \"address\", \"address\", \"uint256\"],\n    [\n      p.txnData.callData as Address,\n      p.txnData.to as Address,\n      p.txnData.feeToken as Address,\n      p.txnData.feeAmount,\n    ]\n  );\n\n  let gelatoPromise: Promise<{ taskId: string }> | undefined;\n\n  const apiKey = GELATO_API_KEYS[p.chainId];\n\n  gelatoPromise = sendTxnToGelato({\n    chainId: p.chainId,\n    target: p.txnData.to,\n    data,\n    feeToken: p.txnData.feeToken,\n    sponsorApiKey: apiKey,\n    retries: 0,\n    isSponsoredCall: apiKey ? p.isSponsoredCall : false,\n  });\n\n  return gelatoPromise?.then((res) => {\n    return {\n      taskId: res.taskId,\n      wait: makeExpressTxnResultWaiter(res),\n    };\n  });\n}\n\nfunction makeExpressTxnResultWaiter(res: { taskId: string }) {\n  return async () => {\n    return new Promise<TransactionWaiterResult>((resolve, reject) => {\n      pollGelatoTask(res.taskId, async (status, error) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        switch (status?.taskState) {\n          case \"ExecSuccess\":\n          case \"ExecReverted\":\n          case \"Cancelled\": {\n            const result: TransactionWaiterResult = {\n              transactionHash: status.transactionHash,\n              blockNumber: status?.blockNumber,\n              status: status.taskState === \"ExecSuccess\" ? \"success\" : \"failed\",\n              relayStatus: {\n                taskId: res.taskId,\n                taskState: status.taskState,\n              },\n            };\n            resolve(result);\n            break;\n          }\n          case \"CheckPending\":\n          case \"ExecPending\":\n          case \"WaitingForConfirmation\":\n          default:\n            break;\n        }\n      });\n    });\n  };\n}\n\nconst GELATO_API = \"https://api.gelato.digital\";\n\nexport async function sendTxnToGelato({\n  chainId,\n  target,\n  data,\n  feeToken,\n  sponsorApiKey,\n  retries,\n  isSponsoredCall,\n}: {\n  chainId: number;\n  target: string;\n  data: string;\n  feeToken: string;\n  sponsorApiKey: string | undefined;\n  retries: number;\n  isSponsoredCall: boolean;\n}) {\n  if (isSponsoredCall && !sponsorApiKey) {\n    throw new Error(\"Sponsor API key is required for sponsored call\");\n  }\n\n  const url = isSponsoredCall\n    ? `${GELATO_API}/relays/v2/sponsored-call`\n    : `${GELATO_API}/relays/v2/call-with-sync-fee`;\n\n  const res = await fetch(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      chainId,\n      target,\n      data,\n      feeToken,\n      sponsorApiKey,\n      retries,\n    }),\n  });\n\n  if (!res.ok) {\n    throw new Error(`Failed to call with sync fee: ${res.statusText}`);\n  }\n\n  const result = (await res.json()) as { taskId: string };\n\n  gelatoRelay.subscribeTaskStatusUpdate(result.taskId);\n\n  return result;\n}\n\nconst finalStatuses = [\n  TaskState.ExecSuccess,\n  TaskState.ExecReverted,\n  TaskState.Cancelled,\n];\n\nexport async function pollGelatoTask(\n  taskId: string,\n  cb: (status: GelatoTaskStatus | undefined, error?: Error) => void\n) {\n  const pollInterval = 500;\n  const maxAttempts = 60;\n\n  let attempts = 0;\n  let lastStatus: GelatoTaskStatus | undefined;\n\n  const startTime = Date.now();\n\n  while (attempts < maxAttempts) {\n    try {\n      const res = await fetch(`${GELATO_API}/tasks/status/${taskId}`);\n      const { task: status } = (await res.json()) as { task: GelatoTaskStatus };\n      lastStatus = status;\n\n      cb(status);\n\n      if (finalStatuses.includes(status.taskState)) {\n        const elapsedTime = Date.now() - startTime;\n        emitMetricTiming({\n          event: \"express.pollGelatoTask.finalStatus\",\n          time: elapsedTime,\n          data: {\n            status: status.taskState,\n          },\n        });\n        return;\n      }\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.error(e);\n    } finally {\n      await sleep(pollInterval);\n      attempts++;\n    }\n  }\n\n  cb(lastStatus, new Error(\"Gelato Task timeout\"));\n}\n\nexport async function getGelatoTaskDebugInfo(\n  taskId: string,\n  accountSlug?: string,\n  projectSlug?: string\n) {\n  const accountParams =\n    accountSlug && projectSlug\n      ? `?tenderlyUsername=${accountSlug}&tenderlyProjectName=${projectSlug}`\n      : \"\";\n\n  try {\n    const res = await fetch(\n      `${GELATO_API}/tasks/status/${taskId}/debug${accountParams}`\n    );\n    const debugData = await res.json();\n    return debugData;\n  } catch (error) {\n    return undefined;\n  }\n}\n"]}