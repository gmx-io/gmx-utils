{"version":3,"sources":["../../../../../src/lib/transactions/callRelayTransaction.ts"],"names":[],"mappings":";;;;AAOA,eAAsB,oBAAA,CAAqB;AAAA,EACzC,OAAA;AAAA,EACA,QAAA;AAAA,EACA,mBAAA;AAAA,EACA,oBAAA;AAAA,EACA,GAAA;AAAA,EACA;AACF,CAAA,EAOG;AACD,EAAA,IAAI;AACF,IAAA,OAAO,MAAM,IAAI,OAAA,CAAQ;AAAA,MACvB,EAAA,EAAI,kBAAA;AAAA,MACJ,IAAA,EAAM,qBAAA;AAAA,MACN,IAAA,EAAM,YAAA;AAAA,QACJ,CAAC,OAAA,EAAS,SAAA,EAAW,SAAA,EAAW,SAAS,CAAA;AAAA,QACzC;AAAA,UACE,QAAA;AAAA,UACA,WAAA,CAAY,SAAS,oBAAoB,CAAA;AAAA,UACzC,mBAAA;AAAA,UACA;AAAA;AACF;AACF,KACD,CAAA;AAAA,EACH,SAAS,EAAA,EAAS;AAChB,IAAA,IAAI,GAAG,KAAA,EAAO;AAEZ,MAAA,MAAM,EAAA,CAAG,KAAA;AAAA,IACX;AACA,IAAA,MAAM,EAAA;AAAA,EACR;AACF","file":"callRelayTransaction.js","sourcesContent":["import { Hex, encodePacked, type Address } from \"viem\";\n\nimport { ContractsChainId } from \"configs/chains\";\nimport { getContract } from \"configs/contracts\";\nimport { GMX_SIMULATION_ORIGIN } from \"configs/dataStore\";\nimport { iRpc } from \"lib/rpc/types\";\n\nexport async function callRelayTransaction({\n  chainId,\n  calldata,\n  gelatoRelayFeeToken,\n  gelatoRelayFeeAmount,\n  rpc,\n  relayRouterAddress,\n}: {\n  chainId: ContractsChainId;\n  calldata: string;\n  gelatoRelayFeeToken: string;\n  gelatoRelayFeeAmount: bigint;\n  rpc: iRpc;\n  relayRouterAddress: string;\n}) {\n  try {\n    return await rpc.ethCall({\n      to: relayRouterAddress,\n      from: GMX_SIMULATION_ORIGIN,\n      data: encodePacked(\n        [\"bytes\", \"address\", \"address\", \"uint256\"],\n        [\n          calldata as Hex,\n          getContract(chainId, \"GelatoRelayAddress\"),\n          gelatoRelayFeeToken as Address,\n          gelatoRelayFeeAmount,\n        ]\n      ),\n    });\n  } catch (ex: any) {\n    if (ex.error) {\n      // this gives much more readable error in the console with a stacktrace\n      throw ex.error;\n    }\n    throw ex;\n  }\n}\n"]}