{"version":3,"sources":["../../../../../src/lib/LruCache/index.ts"],"names":[],"mappings":";AAAO,IAAM,WAAN,MAAkB;AAAA,EAIvB,YAAY,QAAA,EAAkB;AAC5B,IAAA,IAAA,CAAK,QAAA,GAAW,QAAA;AAChB,IAAA,IAAA,CAAK,KAAA,uBAAY,GAAA,EAAe;AAAA,EAClC;AAAA,EAEA,IAAI,GAAA,EAAsB;AACxB,IAAA,OAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAAA,EAC3B;AAAA,EAEA,IAAI,GAAA,EAA4B;AAC9B,IAAA,IAAI,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA,EAAG;AAEvB,MAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAChC,MAAA,IAAA,CAAK,KAAA,CAAM,OAAO,GAAG,CAAA;AACrB,MAAA,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAA,EAAK,KAAK,CAAA;AACzB,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,OAAO,MAAA;AAAA,EACT;AAAA,EAEA,GAAA,CAAI,KAAa,KAAA,EAAgB;AAC/B,IAAA,IAAI,OAAO,QAAQ,QAAA,EAAU;AAC3B,MAAA,MAAM,IAAI,MAAM,sBAAsB,CAAA;AAAA,IACxC;AAEA,IAAA,IAAI,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA,EAAG;AAEvB,MAAA,IAAA,CAAK,KAAA,CAAM,OAAO,GAAG,CAAA;AACrB,MAAA,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAA,EAAK,KAAK,CAAA;AAAA,IAC3B,CAAA,MAAO;AAEL,MAAA,IAAI,IAAA,CAAK,aAAa,CAAA,EAAG;AACvB,QAAA;AAAA,MACF;AAEA,MAAA,IAAI,IAAA,CAAK,KAAA,CAAM,IAAA,KAAS,IAAA,CAAK,QAAA,EAAU;AACrC,QAAA,MAAM,WAAW,IAAA,CAAK,KAAA,CAAM,IAAA,EAAK,CAAE,MAAK,CAAE,KAAA;AAC1C,QAAA,IAAI,aAAa,MAAA,EAAW;AAC1B,UAAA,IAAA,CAAK,KAAA,CAAM,OAAO,QAAQ,CAAA;AAAA,QAC5B;AAAA,MACF;AAEA,MAAA,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,GAAA,EAAK,KAAK,CAAA;AAAA,IAC3B;AAAA,EACF;AAAA,EAEA,OAAO,GAAA,EAAmB;AACxB,IAAA,IAAA,CAAK,KAAA,CAAM,OAAO,GAAG,CAAA;AAAA,EACvB;AAAA,EAEA,OAAA,GAAoB;AAClB,IAAA,OAAO,KAAA,CAAM,IAAA,CAAK,IAAA,CAAK,KAAA,CAAM,MAAM,CAAA;AAAA,EACrC;AAAA,EAEA,KAAA,GAAc;AACZ,IAAA,IAAA,CAAK,MAAM,KAAA,EAAM;AAAA,EACnB;AACF","file":"index.js","sourcesContent":["export class LRUCache<T> {\n  private capacity: number;\n  private cache: Map<string, T>;\n\n  constructor(capacity: number) {\n    this.capacity = capacity;\n    this.cache = new Map<string, T>();\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key);\n  }\n\n  get(key: string): T | undefined {\n    if (this.cache.has(key)) {\n      // Move to end (most recently used) by deleting and re-inserting\n      const value = this.cache.get(key)!;\n      this.cache.delete(key);\n      this.cache.set(key, value);\n      return value;\n    }\n    return undefined;\n  }\n\n  set(key: string, value: T): void {\n    if (typeof key !== \"string\") {\n      throw new Error(\"Key must be a string\");\n    }\n\n    if (this.cache.has(key)) {\n      // Update existing key: delete and re-insert to move to end (most recently used)\n      this.cache.delete(key);\n      this.cache.set(key, value);\n    } else {\n      // If capacity is 0, don't store anything\n      if (this.capacity === 0) {\n        return;\n      }\n      // If capacity is reached, remove least recently used (first entry)\n      if (this.cache.size === this.capacity) {\n        const firstKey = this.cache.keys().next().value;\n        if (firstKey !== undefined) {\n          this.cache.delete(firstKey);\n        }\n      }\n      // Add the new key-value pair (inserted at end = most recently used)\n      this.cache.set(key, value);\n    }\n  }\n\n  delete(key: string): void {\n    this.cache.delete(key);\n  }\n\n  getKeys(): string[] {\n    return Array.from(this.cache.keys());\n  }\n\n  clean(): void {\n    this.cache.clear();\n  }\n}\n"]}