{"version":3,"sources":["../../../../../src/lib/hash/index.ts"],"names":[],"mappings":";;;;AAIO,IAAM,SAAA,GAAY;AAEzB,IAAM,SAAA,GAAY,IAAI,QAAA,CAAiB,GAAM,CAAA;AAEtC,SAAS,QAAA,CACd,WACA,UAAA,EACA;AACA,EAAA,MAAM,MAAM,IAAA,CAAK,SAAA;AAAA,IAAU,EAAE,WAAW,UAAA,EAAW;AAAA,IAAG,CAAC,GAAG,GAAA,KACxD,OAAO,QAAQ,QAAA,GAAW,MAAA,CAAO,GAAG,CAAA,GAAI;AAAA,GAC1C;AAEA,EAAA,IAAI,SAAA,CAAU,GAAA,CAAI,GAAG,CAAA,EAAG;AACtB,IAAA,OAAO,SAAA,CAAU,IAAI,GAAG,CAAA;AAAA,EAC1B;AAGA,EAAA,MAAM,gBAAgB,SAAA,CAAU,GAAA,CAAI,CAAC,IAAA,MAAU,EAAE,MAAK,CAAE,CAAA;AACxD,EAAA,MAAM,KAAA,GAAQ,mBAAA,CAAoB,aAAA,EAAe,UAAU,CAAA;AAC3D,EAAA,MAAM,IAAA,GAAO,UAAU,KAAK,CAAA;AAE5B,EAAA,SAAA,CAAU,GAAA,CAAI,KAAK,IAAI,CAAA;AAEvB,EAAA,OAAO,IAAA;AACT;AAEA,IAAM,WAAA,GAAc,IAAI,QAAA,CAAiB,GAAM,CAAA;AAExC,SAAS,WAAW,MAAA,EAAgB;AACzC,EAAA,IAAI,WAAA,CAAY,GAAA,CAAI,MAAM,CAAA,EAAG;AAC3B,IAAA,OAAO,WAAA,CAAY,IAAI,MAAM,CAAA;AAAA,EAC/B;AAEA,EAAA,MAAM,OAAO,QAAA,CAAS,CAAC,QAAQ,CAAA,EAAG,CAAC,MAAM,CAAC,CAAA;AAC1C,EAAA,WAAA,CAAY,GAAA,CAAI,QAAQ,IAAI,CAAA;AAE5B,EAAA,OAAO,IAAA;AACT;AAEO,SAAS,YAOd,GAAA,EAGA;AACA,EAAA,MAAM,SAAiC,EAAC;AAExC,EAAA,KAAA,MAAW,GAAA,IAAO,MAAA,CAAO,IAAA,CAAK,GAAG,CAAA,EAAG;AAClC,IAAA,IAAI,CAAC,GAAA,CAAI,GAAG,CAAA,EAAG;AACb,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,CAAC,SAAA,EAAW,UAAU,CAAA,GAAI,IAAI,GAAG,CAAA;AAEvC,IAAA,MAAA,CAAO,GAAG,CAAA,GAAI,QAAA,CAAS,SAAA,EAAW,UAAU,CAAA;AAAA,EAC9C;AAEA,EAAA,OAAO,MAAA;AAGT;AAEO,SAAS,aAAa,MAAA,EAAgB;AAC3C,EAAA,OAAO,SAAA,CAAU,aAAA,CAAc,MAAM,CAAC,CAAA;AACxC","file":"index.js","sourcesContent":["import { encodeAbiParameters, keccak256, stringToBytes } from \"viem\";\n\nimport { LRUCache } from \"../LruCache\";\n\nexport const ZERO_DATA = \"0x\";\n\nconst dataCache = new LRUCache<string>(10_000);\n\nexport function hashData(\n  dataTypes: string[],\n  dataValues: (string | number | bigint | boolean)[]\n) {\n  const key = JSON.stringify({ dataTypes, dataValues }, (_, val) =>\n    typeof val === \"bigint\" ? String(val) : val\n  );\n\n  if (dataCache.has(key)) {\n    return dataCache.get(key)!;\n  }\n\n  // Convert dataTypes from array of strings to array of objects with 'type' property\n  const abiParameters = dataTypes.map((type) => ({ type }));\n  const bytes = encodeAbiParameters(abiParameters, dataValues);\n  const hash = keccak256(bytes);\n\n  dataCache.set(key, hash);\n\n  return hash;\n}\n\nconst stringCache = new LRUCache<string>(10_000);\n\nexport function hashString(string: string) {\n  if (stringCache.has(string)) {\n    return stringCache.get(string)!;\n  }\n\n  const hash = hashData([\"string\"], [string]);\n  stringCache.set(string, hash);\n\n  return hash;\n}\n\nexport function hashDataMap<\n  R extends Record<\n    string,\n    | [dataTypes: string[], dataValues: (string | number | bigint | boolean)[]]\n    | undefined\n  >\n>(\n  map: R\n): {\n  [K in keyof R]: string;\n} {\n  const result: Record<string, string> = {};\n\n  for (const key of Object.keys(map)) {\n    if (!map[key]) {\n      continue;\n    }\n\n    const [dataTypes, dataValues] = map[key]!;\n\n    result[key] = hashData(dataTypes, dataValues);\n  }\n\n  return result as {\n    [K in keyof R]: string;\n  };\n}\n\nexport function keccakString(string: string) {\n  return keccak256(stringToBytes(string));\n}\n"]}