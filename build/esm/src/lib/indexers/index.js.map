{"version":3,"sources":["../../../../../src/lib/indexers/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["export type GraphQlFilters = {\n  /**\n   * `or` must be a single key-value pair in the object.\n   */\n  or?: GraphQlFilters[];\n  /**\n   * `and` must be a single key-value pair in the object.\n   */\n  and?: GraphQlFilters[];\n  /**\n   * Key must not start with an `_`. If you want to use nested filtering add `_` to the parent key itself if possible.\n   * Otherwise, if for some reason the field name itself starts with an `_`, change these types.\n   */\n  [key: `_${string}`]: never;\n  [key: string]:\n    | string\n    | number\n    | boolean\n    | undefined\n    | GraphQlFilters\n    | string[]\n    | number[]\n    | GraphQlFilters[]\n    | null;\n};\n\nexport function buildFiltersBody(\n  filters: GraphQlFilters,\n  options?: { enums?: Record<string, string> }\n): string {\n  const res: Record<string, string | null> = {};\n\n  let hadOr = false;\n  let hadAnd = false;\n\n  for (const [key, value] of Object.entries(filters)) {\n    if (value === undefined) {\n      continue;\n    }\n\n    if (typeof value === \"string\") {\n      if (options?.enums?.[value]) {\n        res[key] = value;\n      } else {\n        res[key] = `\"${value}\"`;\n      }\n    } else if (typeof value === \"number\") {\n      res[key] = `${value}`;\n    } else if (typeof value === \"boolean\") {\n      res[key] = `${value}`;\n    } else if (Array.isArray(value)) {\n      const valueStr =\n        \"[\" +\n        value\n          .map((el: string | number | GraphQlFilters) => {\n            if (typeof el === \"string\") {\n              if (options?.enums?.[el]) {\n                return el;\n              } else {\n                return `\"${el}\"`;\n              }\n            } else if (typeof el === \"number\") {\n              return `${el}`;\n            } else {\n              const elemStr = buildFiltersBody(el, options);\n\n              if (elemStr === \"{}\") {\n                return \"\";\n              } else {\n                return elemStr;\n              }\n            }\n          })\n          .filter((el) => el !== \"\")\n          .join(\",\") +\n        \"]\";\n\n      if (valueStr !== \"[]\") {\n        res[key] = valueStr;\n      }\n    } else if (value === null) {\n      res[key] = null;\n    } else {\n      const valueStr = buildFiltersBody(value, options);\n      if (valueStr !== \"{}\") {\n        res[key + \"_\"] = buildFiltersBody(value, options);\n      }\n    }\n\n    if (hadOr) {\n      throw new Error(\"Or must be a single key-value pair in the object.\");\n    }\n\n    if (key === \"or\" && res[key] !== undefined) {\n      hadOr = true;\n    }\n\n    if (hadAnd) {\n      throw new Error(\"And must be a single key-value pair in the object.\");\n    }\n\n    if (key === \"and\" && res[key] !== undefined) {\n      hadAnd = true;\n    }\n  }\n\n  const str = Object.entries(res).reduce((previous, [key, value], index) => {\n    const maybeComma = index === 0 ? \"\" : \",\";\n    return `${previous}${maybeComma}${key}:${value}`;\n  }, \"\");\n\n  return `{${str}}`;\n}\n"]}