{"version":3,"sources":["../../../../../src/lib/signing/signing.ts"],"names":[],"mappings":";;AA+BA,eAAsB,aAAA,CAAc;AAAA,EAClC,MAAA;AAAA,EACA,MAAA;AAAA,EACA,KAAA;AAAA,EACA,SAAA;AAAA,EACA,qBAAA,GAAwB,KAAA;AAAA,EACxB,QAAA,GAAW;AACb,CAAA,EAAwB;AAEtB,EAAA,KAAA,MAAW,CAAC,GAAA,EAAK,KAAK,KAAK,MAAA,CAAO,OAAA,CAAQ,MAAM,CAAA,EAAG;AACjD,IAAA,IAAI,UAAU,MAAA,EAAW;AACvB,MAAA,OAAO,OAAO,GAAG,CAAA;AAAA,IACnB;AAAA,EACF;AAEA,EAAA,KAAA,MAAW,CAAC,GAAA,EAAK,KAAK,KAAK,MAAA,CAAO,OAAA,CAAQ,KAAK,CAAA,EAAG;AAChD,IAAA,IAAI,UAAU,MAAA,EAAW;AACvB,MAAA,OAAO,MAAM,GAAG,CAAA;AAAA,IAClB;AAAA,EACF;AAEA,EAAA,KAAA,MAAW,CAAC,GAAA,EAAK,KAAK,KAAK,MAAA,CAAO,OAAA,CAAQ,SAAS,CAAA,EAAG;AACpD,IAAA,IAAI,UAAU,MAAA,EAAW;AACvB,MAAA,OAAO,UAAU,GAAG,CAAA;AAAA,IACtB;AAAA,EACF;AAEA,EAAA,IAAI,WAAA,GAAc,KAAA;AAClB,EAAA,IAAI,aAAA,GAAgB,SAAA;AAEpB,EAAA,IAAI,QAAA,EAAU;AACZ,IAAA,MAAM,MAAA,GAAS,gBAAA,CAAiB,IAAA,CAAK,MAAA,EAAQ,OAAO,SAAS,CAAA;AAC7D,IAAA,MAAM,aAAA,GAAgB;AAAA,MACpB,UAAU,CAAC,EAAE,MAAM,QAAA,EAAU,IAAA,EAAM,WAAW;AAAA,KAChD;AACA,IAAA,WAAA,GAAc,aAAA;AACd,IAAA,aAAA,GAAgB;AAAA,MACd;AAAA,KACF;AAAA,EACF;AAEA,EAAA,IAAI,qBAAA,IAAyB,OAAO,aAAA,EAAe;AACjD,IAAA,IAAI;AACF,MAAA,OAAO,MAAM,MAAA,CAAO,aAAA,CAAc,MAAA,EAAQ,aAAa,aAAa,CAAA;AAAA,IACtE,SAAS,CAAA,EAAQ;AACf,MAAA,IAAI,CAAA,CAAE,OAAA,CAAQ,QAAA,CAAS,qBAAqB,CAAA,EAAG,CAE/C,MAAO;AACL,QAAA,MAAM,CAAA;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAyBA,EAAA,OAAO,cAAA;AAyBT;AAEO,SAAS,eAAe,SAAA,EAI7B;AACA,EAAA,MAAM,GAAA,GAAM,SAAA,CAAU,KAAA,CAAM,CAAC,CAAA;AAC7B,EAAA,MAAM,CAAA,GAAI,IAAA,GAAO,GAAA,CAAI,SAAA,CAAU,GAAG,EAAE,CAAA;AACpC,EAAA,MAAM,CAAA,GAAI,IAAA,GAAO,GAAA,CAAI,SAAA,CAAU,IAAI,GAAG,CAAA;AACtC,EAAA,MAAM,IAAI,QAAA,CAAS,GAAA,CAAI,UAAU,GAAA,EAAK,GAAG,GAAG,EAAE,CAAA;AAG9C,EAAA,OAAO,EAAE,CAAA,EAAG,CAAA,EAAG,CAAA,EAAE;AACnB","file":"signing.js","sourcesContent":["import { TypedDataEncoder } from \"ethers\";\n\nexport type SignatureDomain = {\n  name: string;\n  version: string;\n  chainId: number;\n  verifyingContract: string;\n};\n// TODO\nexport type ISigner = {\n  address: string;\n  getNetwork: () => Promise<{ chainId: number }>;\n  signTypedData: (\n    domain: SignatureDomain,\n    types: SignatureTypes,\n    value: Record<string, any>\n  ) => Promise<string>;\n  sendTransaction: (params: any) => Promise<any>;\n};\n\nexport type SignatureTypes = Record<string, { name: string; type: string }[]>;\n\nexport type SignTypedDataParams = {\n  signer: ISigner;\n  types: SignatureTypes;\n  typedData: Record<string, any>;\n  domain: SignatureDomain;\n  shouldUseSignerMethod?: boolean;\n  minified?: boolean;\n};\n\nexport async function signTypedData({\n  signer,\n  domain,\n  types,\n  typedData,\n  shouldUseSignerMethod = false,\n  minified = true,\n}: SignTypedDataParams) {\n  // filter inputs\n  for (const [key, value] of Object.entries(domain)) {\n    if (value === undefined) {\n      delete domain[key];\n    }\n  }\n\n  for (const [key, value] of Object.entries(types)) {\n    if (value === undefined) {\n      delete types[key];\n    }\n  }\n\n  for (const [key, value] of Object.entries(typedData)) {\n    if (value === undefined) {\n      delete typedData[key];\n    }\n  }\n\n  let typesToSign = types;\n  let messageToSign = typedData;\n\n  if (minified) {\n    const digest = TypedDataEncoder.hash(domain, types, typedData);\n    const minifiedTypes = {\n      Minified: [{ name: \"digest\", type: \"bytes32\" }],\n    };\n    typesToSign = minifiedTypes;\n    messageToSign = {\n      digest,\n    };\n  }\n\n  if (shouldUseSignerMethod && signer.signTypedData) {\n    try {\n      return await signer.signTypedData(domain, typesToSign, messageToSign);\n    } catch (e: any) {\n      if (e.message.includes(\"requires a provider\")) {\n        // ignore and try to send request directly to provider\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  // const primaryType = Object.keys(typesToSign).filter(\n  //   (t) => t !== \"EIP712Domain\"\n  // )[0];\n\n  // TODO\n  // const provider = signer.provider;\n  // const from = await signer.getAddress();\n\n  // const eip712 = {\n  //   types: {\n  //     EIP712Domain: [\n  //       { name: \"name\", type: \"string\" },\n  //       { name: \"version\", type: \"string\" },\n  //       { name: \"chainId\", type: \"uint256\" },\n  //       { name: \"verifyingContract\", type: \"address\" },\n  //     ],\n  //     ...typesToSign,\n  //   },\n  //   primaryType,\n  //   domain,\n  //   message: messageToSign,\n  // };\n\n  return \"0x1234567890\";\n\n  // TODO\n  // const signature = await withRetry<string>(\n  //   () => {\n  //     return (provider as any).send(\"eth_signTypedData_v4\", [\n  //       from,\n  //       JSON.stringify(eip712),\n  //     ]);\n  //   },\n  //   {\n  //     retryCount: 1,\n  //     delay: 100,\n  //     shouldRetry: ({ error }) => {\n  //       const errorData = parseError(error);\n  //       return (\n  //         errorData?.errorMessage\n  //           ?.toLowerCase()\n  //           .includes(\"an error has occurred\") || false\n  //       );\n  //     },\n  //   }\n  // );\n\n  // return signature;\n}\n\nexport function splitSignature(signature: string): {\n  r: string;\n  s: string;\n  v: number;\n} {\n  const sig = signature.slice(2);\n  const r = \"0x\" + sig.substring(0, 64);\n  const s = \"0x\" + sig.substring(64, 128);\n  const v = parseInt(sig.substring(128, 130), 16);\n\n  // ECDSA signature components\n  return { r, s, v };\n}\n"]}