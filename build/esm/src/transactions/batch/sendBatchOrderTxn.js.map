{"version":3,"sources":["../../../../../src/transactions/batch/sendBatchOrderTxn.ts"],"names":["res"],"mappings":"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","file":"sendBatchOrderTxn.js","sourcesContent":["import { withRetry } from \"viem\";\n\nimport type { ContractsChainId } from \"configs/chains\";\nimport { getContract } from \"configs/contracts\";\nimport { OrderType } from \"domain/orders/types\";\nimport { isLimitOrderType } from \"domain/orders/utils\";\nimport type { TokensData } from \"domain/tokens/types\";\nimport { extendError } from \"lib/errors\";\nimport { iRpc } from \"lib/rpc/types\";\nimport { ISigner } from \"lib/signing/signing\";\nimport { callRelayTransaction } from \"lib/transactions/callRelayTransaction\";\nimport { sendExpressTransaction } from \"lib/transactions/sendExpressTransaction\";\nimport { sendWalletTransaction } from \"lib/transactions/sendWalletTransaction\";\nimport { TxnCallback, TxnEventBuilder } from \"lib/transactions/types\";\nimport {\n  getBatchOrderMulticallPayload,\n  getIsInvalidBatchReceiver,\n  getIsTwapOrderPayload,\n  type BatchOrderTxnParams,\n} from \"transactions/batch/payloads/orderTransactions\";\nimport { buildAndSignExpressBatchOrderTxn } from \"transactions/express/expressOrderUtils\";\nimport type { ExpressTxnParams } from \"transactions/express/types\";\nimport type { BlockTimestampData } from \"transactions/simulation/simulation\";\n\nimport {\n  getOrdersTriggerPriceOverrides,\n  getSimulationPrices,\n  simulateExecution,\n} from \"../simulation/simulation\";\n\nconst signerAddressError = \"Invalid receiver address\";\n\nfunction isTriggerDecreaseOrderType(orderType: OrderType): boolean {\n  return [OrderType.LimitDecrease, OrderType.StopLossDecrease].includes(\n    orderType\n  );\n}\n\nexport type BatchSimulationParams = {\n  tokensData: TokensData;\n  blockTimestampData: BlockTimestampData | undefined;\n};\n\nexport type BatchOrderTxnCtx = {\n  expressParams: ExpressTxnParams | undefined;\n  batchParams: BatchOrderTxnParams;\n  signer: ISigner;\n};\n\nconst DEFAULT_RUN_SIMULATION = () => Promise.resolve(undefined);\n\nexport async function sendBatchOrderTxn({\n  chainId,\n  signer,\n  isGmxAccount,\n  provider,\n  batchParams,\n  expressParams,\n  simulationParams,\n  callback,\n}: {\n  chainId: ContractsChainId;\n  signer: ISigner;\n  isGmxAccount: boolean;\n  provider: iRpc;\n  batchParams: BatchOrderTxnParams;\n  expressParams: ExpressTxnParams | undefined;\n  simulationParams: BatchSimulationParams | undefined;\n  callback: TxnCallback<BatchOrderTxnCtx> | undefined;\n}) {\n  const eventBuilder = new TxnEventBuilder<BatchOrderTxnCtx>({\n    expressParams,\n    batchParams,\n    signer,\n  });\n\n  try {\n    if (isGmxAccount && !expressParams) {\n      throw new Error(\n        \"Multichain orders are only supported with express params\"\n      );\n    }\n\n    if (isGmxAccount && !provider) {\n      throw new Error(\"provider is required for multichain txns\");\n    }\n    callback?.(eventBuilder.Submitted());\n\n    let runSimulation: () => Promise<void> = DEFAULT_RUN_SIMULATION;\n\n    if (simulationParams) {\n      runSimulation = () => {\n        return makeBatchOrderSimulation({\n          chainId,\n          signer,\n          batchParams,\n          blockTimestampData: simulationParams.blockTimestampData,\n          tokensData: simulationParams.tokensData,\n          expressParams,\n          provider,\n          isGmxAccount,\n        });\n      };\n    }\n\n    if (expressParams) {\n      await runSimulation().then(() => callback?.(eventBuilder.Simulated()));\n      const txnData = await buildAndSignExpressBatchOrderTxn({\n        chainId,\n        signer,\n        batchParams,\n        relayParamsPayload: expressParams.relayParamsPayload,\n        relayerFeeTokenAddress:\n          expressParams.gasPaymentParams.relayerFeeTokenAddress,\n        relayerFeeAmount: expressParams.gasPaymentParams.relayerFeeAmount,\n        subaccount: expressParams.subaccount,\n        isGmxAccount,\n      });\n\n      callback?.(eventBuilder.Sending());\n\n      const res = withRetry(\n        () =>\n          sendExpressTransaction({\n            chainId,\n            txnData,\n            isSponsoredCall: expressParams.isSponsoredCall,\n          }),\n        {\n          retryCount: 3,\n          delay: 300,\n        }\n      )\n        .then(async (res) => {\n          callback?.(\n            eventBuilder.Sent({\n              type: \"relay\",\n              relayTaskId: res?.taskId,\n            })\n          );\n\n          return res;\n        })\n        .catch((error) => {\n          throw extendError(error, {\n            errorContext: \"sending\",\n          });\n        });\n\n      return res;\n    }\n\n    const { callData, value } = getBatchOrderMulticallPayload({\n      params: batchParams,\n    });\n\n    return sendWalletTransaction({\n      chainId,\n      signer,\n      rpc: provider,\n      to: getContract(chainId, \"ExchangeRouter\"),\n      callData,\n      value,\n      runSimulation,\n      callback: (event) => {\n        callback?.(eventBuilder.extend(event));\n      },\n    });\n  } catch (error) {\n    callback?.(eventBuilder.Error(error as any));\n\n    throw error;\n  }\n}\n\nexport const makeBatchOrderSimulation = async ({\n  chainId,\n  signer,\n  isGmxAccount,\n  provider,\n  batchParams,\n  blockTimestampData,\n  tokensData,\n  expressParams,\n}: {\n  chainId: ContractsChainId;\n  signer: ISigner;\n  isGmxAccount: boolean;\n  provider: iRpc;\n  batchParams: BatchOrderTxnParams;\n  blockTimestampData: BlockTimestampData | undefined;\n  tokensData: TokensData;\n  expressParams: ExpressTxnParams | undefined;\n}): Promise<void> => {\n  try {\n    if (getIsInvalidBatchReceiver(batchParams, signer.address)) {\n      throw extendError(new Error(signerAddressError), {\n        errorContext: \"simulation\",\n      });\n    }\n\n    if (\n      expressParams?.subaccount &&\n      expressParams?.subaccountValidations &&\n      !expressParams.subaccountValidations.isValid\n    ) {\n      const { onchainData, signedApproval } = expressParams.subaccount;\n\n      throw extendError(new Error(\"Invalid subaccount\"), {\n        data: {\n          isExpired: expressParams.subaccountValidations.isExpired,\n          isActionsExceeded:\n            expressParams.subaccountValidations.isActionsExceeded,\n          isNonceExceeded: expressParams.subaccountValidations.isNonceExpired,\n          onchainData: {\n            maxAllowedCount: onchainData.maxAllowedCount,\n            currentCount: onchainData.currentActionsCount,\n            expiresAt: onchainData.expiresAt,\n            isActive: onchainData.active,\n            nonce: onchainData.approvalNonce,\n            multichainNonce: onchainData.multichainApprovalNonce,\n            integrationId: onchainData.integrationId,\n          },\n          signedData: {\n            maxAllowedCount: signedApproval.maxAllowedCount,\n            expiresAt: signedApproval.expiresAt,\n            shouldAdd: signedApproval.shouldAdd,\n            nonce: signedApproval.nonce,\n            integrationId: signedApproval.integrationId,\n          },\n        },\n      });\n    }\n\n    if (\n      expressParams &&\n      expressParams.gasPaymentValidations.isOutGasTokenBalance\n    ) {\n      throw extendError(new Error(\"Out of gas token balance\"), {\n        data: {\n          gasPaymentTokenAmount:\n            expressParams.gasPaymentParams.gasPaymentTokenAmount,\n          gasPaymentTokenAddress:\n            expressParams.gasPaymentParams.gasPaymentTokenAddress,\n        },\n      });\n    }\n\n    if (\n      expressParams &&\n      expressParams.gasPaymentValidations.needGasPaymentTokenApproval\n    ) {\n      throw extendError(new Error(\"Need gas payment token approval\"), {\n        data: {\n          gasPaymentTokenAmount:\n            expressParams.gasPaymentParams.gasPaymentTokenAmount,\n          gasPaymentTokenAddress:\n            expressParams.gasPaymentParams.gasPaymentTokenAddress,\n        },\n      });\n    }\n\n    const isSimulationAllowed = batchParams.createOrderParams.every(\n      (co) =>\n        !isLimitOrderType(co.orderPayload.orderType) &&\n        !isTriggerDecreaseOrderType(co.orderPayload.orderType) &&\n        !getIsTwapOrderPayload(co.orderPayload)\n    );\n\n    // Simulate execution makes sense only for order creation transactions\n    if (batchParams.createOrderParams.length === 0 || !isSimulationAllowed) {\n      return Promise.resolve();\n    }\n\n    if (isGmxAccount) {\n      if (!expressParams) {\n        throw new Error(\n          \"Multichain orders are only supported with express params\"\n        );\n      }\n\n      const { callData, feeAmount, feeToken, to } =\n        await buildAndSignExpressBatchOrderTxn({\n          signer,\n          chainId,\n          relayParamsPayload: expressParams.relayParamsPayload,\n          batchParams: batchParams,\n          subaccount: expressParams.subaccount,\n          emptySignature: true,\n          relayerFeeTokenAddress:\n            expressParams.gasPaymentParams.relayerFeeTokenAddress,\n          relayerFeeAmount: expressParams.gasPaymentParams.relayerFeeAmount,\n          isGmxAccount,\n        });\n\n      await callRelayTransaction({\n        chainId,\n        relayRouterAddress: to,\n        gelatoRelayFeeToken: feeToken,\n        gelatoRelayFeeAmount: feeAmount,\n        rpc: provider,\n        calldata: callData,\n      });\n    } else {\n      const { encodedMulticall, value } = getBatchOrderMulticallPayload({\n        params: {\n          ...batchParams,\n          createOrderParams: [batchParams.createOrderParams[0]],\n        },\n      });\n\n      await simulateExecution(chainId, {\n        account: signer.address,\n        prices: getSimulationPrices(\n          chainId,\n          tokensData,\n          getOrdersTriggerPriceOverrides([batchParams.createOrderParams[0]])\n        ),\n        tokenPermits: expressParams?.relayParamsPayload.tokenPermits ?? [],\n        createMulticallPayload: encodedMulticall,\n        value,\n        blockTimestampData,\n        isExpress: Boolean(expressParams),\n      });\n    }\n  } catch (error) {\n    throw extendError(error, {\n      errorContext: \"simulation\",\n    });\n  }\n};\n"]}