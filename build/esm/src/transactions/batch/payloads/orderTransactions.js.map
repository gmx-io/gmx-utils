{"version":3,"sources":["../../../../../../src/transactions/batch/payloads/orderTransactions.ts"],"names":["params"],"mappings":";;;;;;;;;;;;;;;;;;;AAwOO,MAAM,wBAAA,GAAgD;AAAA,EAC3D,mBAAmB,EAAC;AAAA,EACpB,mBAAmB,EAAC;AAAA,EACpB,mBAAmB;AACrB;AAEO,SAAS,sBACd,CAAA,EACuC;AACvC,EAAA,MAAM,oBAAA,GAAuB,2CAA2C,CAAC,CAAA;AAEzE,EAAA,MAAM,YAAA,GAAmC;AAAA,IACvC,SAAA,EAAW;AAAA,MACT,UAAU,CAAA,CAAE,QAAA;AAAA,MACZ,oBAAA,EAAsB,WAAA;AAAA,MACtB,gBAAA,EAAkB,WAAA;AAAA,MAClB,aAAA,EAAe,EAAE,aAAA,IAAiB,WAAA;AAAA,MAClC,MAAA,EAAQ,WAAA;AAAA,MACR,wBACE,oBAAA,CAAqB,6BAAA;AAAA,MACvB,UAAU,oBAAA,CAAqB;AAAA,KACjC;AAAA,IACA,OAAA,EAAS;AAAA,MACP,YAAA,EAAc,EAAA;AAAA,MACd,8BACE,oBAAA,CAAqB,4BAAA;AAAA;AAAA,MAEvB,YAAA,EAAe,EAAE,YAAA,IAAkC,EAAA;AAAA,MACnD,eAAA,EAAiB,EAAA;AAAA,MACjB,cAAc,CAAA,CAAE,kBAAA;AAAA,MAChB,gBAAA,EAAkB,EAAA;AAAA,MAClB,eAAA,EAAiB,qBAAA;AAAA,QACf,CAAA,CAAE,eAAA;AAAA,QACF,oBAAA,CAAqB;AAAA,OACvB;AAAA,MACA,aAAA,EAAe,EAAE,aAAA,IAAiB;AAAA,KACpC;AAAA,IACA,WAAW,CAAA,CAAE,SAAA;AAAA,IACb,0BAA0B,wBAAA,CAAyB,MAAA;AAAA,IACnD,MAAA,EAAQ,KAAA;AAAA,IACR,uBAAA,EACE,oBAAA,CAAqB,eAAA,IACrB,oBAAA,CAAqB,eAAA;AAAA,IACvB,YAAY,CAAA,CAAE,UAAA;AAAA,IACd,YAAA,EAAc,EAAE,YAAA,IAAgB,QAAA;AAAA,IAChC,UAAU;AAAC,GACb;AAEA,EAAA,OAAO;AAAA,IACL,MAAA,EAAQ,CAAA;AAAA,IACR,YAAA;AAAA,IACA;AAAA,GACF;AACF;AAEO,SAAS,0BACd,CAAA,EACmD;AACnD,EAAA,MAAM,uBAAuB,0CAAA,CAA2C;AAAA,IACtE,GAAG,CAAA;AAAA,IACH,eAAA,EAAiB,EAAA;AAAA,IACjB,mBAAA,EAAqB;AAAA,GACtB,CAAA;AAED,EAAA,MAAM,UAAA,GAAa,QAAA,CAAS,CAAA,CAAE,OAAA,EAAS,EAAE,iBAAiB,CAAA;AAE1D,EAAA,IAAI,eAAA;AACJ,EAAA,IAAI,CAAA,CAAE,oBAAoB,UAAA,EAAY;AACpC,IAAA,eAAA,GAAkB,UAAA;AAAA,EACpB,CAAA,MAAO;AACL,IAAA,eAAA,GAAkB,sBAAA;AAAA,MAChB,oBAAA;AAAA,QACE,CAAA,CAAE,eAAA;AAAA,QACF,CAAA,CAAE,eAAA;AAAA,QACF,IAAA;AAAA,QACA,CAAA,CAAE;AAAA,OACJ;AAAA,MACA,UAAA,CAAW;AAAA,KACb;AAAA,EACF;AAEA,EAAA,IAAI,YAAA;AACJ,EAAA,IAAI,CAAA,CAAE,iBAAiB,UAAA,EAAY;AACjC,IAAA,YAAA,GAAe,UAAA;AAAA,EACjB,CAAA,MAAO;AACL,IAAA,YAAA,GAAe,sBAAA;AAAA,MACb,EAAE,YAAA,IAAgB,EAAA;AAAA,MAClB,UAAA,CAAW;AAAA,KACb;AAAA,EACF;AAEA,EAAA,MAAM,YAAA,GAAmC;AAAA,IACvC,SAAA,EAAW;AAAA,MACT,UAAU,CAAA,CAAE,QAAA;AAAA,MACZ,oBAAA,EAAsB,WAAA;AAAA,MACtB,gBAAA,EAAkB,WAAA;AAAA,MAClB,aAAA,EAAe,EAAE,aAAA,IAAiB,WAAA;AAAA,MAClC,QAAQ,CAAA,CAAE,aAAA;AAAA,MACV,wBACE,oBAAA,CAAqB,6BAAA;AAAA,MACvB,UAAU,oBAAA,CAAqB;AAAA,KACjC;AAAA,IACA,OAAA,EAAS;AAAA,MACP,cAAc,CAAA,CAAE,YAAA;AAAA,MAChB,8BACE,oBAAA,CAAqB,4BAAA;AAAA,MACvB,YAAA;AAAA,MACA,eAAA;AAAA,MACA,cAAc,CAAA,CAAE,kBAAA;AAAA,MAChB,gBAAA,EAAkB,EAAA;AAAA,MAClB,eAAA,EAAiB,qBAAA;AAAA,QACf,CAAA,CAAE,eAAA;AAAA,QACF,oBAAA,CAAqB;AAAA,OACvB;AAAA,MACA,aAAA,EAAe,EAAE,aAAA,IAAiB;AAAA,KACpC;AAAA,IACA,WAAW,CAAA,CAAE,SAAA;AAAA,IACb,0BAA0B,wBAAA,CAAyB,MAAA;AAAA,IACnD,QAAQ,CAAA,CAAE,MAAA;AAAA,IACV,yBAAyB,oBAAA,CAAqB,eAAA;AAAA,IAC9C,YAAY,CAAA,CAAE,UAAA;AAAA,IACd,YAAA,EAAc,EAAE,YAAA,IAAgB,QAAA;AAAA,IAChC,UAAU;AAAC,GACb;AAEA,EAAA,OAAO;AAAA,IACL,MAAA,EAAQ,CAAA;AAAA,IACR,YAAA;AAAA,IACA;AAAA,GACF;AACF;AAEO,SAAS,0BACd,CAAA,EACmD;AACnD,EAAA,MAAM,UAAA,GAAa,QAAA,CAAS,CAAA,CAAE,OAAA,EAAS,EAAE,iBAAiB,CAAA;AAC1D,EAAA,MAAM,oBAAA,GAAuB,qCAAqC,CAAC,CAAA;AAEnE,EAAA,IAAI,eAAA;AACJ,EAAA,IAAI,CAAA,CAAE,oBAAoB,UAAA,EAAY;AACpC,IAAA,eAAA,GAAkB,UAAA;AAAA,EACpB,CAAA,MAAO;AACL,IAAA,eAAA,GAAkB,sBAAA;AAAA,MAChB,oBAAA;AAAA,QACE,CAAA,CAAE,eAAA;AAAA,QACF,CAAA,CAAE,eAAA;AAAA,QACF,KAAA;AAAA,QACA,CAAA,CAAE;AAAA,OACJ;AAAA,MACA,UAAA,CAAW;AAAA,KACb;AAAA,EACF;AAEA,EAAA,IAAI,YAAA;AACJ,EAAA,IAAI,CAAA,CAAE,iBAAiB,UAAA,EAAY;AACjC,IAAA,YAAA,GAAe,UAAA;AAAA,EACjB,CAAA,MAAO;AACL,IAAA,YAAA,GAAe,sBAAA;AAAA,MACb,EAAE,YAAA,IAAgB,EAAA;AAAA,MAClB,UAAA,CAAW;AAAA,KACb;AAAA,EACF;AAEA,EAAA,MAAM,YAAA,GAAmC;AAAA,IACvC,SAAA,EAAW;AAAA,MACT,UAAU,CAAA,CAAE,QAAA;AAAA,MACZ,oBAAA,EAAsB,WAAA;AAAA,MACtB,gBAAA,EAAkB,WAAA;AAAA,MAClB,aAAA,EAAe,EAAE,aAAA,IAAiB,WAAA;AAAA,MAClC,QAAQ,CAAA,CAAE,aAAA;AAAA,MACV,wBACE,oBAAA,CAAqB,6BAAA;AAAA,MACvB,UAAU,oBAAA,CAAqB;AAAA,KACjC;AAAA,IACA,OAAA,EAAS;AAAA,MACP,cAAc,CAAA,CAAE,YAAA;AAAA,MAChB,8BACE,oBAAA,CAAqB,4BAAA;AAAA,MACvB,YAAA;AAAA,MACA,eAAA;AAAA,MACA,cAAc,CAAA,CAAE,kBAAA;AAAA,MAChB,gBAAA,EAAkB,EAAA;AAAA,MAClB,eAAA,EAAiB,qBAAA;AAAA,QACf,CAAA,CAAE,eAAA;AAAA,QACF,oBAAA,CAAqB;AAAA,OACvB;AAAA,MACA,aAAA,EAAe,EAAE,aAAA,IAAiB;AAAA,KACpC;AAAA,IACA,WAAW,CAAA,CAAE,SAAA;AAAA,IACb,0BAA0B,CAAA,CAAE,wBAAA;AAAA,IAC5B,QAAQ,CAAA,CAAE,MAAA;AAAA,IACV,uBAAA,EAAyB,EAAE,mBAAA,KAAwB,oBAAA;AAAA,IACnD,YAAY,CAAA,CAAE,UAAA;AAAA,IACd,YAAA,EAAc,EAAE,YAAA,IAAgB,QAAA;AAAA,IAChC,UAAU;AAAC,GACb;AAEA,EAAA,OAAO;AAAA,IACL,MAAA,EAAQ,CAAA;AAAA,IACR,YAAA;AAAA,IACA;AAAA,GACF;AACF;AAEO,SAAS,uBAAA,CAKd,GAAM,UAAA,EAAwD;AAC9D,EAAA,MAAM,gBAAgB,uBAAA,CAAwB;AAAA,IAC5C,eAAe,UAAA,CAAW;AAAA,GAC3B,CAAA;AAED,EAAA,IAAI,eAAA,CAAgB,CAAA,CAAE,SAAS,CAAA,EAAG;AAChC,IAAA,OAAO,KAAA,CAAM,KAAK,EAAE,MAAA,EAAQ,WAAW,aAAA,EAAc,EAAG,CAAC,CAAA,EAAG,CAAA,KAAM;AAChE,MAAA,MAAM,MAAA,GAAS,CAAA;AAEf,MAAA,OAAO,qBAAA,CAAsB;AAAA,QAC3B,SAAS,MAAA,CAAO,OAAA;AAAA,QAChB,UAAU,MAAA,CAAO,QAAA;AAAA,QACjB,mBAAmB,MAAA,CAAO,iBAAA;AAAA,QAC1B,iBAAiB,MAAA,CAAO,eAAA;AAAA,QACxB,qBAAqB,MAAA,CAAO,mBAAA;AAAA,QAC5B,UAAU,MAAA,CAAO,QAAA;AAAA,QACjB,iBAAA,EAAmB,MAAA;AAAA,QACnB,eAAA,EAAiB,EAAA;AAAA,QACjB,cAAc,MAAA,CAAO,YAAA;AAAA,QACrB,cAAc,MAAA,CAAO,YAAA;AAAA,QACrB,YAAY,MAAA,CAAO,UAAA;AAAA,QACnB,eAAA,EAAiB,CAAA;AAAA,QACjB,GAAI,MAAA,CAAO,oBAAA,KAAyB,MAAA,IAAa;AAAA,UAC/C,oBAAA,EACE,MAAA,CAAO,oBAAA,GAAuB,MAAA,CAAO,WAAW,aAAa;AAAA,SACjE;AAAA,QACA,cAAA,EACE,MAAA,CAAO,cAAA,GAAiB,MAAA,CAAO,WAAW,aAAa,CAAA;AAAA,QACzD,kBAAA,EACE,MAAA,CAAO,kBAAA,GAAqB,MAAA,CAAO,WAAW,aAAa,CAAA;AAAA,QAC7D,aAAA,EAAe,oBAAA;AAAA,UACb,UAAA,CAAW,QAAA;AAAA,UACX,UAAA,CAAW,aAAA;AAAA,UACX;AAAA,SACF;AAAA,QACA,WAAW,SAAA,CAAU,SAAA;AAAA,QACrB;AAAA,OACD,CAAA;AAAA,IACH,CAAC,CAAA;AAAA,EACH;AAEA,EAAA,IAAI,mBAAA,CAAoB,CAAA,CAAE,SAAS,CAAA,EAAG;AACpC,IAAA,OAAO,KAAA,CAAM,KAAK,EAAE,MAAA,EAAQ,WAAW,aAAA,EAAc,EAAG,CAAC,CAAA,EAAG,CAAA,KAAM;AAChE,MAAA,MAAM,MAAA,GAAS,CAAA;AAEf,MAAA,MAAM,eAAA,GAAkB,MAAA,CAAO,MAAA,GAAS,UAAA,GAAa,EAAA;AACrD,MAAA,MAAM,YAAA,GAAe,eAAA;AAErB,MAAA,OAAO,yBAAA,CAA0B;AAAA,QAC/B,SAAS,MAAA,CAAO,OAAA;AAAA,QAChB,UAAU,MAAA,CAAO,QAAA;AAAA,QACjB,mBAAmB,MAAA,CAAO,iBAAA;AAAA,QAC1B,cAAc,MAAA,CAAO,YAAA;AAAA,QACrB,YAAY,MAAA,CAAO,UAAA;AAAA,QACnB,UAAU,MAAA,CAAO,QAAA;AAAA,QACjB,iBAAA,EAAmB,MAAA;AAAA,QACnB,eAAe,MAAA,CAAO,aAAA;AAAA,QACtB,mBAAmB,MAAA,CAAO,iBAAA;AAAA,QAC1B,QAAQ,MAAA,CAAO,MAAA;AAAA,QACf,YAAA,EAAc,MAAA,CAAO,YAAA,GAAe,MAAA,CAAO,WAAW,aAAa,CAAA;AAAA,QACnE,iBAAA,EACE,MAAA,CAAO,iBAAA,GAAoB,MAAA,CAAO,WAAW,aAAa,CAAA;AAAA,QAC5D,iBAAiB,MAAA,CAAO,eAAA;AAAA,QACxB,eAAA,EAAiB,CAAA;AAAA,QACjB,cAAA,EACE,MAAA,CAAO,cAAA,GAAiB,MAAA,CAAO,WAAW,aAAa,CAAA;AAAA,QACzD,wBAAwB,MAAA,CAAO,sBAAA;AAAA,QAC/B,qBAAA,EACE,MAAA,CAAO,qBAAA,GAAwB,MAAA,CAAO,WAAW,aAAa,CAAA;AAAA,QAChE,kBAAA,EACE,MAAA,CAAO,kBAAA,GAAqB,MAAA,CAAO,WAAW,aAAa,CAAA;AAAA,QAC7D,aAAA,EAAe,oBAAA;AAAA,UACb,UAAA,CAAW,QAAA;AAAA,UACX,UAAA,CAAW,aAAA;AAAA,UACX;AAAA,SACF;AAAA,QACA,WAAW,SAAA,CAAU,aAAA;AAAA,QACrB,eAAA;AAAA,QACA,YAAA;AAAA,QACA;AAAA,OACD,CAAA;AAAA,IACH,CAAC,CAAA;AAAA,EACH;AAEA,EAAA,OAAO,KAAA,CAAM,KAAK,EAAE,MAAA,EAAQ,WAAW,aAAA,EAAc,EAAG,CAAC,CAAA,EAAG,CAAA,KAAM;AAChE,IAAA,MAAM,MAAA,GAAS,CAAA;AAEf,IAAA,MAAM,eAAA,GAAkB,CAAC,MAAA,CAAO,MAAA,GAAS,UAAA,GAAa,EAAA;AACtD,IAAA,MAAM,YAAA,GAAe,eAAA;AAErB,IAAA,OAAO,yBAAA,CAA0B;AAAA,MAC/B,SAAS,MAAA,CAAO,OAAA;AAAA,MAChB,UAAU,MAAA,CAAO,QAAA;AAAA,MACjB,mBAAmB,MAAA,CAAO,iBAAA;AAAA,MAC1B,cAAc,MAAA,CAAO,YAAA;AAAA,MACrB,YAAY,MAAA,CAAO,UAAA;AAAA,MACnB,UAAU,MAAA,CAAO,QAAA;AAAA,MACjB,iBAAA,EAAmB,MAAA;AAAA,MACnB,eAAe,MAAA,CAAO,aAAA;AAAA,MACtB,mBAAmB,MAAA,CAAO,iBAAA;AAAA,MAC1B,QAAQ,MAAA,CAAO,MAAA;AAAA,MACf,wBAAwB,MAAA,CAAO,sBAAA;AAAA,MAC/B,qBAAA,EACE,MAAA,CAAO,qBAAA,GAAwB,MAAA,CAAO,WAAW,aAAa,CAAA;AAAA,MAChE,YAAA,EAAc,MAAA,CAAO,YAAA,GAAe,MAAA,CAAO,WAAW,aAAa,CAAA;AAAA,MACnE,iBAAA,EACE,MAAA,CAAO,iBAAA,GAAoB,MAAA,CAAO,WAAW,aAAa,CAAA;AAAA,MAC5D,kBAAA,EACE,MAAA,CAAO,kBAAA,GAAqB,MAAA,CAAO,WAAW,aAAa,CAAA;AAAA,MAC7D,aAAA,EAAe,oBAAA;AAAA,QACb,UAAA,CAAW,QAAA;AAAA,QACX,UAAA,CAAW,aAAA;AAAA,QACX;AAAA,OACF;AAAA,MACA,WAAW,SAAA,CAAU,aAAA;AAAA,MACrB,eAAA;AAAA,MACA,YAAA;AAAA,MACA,eAAA,EAAiB,CAAA;AAAA,MACjB,aAAA;AAAA,MACA,YAAA,EAAc,MAAA,CAAO,YAAA,GAAe,MAAA,CAAO,WAAW,aAAa,CAAA;AAAA,MACnE,qBAAqB,MAAA,CAAO,mBAAA;AAAA,MAC5B,0BAA0B,MAAA,CAAO;AAAA,KAClC,CAAA;AAAA,EACH,CAAC,CAAA;AACH;AAEO,SAAS,sBAAsB,CAAA,EAAuB;AAC3D,EAAA,OAAO,CAAA,CAAE,QAAQ,aAAA,KAAkB,EAAA;AACrC;AAEO,SAAS,wBACd,CAAA,EACsB;AACtB,EAAA,MAAM,UAAA,GAAa,QAAA,CAAS,CAAA,CAAE,OAAA,EAAS,EAAE,iBAAiB,CAAA;AAE1D,EAAA,OAAO;AAAA,IACL,MAAA,EAAQ,CAAA;AAAA,IACR,aAAA,EAAe;AAAA,MACb,UAAU,CAAA,CAAE,QAAA;AAAA,MACZ,cAAc,CAAA,CAAE,YAAA;AAAA,MAChB,YAAA,EAAc,eAAA,CAAgB,CAAA,CAAE,SAAS,CAAA,GACpC,CAAA,CAAE,YAAA,GACH,sBAAA,CAAuB,CAAA,CAAE,YAAA,EAAc,UAAA,CAAW,QAAQ,CAAA;AAAA,MAC9D,eAAA,EAAiB,sBAAA;AAAA,QACf,CAAA,CAAE,eAAA;AAAA,QACF,UAAA,CAAW;AAAA,OACb;AAAA,MACA,iBAAiB,CAAA,CAAE,eAAA;AAAA,MACnB,YAAY,CAAA,CAAE,UAAA;AAAA,MACd,aAAA,EAAe,EAAA;AAAA,MACf,mBAAmB,CAAA,CAAE;AAAA;AACvB,GACF;AACF;AAEO,SAAS,yBAAA,CAA0B;AAAA,EACxC,WAAA,EAAa,EAAE,iBAAA,EAAmB,iBAAA,EAAkB;AAAA,EACpD,UAAA;AAAA,EACA;AACF,CAAA,EAI6B;AAC3B,EAAA,IAAI,cAAA,GAAiB,EAAA;AACrB,EAAA,IAAI,QAAA,GAAW,EAAA;AAEf,EAAA,MAAM,MAAM,QAAA,CAAS,UAAA,EAAY,eAAA,CAAgB,OAAO,EAAE,OAAO,CAAA;AAEjE,EAAA,IAAI,CAAC,GAAA,EAAK;AACR,IAAA,OAAO,MAAA;AAAA,EACT;AAEA,EAAA,KAAA,MAAW,MAAM,iBAAA,EAAmB;AAClC,IAAA,cAAA,IAAkB,EAAA,CAAG,aAAa,OAAA,CAAQ,YAAA;AAC1C,IAAA,QAAA,IAAY,GAAG,MAAA,CAAO,iBAAA;AAAA,EACxB;AAEA,EAAA,KAAA,MAAW,MAAM,iBAAA,EAAmB;AAClC,IAAA,cAAA,IAAkB,GAAG,aAAA,CAAc,iBAAA;AAAA,EACrC;AAEA,EAAA,MAAM,MAAA,GAAS,YAAA;AAAA,IACb,cAAA;AAAA,IACA,GAAA,CAAI,QAAA;AAAA,IACJ,IAAI,MAAA,CAAO;AAAA,GACb;AACA,EAAA,MAAM,YACJ,MAAA,GAAS,cAAA,CAAe,mBAAA,CAAoB,OAAO,GAAG,YAAY,CAAA;AACpE,EAAA,MAAM,gBACJ,MAAA,GAAS,cAAA,CAAe,wBAAA,CAAyB,OAAO,GAAG,YAAY,CAAA;AAEzE,EAAA,OAAO;AAAA,IACL,cAAA;AAAA,IACA,QAAA;AAAA,IACA,MAAA;AAAA,IACA,QAAA,EAAU,GAAA;AAAA,IACV,SAAA;AAAA,IACA;AAAA,GACF;AACF;AAEO,SAAS,iCACd,WAAA,EACA;AACA,EAAA,MAAM,aAAiD,EAAC;AAExD,EAAA,KAAA,MAAW,EAAA,IAAM,YAAY,iBAAA,EAAmB;AAC9C,IAAA,MAAM,eAAA,GAAkB,GAAG,oBAAA,EAAsB,eAAA;AACjD,IAAA,MAAM,cAAA,GAAiB,GAAG,oBAAA,EAAsB,cAAA;AAEhD,IAAA,IAAI,eAAA,IAAmB,mBAAmB,MAAA,EAAW;AACnD,MAAA,UAAA,CAAW,eAAe,CAAA,GAAA,CACvB,UAAA,CAAW,eAAe,KAAK,EAAA,IAAM,cAAA;AAAA,IAC1C;AAAA,EACF;AAEA,EAAA,OAAO,UAAA;AACT;AAEO,SAAS,6BAA6B,WAAA,EAAkC;AAC7E,EAAA,OAAO,WAAA,CAAY,iBAAA,CAAkB,MAAA,CAAO,CAAC,KAAK,EAAA,KAAO;AACvD,IAAA,MAAM,iBAAA,GACJ,GAAG,MAAA,CACH,iBAAA;AAEF,IAAA,IAAI,iBAAA,EAAmB;AACrB,MAAA,OAAO,GAAA,GAAM,kBAAkB,OAAA,CAAQ,YAAA;AAAA,IACzC;AAEA,IAAA,OAAO,GAAA;AAAA,EACT,GAAG,EAAE,CAAA;AACP;AAEO,SAAS,oCAAA,CAAqC;AAAA,EACnD,OAAA;AAAA,EACA,kBAAA;AAAA,EACA,sBAAA;AAAA,EACA,qBAAA;AAAA,EACA,QAAA;AAAA,EACA,YAAA;AAAA,EACA;AACF,CAAA,EAQyB;AACvB,EAAA,MAAM,iBAAA,GAAoB,WAAA,CAAY,OAAA,EAAS,YAAY,CAAA;AAE3D,EAAA,MAAM,EAAE,cAAA,EAAgB,KAAA,EAAM,GAAI,gBAAA,CAAiB;AAAA,IACjD;AAAA,MACE,YAAA,EAAc,oBAAA;AAAA,MACd,WAAA,EAAa,iBAAA;AAAA,MACb,MAAA,EAAQ;AAAA;AACV,GACD,CAAA;AAED,EAAA,OAAO;AAAA,IACL,eAAA,EAAiB,KAAA;AAAA,IACjB,iBAAiB,mBAAA,KAAwB,oBAAA;AAAA,IACzC,6BAAA,EAA+B,mBAAA;AAAA,MAC7B,OAAA;AAAA,MACA,sBAAA;AAAA,MACA;AAAA,KACF;AAAA,IACA,4BAAA,EAA8B,qBAAA;AAAA,IAC9B,cAAA;AAAA,IACA,eAAA,EAAiB,WAAA;AAAA,IACjB,cAAA,EAAgB,EAAA;AAAA,IAChB,eAAA,EAAiB,YAAA;AAAA,IACjB,QAAA;AAAA,IACA,KAAA;AAAA,IACA,aAAA,EAAe;AAAA,GACjB;AACF;AAEO,SAAS,0CAAA,CAA2C;AAAA,EACzD,OAAA;AAAA,EACA,QAAA;AAAA,EACA,eAAA;AAAA,EACA,cAAA;AAAA,EACA,mBAAA;AAAA,EACA,kBAAA;AAAA,EACA,iBAAA;AAAA,EACA,eAAA;AAAA,EACA;AACF,CAAA,EAUyB;AACvB,EAAA,MAAM,kBAAkB,eAAA,KAAoB,oBAAA;AAC5C,EAAA,MAAM,kBAAkB,mBAAA,KAAwB,oBAAA;AAChD,EAAA,MAAM,iBAAA,GAAoB,WAAA,CAAY,OAAA,EAAS,YAAY,CAAA;AAC3D,EAAA,MAAM,sBAAA,GAAyB,WAAA,CAAY,OAAA,EAAS,iBAAiB,CAAA;AAErE,EAAA,IAAI,mBAAA,GAAsB,cAAA;AAE1B,EAAA,MAAM,EAAE,cAAA,EAAgB,KAAA,EAAM,GAAI,gBAAA,CAAiB;AAAA,IACjD;AAAA,MACE,YAAA,EAAc,oBAAA;AAAA,MACd,WAAA,EAAa,iBAAA;AAAA,MACb,MAAA,EAAQ;AAAA,KACV;AAAA,IACA;AAAA,MACE,YAAA,EAAc,eAAA;AAAA,MACd,WAAA,EAAa,oBACT,sBAAA,GACA,iBAAA;AAAA,MACJ,MAAA,EAAQ;AAAA;AACV,GACD,CAAA;AAED,EAAA,IAAI,6BAAA,GAAgC,mBAAA;AAAA,IAClC,OAAA;AAAA,IACA,eAAA;AAAA,IACA;AAAA,GACF;AACA,EAAA,IAAI,4BAAA,GAA+B,cAAA;AACnC,EAAA,IAAI,aAAA;AAEJ,EAAA,IAAI,qBAAqB,QAAA,EAAU;AAKjC,IAAA,6BAAA,GAAgC,mBAAA;AAAA,MAC9B,OAAA;AAAA,MACA,iBAAA,CAAkB,eAAA;AAAA,MAClB;AAAA,KACF;AACA,IAAA,4BAAA,GAA+B,EAAA;AAC/B,IAAA,aAAA,GAAgB,uBAAA,CAAwB;AAAA,MACtC,OAAA;AAAA,MACA,OAAA,EAAS,QAAA;AAAA,MACT,KAAA,EAAO;AAAA,KACR,CAAA;AACD,IAAA,mBAAA,GAAsB,iBAAA,CAAkB,QAAA;AAAA,EAC1C;AAEA,EAAA,OAAO;AAAA,IACL,eAAA;AAAA,IACA,eAAA;AAAA,IACA,6BAAA;AAAA,IACA,4BAAA;AAAA,IACA,cAAA;AAAA,IACA,eAAA;AAAA,IACA,cAAA,EAAgB,mBAAA;AAAA,IAChB,eAAA;AAAA,IACA,QAAA;AAAA,IACA,KAAA;AAAA,IACA;AAAA,GACF;AACF;AAEO,SAAS,sBACd,WAAA,EACsB;AACtB,EAAA,MAAM,gBAAwC,EAAC;AAE/C,EAAA,KAAA,MAAW,iBAAA,IAAqB,YAAY,iBAAA,EAAmB;AAC7D,IAAA,IAAI,iBAAA,CAAkB,sBAAsB,aAAA,EAAe;AACzD,MAAA,aAAA,CAAc,IAAA,CAAK,iBAAA,CAAkB,oBAAA,CAAqB,aAAa,CAAA;AAAA,IACzE;AAAA,EACF;AAEA,EAAA,OAAO,qBAAqB,aAAa,CAAA;AAC3C;AAEO,SAAS,qBACd,aAAA,EACsB;AACtB,EAAA,MAAM,gBAAoD,EAAC;AAC3D,EAAA,MAAM,kBAAsD,EAAC;AAC7D,EAAA,MAAM,sBAAgC,EAAC;AACvC,EAAA,MAAM,uBAAiC,EAAC;AAExC,EAAA,KAAA,MAAW,QAAQ,aAAA,EAAe;AAChC,IAAA,KAAA,MAAW,CAAC,KAAA,EAAO,YAAY,KAAK,IAAA,CAAK,UAAA,CAAW,SAAQ,EAAG;AAC7D,MAAA,aAAA,CAAc,YAAY,KACvB,aAAA,CAAc,YAAY,KAAK,EAAA,IAAM,IAAA,CAAK,YAAY,KAAK,CAAA;AAAA,IAChE;AAEA,IAAA,KAAA,MAAW,CAAC,KAAA,EAAO,YAAY,KAAK,IAAA,CAAK,YAAA,CAAa,SAAQ,EAAG;AAC/D,MAAA,eAAA,CAAgB,YAAY,CAAA,GAAI,IAAA,CAAK,eAAA,CAAgB,KAAK,CAAA;AAAA,IAC5D;AAEA,IAAA,mBAAA,CAAoB,IAAA,CAAK,GAAG,IAAA,CAAK,mBAAmB,CAAA;AACpD,IAAA,oBAAA,CAAqB,IAAA,CAAK,GAAG,IAAA,CAAK,oBAAoB,CAAA;AAAA,EACxD;AAEA,EAAA,OAAO;AAAA,IACL,UAAA,EAAY,MAAA,CAAO,IAAA,CAAK,aAAa,CAAA;AAAA,IACrC,WAAA,EAAa,MAAA,CAAO,MAAA,CAAO,aAAa,CAAA;AAAA,IACxC,mBAAA;AAAA,IACA,oBAAA;AAAA,IACA,eAAA,EAAiB,MAAA,CAAO,MAAA,CAAO,eAAe,CAAA;AAAA,IAC9C,YAAA,EAAc,MAAA,CAAO,IAAA,CAAK,eAAe;AAAA,GAC3C;AACF;AAEO,SAAS,4BAAA,GAAqD;AACnE,EAAA,OAAO;AAAA,IACL,YAAY,EAAC;AAAA,IACb,aAAa,EAAC;AAAA,IACd,qBAAqB,EAAC;AAAA,IACtB,sBAAsB,EAAC;AAAA,IACvB,iBAAiB,EAAC;AAAA,IAClB,cAAc;AAAC,GACjB;AACF;AAEO,SAAS,uBAAA,CAAwB;AAAA,EACtC,OAAA;AAAA,EACA,OAAA;AAAA,EACA;AACF,CAAA,EAIyB;AACvB,EAAA,MAAM,cAAA,GAAiB,mBAAA;AAAA,IACrB,OAAA;AAAA,IACA,KAAA,CAAM,cAAA;AAAA,IACN;AAAA,GACF;AACA,EAAA,MAAM,eAAA,GAAkB,mBAAA;AAAA,IACtB,OAAA;AAAA,IACA,KAAA,CAAM,eAAA;AAAA,IACN;AAAA,GACF;AACA,EAAA,MAAM,UAAA,GAAa,eAAA,CAAgB,OAAO,CAAA,CAAE,OAAA;AAE5C,EAAA,MAAM,eAAe,IAAA,CAAK,CAAC,cAAA,EAAgB,eAAA,EAAiB,UAAU,CAAC,CAAA;AAEvE,EAAA,MAAM,OAAA,GAAgC;AAAA,IACpC,UAAA,EAAY,CAAC,cAAc,CAAA;AAAA,IAC3B,WAAA,EAAa,CAAC,KAAA,CAAM,QAAQ,CAAA;AAAA,IAC5B,qBAAqB,EAAC;AAAA,IACtB,sBAAsB,EAAC;AAAA,IACvB,YAAA;AAAA,IACA,eAAA,EAAiB,MAAM,IAAA,CAAK,EAAE,QAAQ,YAAA,CAAa,MAAA,EAAO,EAAG,MAAM,OAAO;AAAA,GAC5E;AAEA,EAAA,IAAI,MAAM,mBAAA,EAAqB;AAC7B,IAAA,OAAA,CAAQ,mBAAA,CAAoB,KAAK,cAAc,CAAA;AAC/C,IAAA,OAAA,CAAQ,oBAAA,CAAqB,IAAA;AAAA,MAC3B,kBAAA,CAAmB;AAAA,QACjB,GAAA,EAAK,QAAA;AAAA,QACL,YAAA,EAAc,SAAA;AAAA,QACd,IAAA,EAAM,CAAC,KAAA,CAAM,OAAA,CAAQ,IAAe,UAAU;AAAA,OAC/C;AAAA,KACH;AAAA,EACF;AAEA,EAAA,OAAA,CAAQ,mBAAA,CAAoB,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ,EAAE,CAAA;AACjD,EAAA,OAAA,CAAQ,oBAAA,CAAqB,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ,IAAI,CAAA;AAEpD,EAAA,OAAO,OAAA;AACT;AAEA,SAAS,iBAAiB,cAAA,EAAiC;AACzD,EAAA,MAAM,eAAiD,EAAC;AACxD,EAAA,IAAI,KAAA,GAAQ,EAAA;AAEZ,EAAA,KAAA,MAAW,YAAY,cAAA,EAAgB;AACrC,IAAA,MAAM,MAAM,CAAA,EAAG,QAAA,CAAS,YAAY,CAAA,CAAA,EAAI,SAAS,WAAW,CAAA,CAAA;AAE5D,IAAA,IAAI,CAAC,YAAA,CAAa,GAAG,CAAA,EAAG;AACtB,MAAA,YAAA,CAAa,GAAG,CAAA,GAAI,EAAE,GAAG,QAAA,EAAS;AAAA,IACpC,CAAA,MAAO;AACL,MAAA,YAAA,CAAa,GAAG,CAAA,CAAE,MAAA,IAAU,QAAA,CAAS,MAAA;AAAA,IACvC;AAEA,IAAA,IAAI,QAAA,CAAS,iBAAiB,oBAAA,EAAsB;AAClD,MAAA,KAAA,IAAS,QAAA,CAAS,MAAA;AAAA,IACpB;AAAA,EACF;AAEA,EAAA,OAAO,EAAE,cAAA,EAAgB,MAAA,CAAO,MAAA,CAAO,YAAY,GAAG,KAAA,EAAM;AAC9D;AAEO,SAAS,6BAAA,CAA8B;AAAA,EAC5C;AACF,CAAA,EAEG;AACD,EAAA,MAAM,EAAE,iBAAA,EAAmB,iBAAA,EAAmB,iBAAA,EAAkB,GAAI,MAAA;AAEpE,EAAA,MAAM,YAAkC,EAAC;AACzC,EAAA,IAAI,KAAA,GAAQ,EAAA;AAEZ,EAAA,KAAA,MAAWA,WAAU,iBAAA,EAAmB;AACtC,IAAA,MAAM,EAAE,SAAA,EAAW,eAAA,EAAiB,OAAO,WAAA,EAAY,GACrD,0BAA0BA,OAAM,CAAA;AAClC,IAAA,SAAA,CAAU,IAAA,CAAK,GAAG,eAAe,CAAA;AACjC,IAAA,KAAA,IAAS,WAAA;AAAA,EACX;AAEA,EAAA,KAAA,MAAW,UAAU,iBAAA,EAAmB;AACtC,IAAA,MAAM,EAAE,SAAA,EAAW,eAAA,EAAiB,OAAO,WAAA,EAAY,GACrD,0BAA0B,MAAM,CAAA;AAClC,IAAA,SAAA,CAAU,IAAA,CAAK,GAAG,eAAe,CAAA;AACjC,IAAA,KAAA,IAAS,WAAA;AAAA,EACX;AAEA,EAAA,KAAA,MAAW,UAAU,iBAAA,EAAmB;AACtC,IAAA,MAAM,EAAE,SAAA,EAAW,eAAA,EAAiB,KAAA,EAAO,WAAA,KACzC,yBAAA,CAA0B,EAAE,MAAA,EAAQ,MAAA,EAAQ,CAAA;AAC9C,IAAA,SAAA,CAAU,IAAA,CAAK,GAAG,eAAe,CAAA;AACjC,IAAA,KAAA,IAAS,WAAA;AAAA,EACX;AAEA,EAAA,MAAM,EAAE,gBAAA,EAAkB,QAAA,EAAS,GACjC,8BAA8B,SAAS,CAAA;AAEzC,EAAA,OAAO,EAAE,SAAA,EAAW,KAAA,EAAO,gBAAA,EAAkB,QAAA,EAAS;AACxD;AAEO,SAAS,0BAA0B,MAAA,EAAmC;AAC3E,EAAA,MAAM,EAAE,oBAAA,EAAsB,YAAA,EAAa,GAAI,MAAA;AAC/C,EAAA,MAAM;AAAA,IACJ,iBAAiB,EAAC;AAAA,IAClB,KAAA,GAAQ,EAAA;AAAA,IACR,aAAA,GAAgB;AAAA,GAClB,GAAI,wBAAwB,EAAC;AAE7B,EAAA,MAAM,YAAkC,EAAC;AAEzC,EAAA,KAAA,MAAW,YAAY,cAAA,EAAgB;AACrC,IAAA,IAAI,QAAA,CAAS,iBAAiB,oBAAA,EAAsB;AAClD,MAAA,SAAA,CAAU,IAAA,CAAK;AAAA,QACb,MAAA,EAAQ,SAAA;AAAA,QACR,MAAA,EAAQ,CAAC,QAAA,CAAS,WAAA,EAAa,SAAS,MAAM;AAAA,OAC/C,CAAA;AAAA,IACH,CAAA,MAAO;AACL,MAAA,SAAA,CAAU,IAAA,CAAK;AAAA,QACb,MAAA,EAAQ,YAAA;AAAA,QACR,QAAQ,CAAC,QAAA,CAAS,cAAc,QAAA,CAAS,WAAA,EAAa,SAAS,MAAM;AAAA,OACtE,CAAA;AAAA,IACH;AAAA,EACF;AAEA,EAAA,IAAI,aAAA,EAAe;AACjB,IAAA,SAAA,CAAU,IAAA,CAAK;AAAA,MACb,MAAA,EAAQ,mBAAA;AAAA,MACR,MAAA,EAAQ;AAAA,QACN,aAAA,CAAc,mBAAA;AAAA,QACd,aAAA,CAAc,oBAAA;AAAA,QACd,aAAA,CAAc,YAAA;AAAA,QACd,aAAA,CAAc;AAAA;AAChB,KACD,CAAA;AAAA,EACH;AAEA,EAAA,SAAA,CAAU,IAAA,CAAK;AAAA,IACb,MAAA,EAAQ,aAAA;AAAA,IACR,MAAA,EAAQ,CAAC,YAAY;AAAA,GACtB,CAAA;AAED,EAAA,OAAO;AAAA,IACL,SAAA;AAAA,IACA;AAAA,GACF;AACF;AAEO,SAAS,0BAA0B,SAAA,EAAiC;AACzE,EAAA,MAAM,EAAE,aAAA,EAAe,MAAA,EAAQ,YAAA,EAAa,GAAI,SAAA;AAChD,EAAA,MAAM,EAAE,SAAQ,GAAI,YAAA;AACpB,EAAA,MAAM,iBAAA,GAAoB,WAAA,CAAY,OAAA,EAAS,YAAY,CAAA;AAE3D,EAAA,MAAM,YAAkC,EAAC;AAEzC,EAAA,IAAI,aAAA,CAAc,oBAAoB,EAAA,EAAI;AACxC,IAAA,SAAA,CAAU,IAAA,CAAK;AAAA,MACb,MAAA,EAAQ,SAAA;AAAA,MACR,MAAA,EAAQ,CAAC,iBAAA,EAAmB,aAAA,CAAc,iBAAiB;AAAA,KAC5D,CAAA;AAAA,EACH;AAEA,EAAA,SAAA,CAAU,IAAA,CAAK;AAAA,IACb,MAAA,EAAQ,aAAA;AAAA,IACR,MAAA,EAAQ;AAAA,MACN,aAAA,CAAc,QAAA;AAAA,MACd,aAAA,CAAc,YAAA;AAAA,MACd,aAAA,CAAc,eAAA;AAAA,MACd,aAAA,CAAc,YAAA;AAAA,MACd,aAAA,CAAc,eAAA;AAAA,MACd,EAAA;AAAA,MACA,aAAA,CAAc;AAAA;AAChB,GACD,CAAA;AAED,EAAA,OAAO;AAAA,IACL,SAAA;AAAA,IACA,OAAO,aAAA,CAAc;AAAA,GACvB;AACF;AAEO,SAAS,yBAAA,CAA0B;AAAA,EACxC;AACF,CAAA,EAEG;AACD,EAAA,MAAM,EAAE,UAAS,GAAI,MAAA;AAErB,EAAA,MAAM,YAAkC,EAAC;AAEzC,EAAA,SAAA,CAAU,IAAA,CAAK;AAAA,IACb,MAAA,EAAQ,aAAA;AAAA,IACR,MAAA,EAAQ,CAAC,QAAQ;AAAA,GAClB,CAAA;AAED,EAAA,OAAO;AAAA,IACL,SAAA;AAAA,IACA,KAAA,EAAO;AAAA,GACT;AACF;AAEO,SAAS,8BAA8B,SAAA,EAAiC;AAC7E,EAAA,MAAM,mBAAmB,SAAA,CAAU,GAAA;AAAA,IAAI,CAAC,SACtC,kBAAA,CAAmB;AAAA,MACjB,KAAK,IAAA,CAAK,cAAA;AAAA,MACV,cAAc,IAAA,CAAK,MAAA;AAAA,MACnB,MAAM,IAAA,CAAK;AAAA,KACZ;AAAA,GACH;AAEA,EAAA,MAAM,WAAW,kBAAA,CAAmB;AAAA,IAClC,GAAA,EAAK,iBAAA;AAAA,IACL,YAAA,EAAc,WAAA;AAAA,IACd,IAAA,EAAM,CAAC,gBAAgB;AAAA,GACxB,CAAA;AAED,EAAA,OAAO;AAAA,IACL,gBAAA;AAAA,IACA;AAAA,GACF;AACF;AAEO,SAAS,0BAAA,CACd,SAAA,GAA+B,EAAC,EACtB;AACV,EAAA,OAAO,SAAA,CAAU,MAAA,CAAO,OAAO,CAAA,CAAE,GAAA;AAAA,IAAI,CAAC,aACpC,kBAAA,CAAmB;AAAA,MACjB,KAAK,IAAA,CAAK,cAAA;AAAA,MACV,YAAA,EAAc,aAAA;AAAA,MACd,IAAA,EAAM,CAAC,QAAQ;AAAA,KAChB;AAAA,GACH;AACF;AAEO,SAAS,0BAAA,CAA2B;AAAA,EACzC,OAAA;AAAA,EACA,QAAA;AAAA,EACA,YAAA;AAAA,EACA,YAAA;AAAA,EACA,UAAA;AAAA,EACA,eAAA;AAAA,EACA,YAAA;AAAA,EACA,eAAA;AAAA,EACA;AACF,CAAA,EAUa;AACX,EAAA,MAAM,iBAAA,GAAoB,WAAA,CAAY,OAAA,EAAS,YAAY,CAAA;AAE3D,EAAA,MAAM,YAAkC,EAAC;AACzC,EAAA,IAAI,YAAA,IAAgB,MAAA,IAAa,YAAA,GAAe,CAAA,EAAG;AACjD,IAAA,SAAA,CAAU,IAAA,CAAK;AAAA,MACb,MAAA,EAAQ,SAAA;AAAA,MACR,MAAA,EAAQ,CAAC,iBAAA,EAAmB,YAAY;AAAA,KACzC,CAAA;AAAA,EACH;AAEA,EAAA,SAAA,CAAU,IAAA,CAAK;AAAA,IACb,MAAA,EAAQ,aAAA;AAAA,IACR,MAAA,EAAQ;AAAA,MACN,QAAA;AAAA,MACA,YAAA;AAAA,MACA,oBAAoB,MAAA,GAChB,sBAAA,CAAuB,iBAAiB,UAAA,EAAY,QAAA,IAAY,CAAC,CAAA,GACjE,EAAA;AAAA,MACJ,iBAAiB,MAAA,GACb,sBAAA,CAAuB,cAAc,UAAA,EAAY,QAAA,IAAY,CAAC,CAAA,GAC9D,EAAA;AAAA,MACJ,eAAA;AAAA,MACA,EAAA;AAAA,MACA;AAAA;AACF,GACD,CAAA;AAED,EAAA,OAAO,SAAA,CAAU,MAAA,CAAO,OAAO,CAAA,CAAE,GAAA;AAAA,IAAI,CAAC,SACpC,kBAAA,CAAmB;AAAA,MACjB,KAAK,IAAA,CAAK,cAAA;AAAA,MACV,cAAc,IAAA,CAAM,MAAA;AAAA,MACpB,MAAM,IAAA,CAAM;AAAA,KACb;AAAA,GACH;AACF;AAyBO,SAAS,4BAAA,CAA6B;AAAA,EAC3C,OAAA;AAAA,EACA,iBAAA;AAAA,EACA,EAAA;AAAA,EACA;AACF,CAAA,EAKa;AACX,EAAA,MAAM,SAAA,GAAY;AAAA,IAChB,GAAG,EAAA,CAAG,OAAA,CAAQ,CAAC,CAAA,KAAM;AACnB,MAAA,MAAM,eAAA,GAAkB,EAAE,mBAAA,KAAwB,oBAAA;AAElD,MAAA,MAAM,6BAAA,GAAgC,mBAAA;AAAA,QACpC,OAAA;AAAA,QACA,CAAA,CAAE,wBAAA;AAAA,QACF;AAAA,OACF;AAEA,MAAA,MAAM,mBAAA,GAAsB,iBAAA,CAAkB,CAAA,CAAE,SAAS,CAAA;AAEzD,MAAA,MAAM,kBAAkB,mBAAA,GACpB,oBAAA;AAAA,QACE,CAAA,CAAE,eAAA;AAAA,QACF,CAAA,CAAE,eAAA;AAAA,QACF,KAAA;AAAA,QACA,CAAA,CAAE;AAAA,UAEJ,CAAA,CAAE,eAAA;AAEN,MAAA,MAAM,eAAA,GAAkB,sBACpB,qBAAA,CAAsB,CAAA,CAAE,iBAAiB,CAAA,CAAE,YAAY,IACvD,CAAA,CAAE,YAAA;AACN,MAAA,MAAM,WAAA,GAAc;AAAA,QAClB,SAAA,EAAW;AAAA,UACT,oBAAA,EAAsB,WAAA;AAAA,UACtB,UAAU,CAAA,CAAE,OAAA;AAAA,UACZ,sBAAA,EAAwB,6BAAA;AAAA,UACxB,gBAAA,EAAkB,WAAA;AAAA,UAClB,QAAQ,CAAA,CAAE,aAAA;AAAA,UACV,UAAU,CAAA,CAAE,QAAA;AAAA,UACZ,aAAA,EAAe,CAAA,CAAE,aAAA,IAAiB,aAAA,IAAiB;AAAA,SACrD;AAAA,QACA,OAAA,EAAS;AAAA,UACP,cAAc,CAAA,CAAE,YAAA;AAAA,UAChB,8BAA8B,CAAA,CAAE,4BAAA;AAAA,UAChC,YAAA,EAAc,sBAAA;AAAA,YACZ,EAAE,YAAA,IAAgB,EAAA;AAAA,YAClB,EAAE,UAAA,CAAW;AAAA,WACf;AAAA,UACA,eAAA,EAAiB,sBAAA;AAAA,YACf,eAAA;AAAA,YACA,EAAE,UAAA,CAAW;AAAA,WACf;AAAA,UACA,cAAc,CAAA,CAAE,YAAA;AAAA,UAChB,gBAAA,EAAkB,EAAA;AAAA,UAClB,eAAA;AAAA,UACA,aAAA,EAAe;AAAA,SACjB;AAAA,QACA,WAAW,CAAA,CAAE,SAAA;AAAA,QACb,0BAA0B,CAAA,CAAE,wBAAA;AAAA,QAC5B,QAAQ,CAAA,CAAE,MAAA;AAAA,QACV,uBAAA,EAAyB,eAAA;AAAA,QACzB,YAAY,CAAA,CAAE,UAAA;AAAA,QACd,YAAA,EAAc,EAAE,YAAA,IAAgB,QAAA;AAAA,QAChC,QAAA,EAAU,CAAA,CAAE,QAAA,IAAY;AAAC,OAC3B;AAEA,MAAA,OAAO;AAAA,QACL,EAAE,QAAQ,SAAA,EAAW,MAAA,EAAQ,CAAC,iBAAA,EAAmB,CAAA,CAAE,YAAY,CAAA,EAAE;AAAA,QACjE;AAAA,UACE,MAAA,EAAQ,aAAA;AAAA,UACR,MAAA,EAAQ,CAAC,WAAW;AAAA;AACtB,OACF;AAAA,IACF,CAAC;AAAA,GACH;AAEA,EAAA,OAAO,SAAA,CAAU,MAAA,CAAO,OAAO,CAAA,CAAE,GAAA;AAAA,IAAI,CAAC,SACpC,kBAAA,CAAmB;AAAA,MACjB,KAAK,IAAA,CAAK,cAAA;AAAA,MACV,cAAc,IAAA,CAAM,MAAA;AAAA,MACpB,MAAM,IAAA,CAAM;AAAA,KACb;AAAA,GACH;AACF;AAEO,SAAS,wBACd,WAAA,EACA;AACA,EAAA,IAAI,CAAC,WAAA,EAAa;AAChB,IAAA,OAAO,CAAA;AAAA,EACT;AAEA,EAAA,OACE,YAAY,iBAAA,CAAkB,MAAA,GAC9B,YAAY,iBAAA,CAAkB,MAAA,GAC9B,YAAY,iBAAA,CAAkB,MAAA;AAElC;AAEO,SAAS,mBACd,WAAA,EACA;AACA,EAAA,IAAI,CAAC,WAAA,EAAa;AAChB,IAAA,OAAO,CAAA;AAAA,EACT;AAEA,EAAA,OAAO,WAAA,CAAY,iBAAA,CAAkB,MAAA,CAAO,CAAC,KAAK,EAAA,KAAO;AACvD,IAAA,OAAO,GAAA,GAAM,EAAA,CAAG,YAAA,CAAa,SAAA,CAAU,QAAA,CAAS,MAAA;AAAA,EAClD,GAAG,CAAC,CAAA;AACN;AAEO,SAAS,gBAAgB,WAAA,EAA8C;AAC5E,EAAA,IAAI,CAAC,WAAA,EAAa;AAChB,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,IAAI,uBAAA,CAAwB,WAAW,CAAA,KAAM,CAAA,EAAG;AAC9C,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,MAAM,aAAA,GAAgB,YAAY,iBAAA,CAAkB,IAAA;AAAA,IAClD,CAAC,CAAA,KACC,CAAA,CAAE,YAAA,CAAa,OAAA,CAAQ,iBAAiB,EAAA,IACxC,CAAA,CAAE,YAAA,CAAa,OAAA,CAAQ,4BAAA,KAAiC;AAAA,GAC5D;AAEA,EAAA,OAAO,aAAA;AACT;AAEO,SAAS,wBAAwB,WAAA,EAAkC;AACxE,EAAA,OAAO,YAAY,iBAAA,CAAkB,IAAA;AAAA,IACnC,CAAC,CAAA,KAAM,CAAA,CAAE,oBAAA,EAAsB;AAAA,GACjC;AACF;AAEO,SAAS,yBAAA,CACd,aACA,aAAA,EACA;AACA,EAAA,OAAO,YAAY,iBAAA,CAAkB,IAAA;AAAA,IACnC,CAAC,EAAA,KAAO,EAAA,CAAG,YAAA,CAAa,UAAU,QAAA,KAAa;AAAA,GACjD;AACF","file":"orderTransactions.js","sourcesContent":["import uniq from \"lodash/uniq\";\nimport { Address, encodeFunctionData, zeroAddress, zeroHash } from \"viem\";\n\nimport { abis } from \"abis\";\nimport ExchangeRouterAbi from \"abis/ExchangeRouter\";\nimport ERC20ABI from \"abis/Token\";\nimport {\n  ContractsChainId,\n  getExcessiveExecutionFee,\n  getHighExecutionFee,\n} from \"configs/chains\";\nimport { getContract } from \"configs/contracts\";\nimport {\n  convertTokenAddress,\n  getToken,\n  getWrappedToken,\n  NATIVE_TOKEN_ADDRESS,\n} from \"configs/tokens\";\nimport { DecreasePositionSwapType } from \"domain/decrease/types\";\nimport { ExecutionFee } from \"domain/executionFee/types\";\nimport { ExternalSwapQuote } from \"domain/externalSwap/types\";\nimport { OrderType } from \"domain/orders/types\";\nimport {\n  isIncreaseOrderType,\n  isMarketOrderType,\n  isSwapOrderType,\n} from \"domain/orders/utils\";\nimport { convertToContractPrice } from \"domain/pricing/contractPrice\";\nimport {\n  applySlippageToMinOut,\n  applySlippageToPrice,\n} from \"domain/pricing/slippage\";\nimport { ContractPrice } from \"domain/pricing/types\";\nimport { ERC20Address, TokensData } from \"domain/tokens/types\";\nimport { convertToUsd } from \"domain/tokens/utils\";\nimport { TwapOrderParams } from \"domain/twap/types\";\nimport { getTwapValidFromTime } from \"domain/twap/utils\";\nimport { createTwapUiFeeReceiver } from \"domain/uiFeeReceiver/uiFeeReceiver\";\nimport { expandDecimals, MaxUint256, USD_DECIMALS } from \"lib/numbers\";\nimport { getByKey } from \"lib/objects\";\n\nexport type ExchangeRouterCall = {\n  method: string;\n  params: any[];\n};\n\nexport type BatchOrderTxnParams = {\n  createOrderParams: CreateOrderTxnParams<any>[];\n  updateOrderParams: UpdateOrderTxnParams[];\n  cancelOrderParams: CancelOrderTxnParams[];\n};\n\nexport type CreateOrderTxnParams<\n  TParams extends\n    | SwapOrderParams\n    | IncreasePositionOrderParams\n    | DecreasePositionOrderParams\n> = {\n  params: TParams;\n  orderPayload: CreateOrderPayload;\n  tokenTransfersParams: TokenTransfersParams | undefined;\n};\n\nexport type UpdateOrderTxnParams = {\n  params: UpdateOrderParams;\n  updatePayload: UpdateOrderPayload;\n};\n\nexport type CancelOrderTxnParams = {\n  orderKey: string;\n};\n\nexport type CreateOrderPayload = {\n  addresses: {\n    receiver: string | undefined;\n    cancellationReceiver: string;\n    callbackContract: string;\n    uiFeeReceiver: string;\n    market: string;\n    initialCollateralToken: ERC20Address;\n    swapPath: string[];\n  };\n  numbers: {\n    sizeDeltaUsd: bigint;\n    /**\n     * For express orders initialCollateralDeltaAmount will be transfered from user wallet to order vault in relay router logic,\n     * for default orders - this field will be ignored in contracts and settled by actual value reveived in order vault\n     * */\n    initialCollateralDeltaAmount: bigint;\n    triggerPrice: ContractPrice | 0n;\n    acceptablePrice: ContractPrice | 0n;\n    executionFee: bigint;\n    callbackGasLimit: bigint;\n    minOutputAmount: bigint;\n    validFromTime: bigint;\n  };\n  orderType: OrderType;\n  decreasePositionSwapType: DecreasePositionSwapType;\n  isLong: boolean;\n  shouldUnwrapNativeToken: boolean;\n  autoCancel: boolean;\n  referralCode: string;\n  dataList: string[];\n};\n\nexport type UpdateOrderParams = {\n  chainId: ContractsChainId;\n  indexTokenAddress: string;\n  orderKey: string;\n  orderType: OrderType;\n  sizeDeltaUsd: bigint;\n  triggerPrice: bigint;\n  acceptablePrice: bigint;\n  minOutputAmount: bigint;\n  autoCancel: boolean;\n  validFromTime: bigint;\n  // used to top-up execution fee for frozen orders\n  executionFeeTopUp: bigint;\n};\n\nexport type UpdateOrderPayload = {\n  orderKey: string;\n  sizeDeltaUsd: bigint;\n  triggerPrice: ContractPrice;\n  acceptablePrice: ContractPrice;\n  minOutputAmount: bigint;\n  autoCancel: boolean;\n  validFromTime: bigint;\n  // used to top-up execution fee for frozen orders\n  executionFeeTopUp: bigint;\n};\n\nexport type TokenTransfersParams = {\n  // Whether the payment token is the chain's native token (e.g. ETH for Ethereum)\n  isNativePayment: boolean;\n  // Whether the receive token is the chain's native token (e.g. ETH for Ethereum)\n  isNativeReceive: boolean;\n  tokenTransfers: TokenTransfer[];\n  value: bigint;\n  payTokenAddress: string;\n  payTokenAmount: bigint;\n  initialCollateralTokenAddress: ERC20Address;\n  initialCollateralDeltaAmount: bigint;\n  minOutputAmount: bigint;\n  swapPath: string[];\n  externalCalls: ExternalCallsPayload | undefined;\n};\n\nexport type TokenTransfer = {\n  tokenAddress: string;\n  destination: string;\n  amount: bigint;\n};\n\nexport type ExternalCallsPayload = {\n  sendTokens: ERC20Address[];\n  sendAmounts: bigint[];\n  externalCallTargets: string[];\n  externalCallDataList: string[];\n  refundTokens: string[];\n  refundReceivers: string[];\n};\n\nexport type CommonOrderParams = {\n  chainId: ContractsChainId;\n  receiver: string | undefined;\n  executionFeeAmount: bigint;\n  executionGasLimit: bigint;\n  referralCode: string | undefined;\n  uiFeeReceiver: string | undefined;\n  allowedSlippage: number;\n  autoCancel: boolean;\n  validFromTime: bigint | undefined;\n};\n\nexport type PositionOrderParams = {\n  marketAddress: string;\n  indexTokenAddress: string;\n  isLong: boolean;\n  sizeDeltaUsd: bigint;\n  sizeDeltaInTokens: bigint;\n  acceptablePrice: bigint;\n  triggerPrice: bigint | undefined;\n};\n\nexport type SwapOrderParams = CommonOrderParams & {\n  // Token that the user pays with\n  payTokenAddress: string;\n  payTokenAmount: bigint;\n  // Token that the user receives\n  receiveTokenAddress: string;\n  swapPath: string[];\n  externalSwapQuote: ExternalSwapQuote | undefined;\n  minOutputAmount: bigint;\n  expectedOutputAmount?: bigint;\n  orderType: OrderType.MarketSwap | OrderType.LimitSwap;\n  triggerRatio: bigint | undefined;\n};\n\nexport type IncreasePositionOrderParams = CommonOrderParams &\n  PositionOrderParams & {\n    // Token that the user pays with\n    payTokenAddress: string;\n    payTokenAmount: bigint;\n    swapPath: string[];\n    collateralDeltaAmount: bigint;\n    // Target collateral for the position\n    collateralTokenAddress: string;\n    externalSwapQuote: ExternalSwapQuote | undefined;\n    orderType:\n      | OrderType.MarketIncrease\n      | OrderType.LimitIncrease\n      | OrderType.StopIncrease;\n  };\n\nexport type DecreasePositionOrderParams = CommonOrderParams &\n  PositionOrderParams & {\n    // Collateral of the position\n    collateralTokenAddress: string;\n    collateralDeltaAmount: bigint;\n    swapPath: string[];\n    externalSwapQuote: undefined;\n    // Token that the user receives\n    receiveTokenAddress: string;\n    minOutputUsd: bigint;\n    decreasePositionSwapType: DecreasePositionSwapType;\n    orderType:\n      | OrderType.MarketDecrease\n      | OrderType.LimitDecrease\n      | OrderType.StopLossDecrease;\n  };\n\nexport const EMPTY_BATCH_ORDER_PARAMS: BatchOrderTxnParams = {\n  createOrderParams: [],\n  updateOrderParams: [],\n  cancelOrderParams: [],\n};\n\nexport function buildSwapOrderPayload(\n  p: SwapOrderParams\n): CreateOrderTxnParams<SwapOrderParams> {\n  const tokenTransfersParams = buildTokenTransfersParamsForIncreaseOrSwap(p);\n\n  const orderPayload: CreateOrderPayload = {\n    addresses: {\n      receiver: p.receiver,\n      cancellationReceiver: zeroAddress,\n      callbackContract: zeroAddress,\n      uiFeeReceiver: p.uiFeeReceiver ?? zeroAddress,\n      market: zeroAddress,\n      initialCollateralToken:\n        tokenTransfersParams.initialCollateralTokenAddress,\n      swapPath: tokenTransfersParams.swapPath,\n    },\n    numbers: {\n      sizeDeltaUsd: 0n,\n      initialCollateralDeltaAmount:\n        tokenTransfersParams.initialCollateralDeltaAmount,\n      // triggerRatio of limit swaps is used in trade history\n      triggerPrice: (p.triggerRatio as ContractPrice) ?? 0n,\n      acceptablePrice: 0n,\n      executionFee: p.executionFeeAmount,\n      callbackGasLimit: 0n,\n      minOutputAmount: applySlippageToMinOut(\n        p.allowedSlippage,\n        tokenTransfersParams.minOutputAmount\n      ),\n      validFromTime: p.validFromTime ?? 0n,\n    },\n    orderType: p.orderType,\n    decreasePositionSwapType: DecreasePositionSwapType.NoSwap,\n    isLong: false,\n    shouldUnwrapNativeToken:\n      tokenTransfersParams.isNativePayment ||\n      tokenTransfersParams.isNativeReceive,\n    autoCancel: p.autoCancel,\n    referralCode: p.referralCode ?? zeroHash,\n    dataList: [],\n  };\n\n  return {\n    params: p,\n    orderPayload,\n    tokenTransfersParams,\n  };\n}\n\nexport function buildIncreaseOrderPayload(\n  p: IncreasePositionOrderParams\n): CreateOrderTxnParams<IncreasePositionOrderParams> {\n  const tokenTransfersParams = buildTokenTransfersParamsForIncreaseOrSwap({\n    ...p,\n    minOutputAmount: 0n,\n    receiveTokenAddress: undefined,\n  });\n\n  const indexToken = getToken(p.chainId, p.indexTokenAddress);\n\n  let acceptablePrice: ContractPrice;\n  if (p.acceptablePrice === MaxUint256) {\n    acceptablePrice = MaxUint256 as ContractPrice;\n  } else {\n    acceptablePrice = convertToContractPrice(\n      applySlippageToPrice(\n        p.allowedSlippage,\n        p.acceptablePrice,\n        true,\n        p.isLong\n      ),\n      indexToken.decimals\n    );\n  }\n\n  let triggerPrice: ContractPrice;\n  if (p.triggerPrice === MaxUint256) {\n    triggerPrice = MaxUint256 as ContractPrice;\n  } else {\n    triggerPrice = convertToContractPrice(\n      p.triggerPrice ?? 0n,\n      indexToken.decimals\n    );\n  }\n\n  const orderPayload: CreateOrderPayload = {\n    addresses: {\n      receiver: p.receiver,\n      cancellationReceiver: zeroAddress,\n      callbackContract: zeroAddress,\n      uiFeeReceiver: p.uiFeeReceiver ?? zeroAddress,\n      market: p.marketAddress,\n      initialCollateralToken:\n        tokenTransfersParams.initialCollateralTokenAddress,\n      swapPath: tokenTransfersParams.swapPath,\n    },\n    numbers: {\n      sizeDeltaUsd: p.sizeDeltaUsd,\n      initialCollateralDeltaAmount:\n        tokenTransfersParams.initialCollateralDeltaAmount,\n      triggerPrice,\n      acceptablePrice,\n      executionFee: p.executionFeeAmount,\n      callbackGasLimit: 0n,\n      minOutputAmount: applySlippageToMinOut(\n        p.allowedSlippage,\n        tokenTransfersParams.minOutputAmount\n      ),\n      validFromTime: p.validFromTime ?? 0n,\n    },\n    orderType: p.orderType,\n    decreasePositionSwapType: DecreasePositionSwapType.NoSwap,\n    isLong: p.isLong,\n    shouldUnwrapNativeToken: tokenTransfersParams.isNativePayment,\n    autoCancel: p.autoCancel,\n    referralCode: p.referralCode ?? zeroHash,\n    dataList: [],\n  };\n\n  return {\n    params: p,\n    orderPayload,\n    tokenTransfersParams,\n  };\n}\n\nexport function buildDecreaseOrderPayload(\n  p: DecreasePositionOrderParams\n): CreateOrderTxnParams<DecreasePositionOrderParams> {\n  const indexToken = getToken(p.chainId, p.indexTokenAddress);\n  const tokenTransfersParams = buildTokenTransfersParamsForDecrease(p);\n\n  let acceptablePrice: ContractPrice;\n  if (p.acceptablePrice === MaxUint256) {\n    acceptablePrice = MaxUint256 as ContractPrice;\n  } else {\n    acceptablePrice = convertToContractPrice(\n      applySlippageToPrice(\n        p.allowedSlippage,\n        p.acceptablePrice,\n        false,\n        p.isLong\n      ),\n      indexToken.decimals\n    );\n  }\n\n  let triggerPrice: ContractPrice;\n  if (p.triggerPrice === MaxUint256) {\n    triggerPrice = MaxUint256 as ContractPrice;\n  } else {\n    triggerPrice = convertToContractPrice(\n      p.triggerPrice ?? 0n,\n      indexToken.decimals\n    );\n  }\n\n  const orderPayload: CreateOrderPayload = {\n    addresses: {\n      receiver: p.receiver,\n      cancellationReceiver: zeroAddress,\n      callbackContract: zeroAddress,\n      uiFeeReceiver: p.uiFeeReceiver ?? zeroAddress,\n      market: p.marketAddress,\n      initialCollateralToken:\n        tokenTransfersParams.initialCollateralTokenAddress,\n      swapPath: tokenTransfersParams.swapPath,\n    },\n    numbers: {\n      sizeDeltaUsd: p.sizeDeltaUsd,\n      initialCollateralDeltaAmount:\n        tokenTransfersParams.initialCollateralDeltaAmount,\n      triggerPrice,\n      acceptablePrice,\n      executionFee: p.executionFeeAmount,\n      callbackGasLimit: 0n,\n      minOutputAmount: applySlippageToMinOut(\n        p.allowedSlippage,\n        tokenTransfersParams.minOutputAmount\n      ),\n      validFromTime: p.validFromTime ?? 0n,\n    },\n    orderType: p.orderType,\n    decreasePositionSwapType: p.decreasePositionSwapType,\n    isLong: p.isLong,\n    shouldUnwrapNativeToken: p.receiveTokenAddress === NATIVE_TOKEN_ADDRESS,\n    autoCancel: p.autoCancel,\n    referralCode: p.referralCode ?? zeroHash,\n    dataList: [],\n  };\n\n  return {\n    params: p,\n    orderPayload,\n    tokenTransfersParams,\n  };\n}\n\nexport function buildTwapOrdersPayloads<\n  T extends\n    | SwapOrderParams\n    | IncreasePositionOrderParams\n    | DecreasePositionOrderParams\n>(p: T, twapParams: TwapOrderParams): CreateOrderTxnParams<T>[] {\n  const uiFeeReceiver = createTwapUiFeeReceiver({\n    numberOfParts: twapParams.numberOfParts,\n  });\n\n  if (isSwapOrderType(p.orderType)) {\n    return Array.from({ length: twapParams.numberOfParts }, (_, i) => {\n      const params = p as SwapOrderParams;\n\n      return buildSwapOrderPayload({\n        chainId: params.chainId,\n        receiver: params.receiver,\n        executionGasLimit: params.executionGasLimit,\n        payTokenAddress: params.payTokenAddress,\n        receiveTokenAddress: params.receiveTokenAddress,\n        swapPath: params.swapPath,\n        externalSwapQuote: undefined,\n        minOutputAmount: 0n,\n        triggerRatio: params.triggerRatio,\n        referralCode: params.referralCode,\n        autoCancel: params.autoCancel,\n        allowedSlippage: 0,\n        ...(params.expectedOutputAmount !== undefined && {\n          expectedOutputAmount:\n            params.expectedOutputAmount / BigInt(twapParams.numberOfParts),\n        }),\n        payTokenAmount:\n          params.payTokenAmount / BigInt(twapParams.numberOfParts),\n        executionFeeAmount:\n          params.executionFeeAmount / BigInt(twapParams.numberOfParts),\n        validFromTime: getTwapValidFromTime(\n          twapParams.duration,\n          twapParams.numberOfParts,\n          i\n        ),\n        orderType: OrderType.LimitSwap,\n        uiFeeReceiver,\n      }) as CreateOrderTxnParams<T>;\n    });\n  }\n\n  if (isIncreaseOrderType(p.orderType)) {\n    return Array.from({ length: twapParams.numberOfParts }, (_, i) => {\n      const params = p as IncreasePositionOrderParams;\n\n      const acceptablePrice = params.isLong ? MaxUint256 : 0n;\n      const triggerPrice = acceptablePrice;\n\n      return buildIncreaseOrderPayload({\n        chainId: params.chainId,\n        receiver: params.receiver,\n        executionGasLimit: params.executionGasLimit,\n        referralCode: params.referralCode,\n        autoCancel: params.autoCancel,\n        swapPath: params.swapPath,\n        externalSwapQuote: undefined,\n        marketAddress: params.marketAddress,\n        indexTokenAddress: params.indexTokenAddress,\n        isLong: params.isLong,\n        sizeDeltaUsd: params.sizeDeltaUsd / BigInt(twapParams.numberOfParts),\n        sizeDeltaInTokens:\n          params.sizeDeltaInTokens / BigInt(twapParams.numberOfParts),\n        payTokenAddress: params.payTokenAddress,\n        allowedSlippage: 0,\n        payTokenAmount:\n          params.payTokenAmount / BigInt(twapParams.numberOfParts),\n        collateralTokenAddress: params.collateralTokenAddress,\n        collateralDeltaAmount:\n          params.collateralDeltaAmount / BigInt(twapParams.numberOfParts),\n        executionFeeAmount:\n          params.executionFeeAmount / BigInt(twapParams.numberOfParts),\n        validFromTime: getTwapValidFromTime(\n          twapParams.duration,\n          twapParams.numberOfParts,\n          i\n        ),\n        orderType: OrderType.LimitIncrease,\n        acceptablePrice,\n        triggerPrice,\n        uiFeeReceiver,\n      }) as CreateOrderTxnParams<T>;\n    });\n  }\n\n  return Array.from({ length: twapParams.numberOfParts }, (_, i) => {\n    const params = p as DecreasePositionOrderParams;\n\n    const acceptablePrice = !params.isLong ? MaxUint256 : 0n;\n    const triggerPrice = acceptablePrice;\n\n    return buildDecreaseOrderPayload({\n      chainId: params.chainId,\n      receiver: params.receiver,\n      executionGasLimit: params.executionGasLimit,\n      referralCode: params.referralCode,\n      autoCancel: params.autoCancel,\n      swapPath: params.swapPath,\n      externalSwapQuote: undefined,\n      marketAddress: params.marketAddress,\n      indexTokenAddress: params.indexTokenAddress,\n      isLong: params.isLong,\n      collateralTokenAddress: params.collateralTokenAddress,\n      collateralDeltaAmount:\n        params.collateralDeltaAmount / BigInt(twapParams.numberOfParts),\n      sizeDeltaUsd: params.sizeDeltaUsd / BigInt(twapParams.numberOfParts),\n      sizeDeltaInTokens:\n        params.sizeDeltaInTokens / BigInt(twapParams.numberOfParts),\n      executionFeeAmount:\n        params.executionFeeAmount / BigInt(twapParams.numberOfParts),\n      validFromTime: getTwapValidFromTime(\n        twapParams.duration,\n        twapParams.numberOfParts,\n        i\n      ),\n      orderType: OrderType.LimitDecrease,\n      acceptablePrice,\n      triggerPrice,\n      allowedSlippage: 0,\n      uiFeeReceiver,\n      minOutputUsd: params.minOutputUsd / BigInt(twapParams.numberOfParts),\n      receiveTokenAddress: params.receiveTokenAddress,\n      decreasePositionSwapType: params.decreasePositionSwapType,\n    }) as CreateOrderTxnParams<T>;\n  });\n}\n\nexport function getIsTwapOrderPayload(p: CreateOrderPayload) {\n  return p.numbers.validFromTime !== 0n;\n}\n\nexport function buildUpdateOrderPayload(\n  p: UpdateOrderParams\n): UpdateOrderTxnParams {\n  const indexToken = getToken(p.chainId, p.indexTokenAddress);\n\n  return {\n    params: p,\n    updatePayload: {\n      orderKey: p.orderKey,\n      sizeDeltaUsd: p.sizeDeltaUsd,\n      triggerPrice: isSwapOrderType(p.orderType)\n        ? (p.triggerPrice as ContractPrice)\n        : convertToContractPrice(p.triggerPrice, indexToken.decimals),\n      acceptablePrice: convertToContractPrice(\n        p.acceptablePrice,\n        indexToken.decimals\n      ),\n      minOutputAmount: p.minOutputAmount,\n      autoCancel: p.autoCancel,\n      validFromTime: 0n,\n      executionFeeTopUp: p.executionFeeTopUp,\n    },\n  };\n}\n\nexport function getBatchTotalExecutionFee({\n  batchParams: { createOrderParams, updateOrderParams },\n  tokensData,\n  chainId,\n}: {\n  batchParams: BatchOrderTxnParams;\n  tokensData: TokensData;\n  chainId: number;\n}): ExecutionFee | undefined {\n  let feeTokenAmount = 0n;\n  let gasLimit = 0n;\n\n  const wnt = getByKey(tokensData, getWrappedToken(chainId).address);\n\n  if (!wnt) {\n    return undefined;\n  }\n\n  for (const co of createOrderParams) {\n    feeTokenAmount += co.orderPayload.numbers.executionFee;\n    gasLimit += co.params.executionGasLimit;\n  }\n\n  for (const uo of updateOrderParams) {\n    feeTokenAmount += uo.updatePayload.executionFeeTopUp;\n  }\n\n  const feeUsd = convertToUsd(\n    feeTokenAmount,\n    wnt.decimals,\n    wnt.prices.maxPrice\n  )!;\n  const isFeeHigh =\n    feeUsd > expandDecimals(getHighExecutionFee(chainId), USD_DECIMALS);\n  const isFeeVeryHigh =\n    feeUsd > expandDecimals(getExcessiveExecutionFee(chainId), USD_DECIMALS);\n\n  return {\n    feeTokenAmount,\n    gasLimit,\n    feeUsd,\n    feeToken: wnt,\n    isFeeHigh,\n    isFeeVeryHigh,\n  };\n}\n\nexport function getBatchTotalPayCollateralAmount(\n  batchParams: BatchOrderTxnParams\n) {\n  const payAmounts: { [tokenAddress: string]: bigint } = {};\n\n  for (const co of batchParams.createOrderParams) {\n    const payTokenAddress = co.tokenTransfersParams?.payTokenAddress;\n    const payTokenAmount = co.tokenTransfersParams?.payTokenAmount;\n\n    if (payTokenAddress && payTokenAmount !== undefined) {\n      payAmounts[payTokenAddress] =\n        (payAmounts[payTokenAddress] ?? 0n) + payTokenAmount;\n    }\n  }\n\n  return payAmounts;\n}\n\nexport function getBatchExternalSwapGasLimit(batchParams: BatchOrderTxnParams) {\n  return batchParams.createOrderParams.reduce((acc, co) => {\n    const externalSwapQuote = (\n      co.params as IncreasePositionOrderParams | SwapOrderParams\n    ).externalSwapQuote;\n\n    if (externalSwapQuote) {\n      return acc + externalSwapQuote.txnData.estimatedGas;\n    }\n\n    return acc;\n  }, 0n);\n}\n\nexport function buildTokenTransfersParamsForDecrease({\n  chainId,\n  executionFeeAmount,\n  collateralTokenAddress,\n  collateralDeltaAmount,\n  swapPath,\n  minOutputUsd,\n  receiveTokenAddress,\n}: {\n  chainId: ContractsChainId;\n  executionFeeAmount: bigint;\n  collateralTokenAddress: string;\n  collateralDeltaAmount: bigint;\n  receiveTokenAddress: string;\n  swapPath: string[];\n  minOutputUsd: bigint;\n}): TokenTransfersParams {\n  const orderVaultAddress = getContract(chainId, \"OrderVault\");\n\n  const { tokenTransfers, value } = combineTransfers([\n    {\n      tokenAddress: NATIVE_TOKEN_ADDRESS,\n      destination: orderVaultAddress,\n      amount: executionFeeAmount,\n    },\n  ]);\n\n  return {\n    isNativePayment: false,\n    isNativeReceive: receiveTokenAddress === NATIVE_TOKEN_ADDRESS,\n    initialCollateralTokenAddress: convertTokenAddress(\n      chainId,\n      collateralTokenAddress,\n      \"wrapped\"\n    ),\n    initialCollateralDeltaAmount: collateralDeltaAmount,\n    tokenTransfers,\n    payTokenAddress: zeroAddress,\n    payTokenAmount: 0n,\n    minOutputAmount: minOutputUsd,\n    swapPath,\n    value,\n    externalCalls: undefined,\n  };\n}\n\nexport function buildTokenTransfersParamsForIncreaseOrSwap({\n  chainId,\n  receiver,\n  payTokenAddress,\n  payTokenAmount,\n  receiveTokenAddress,\n  executionFeeAmount,\n  externalSwapQuote,\n  minOutputAmount,\n  swapPath,\n}: {\n  chainId: ContractsChainId;\n  receiver: string | undefined;\n  payTokenAddress: string;\n  payTokenAmount: bigint;\n  receiveTokenAddress: string | undefined;\n  executionFeeAmount: bigint;\n  externalSwapQuote: ExternalSwapQuote | undefined;\n  minOutputAmount: bigint;\n  swapPath: string[];\n}): TokenTransfersParams {\n  const isNativePayment = payTokenAddress === NATIVE_TOKEN_ADDRESS;\n  const isNativeReceive = receiveTokenAddress === NATIVE_TOKEN_ADDRESS;\n  const orderVaultAddress = getContract(chainId, \"OrderVault\");\n  const externalHandlerAddress = getContract(chainId, \"ExternalHandler\");\n\n  let finalPayTokenAmount = payTokenAmount;\n\n  const { tokenTransfers, value } = combineTransfers([\n    {\n      tokenAddress: NATIVE_TOKEN_ADDRESS,\n      destination: orderVaultAddress,\n      amount: executionFeeAmount,\n    },\n    {\n      tokenAddress: payTokenAddress,\n      destination: externalSwapQuote\n        ? externalHandlerAddress\n        : orderVaultAddress,\n      amount: payTokenAmount,\n    },\n  ]);\n\n  let initialCollateralTokenAddress = convertTokenAddress(\n    chainId,\n    payTokenAddress,\n    \"wrapped\"\n  );\n  let initialCollateralDeltaAmount = payTokenAmount;\n  let externalCalls: ExternalCallsPayload | undefined;\n\n  if (externalSwapQuote && receiver) {\n    /**\n     * External swap will be executed before order creation logic,\n     * so the final order has no swap parameters and must treat the outToken address as an initial collateral\n     * */\n    initialCollateralTokenAddress = convertTokenAddress(\n      chainId,\n      externalSwapQuote.outTokenAddress,\n      \"wrapped\"\n    );\n    initialCollateralDeltaAmount = 0n;\n    externalCalls = getExternalCallsPayload({\n      chainId,\n      account: receiver,\n      quote: externalSwapQuote,\n    });\n    finalPayTokenAmount = externalSwapQuote.amountIn;\n  }\n\n  return {\n    isNativePayment,\n    isNativeReceive,\n    initialCollateralTokenAddress,\n    initialCollateralDeltaAmount,\n    tokenTransfers,\n    payTokenAddress,\n    payTokenAmount: finalPayTokenAmount,\n    minOutputAmount,\n    swapPath,\n    value,\n    externalCalls,\n  };\n}\n\nexport function getBatchExternalCalls(\n  batchParams: BatchOrderTxnParams\n): ExternalCallsPayload {\n  const externalCalls: ExternalCallsPayload[] = [];\n\n  for (const createOrderParams of batchParams.createOrderParams) {\n    if (createOrderParams.tokenTransfersParams?.externalCalls) {\n      externalCalls.push(createOrderParams.tokenTransfersParams.externalCalls);\n    }\n  }\n\n  return combineExternalCalls(externalCalls);\n}\n\nexport function combineExternalCalls(\n  externalCalls: ExternalCallsPayload[]\n): ExternalCallsPayload {\n  const sendTokensMap: { [tokenAddress: string]: bigint } = {};\n  const refundTokensMap: { [tokenAddress: string]: string } = {};\n  const externalCallTargets: string[] = [];\n  const externalCallDataList: string[] = [];\n\n  for (const call of externalCalls) {\n    for (const [index, tokenAddress] of call.sendTokens.entries()) {\n      sendTokensMap[tokenAddress] =\n        (sendTokensMap[tokenAddress] ?? 0n) + call.sendAmounts[index];\n    }\n\n    for (const [index, tokenAddress] of call.refundTokens.entries()) {\n      refundTokensMap[tokenAddress] = call.refundReceivers[index];\n    }\n\n    externalCallTargets.push(...call.externalCallTargets);\n    externalCallDataList.push(...call.externalCallDataList);\n  }\n\n  return {\n    sendTokens: Object.keys(sendTokensMap) as ERC20Address[],\n    sendAmounts: Object.values(sendTokensMap),\n    externalCallTargets,\n    externalCallDataList,\n    refundReceivers: Object.values(refundTokensMap),\n    refundTokens: Object.keys(refundTokensMap),\n  };\n}\n\nexport function getEmptyExternalCallsPayload(): ExternalCallsPayload {\n  return {\n    sendTokens: [],\n    sendAmounts: [],\n    externalCallTargets: [],\n    externalCallDataList: [],\n    refundReceivers: [],\n    refundTokens: [],\n  };\n}\n\nexport function getExternalCallsPayload({\n  chainId,\n  account,\n  quote,\n}: {\n  chainId: number;\n  account: string;\n  quote: ExternalSwapQuote;\n}): ExternalCallsPayload {\n  const inTokenAddress = convertTokenAddress(\n    chainId,\n    quote.inTokenAddress,\n    \"wrapped\"\n  );\n  const outTokenAddress = convertTokenAddress(\n    chainId,\n    quote.outTokenAddress,\n    \"wrapped\"\n  );\n  const wntAddress = getWrappedToken(chainId).address;\n\n  const refundTokens = uniq([inTokenAddress, outTokenAddress, wntAddress]);\n\n  const payload: ExternalCallsPayload = {\n    sendTokens: [inTokenAddress],\n    sendAmounts: [quote.amountIn],\n    externalCallTargets: [],\n    externalCallDataList: [],\n    refundTokens,\n    refundReceivers: Array.from({ length: refundTokens.length }, () => account),\n  };\n\n  if (quote.needSpenderApproval) {\n    payload.externalCallTargets.push(inTokenAddress);\n    payload.externalCallDataList.push(\n      encodeFunctionData({\n        abi: ERC20ABI,\n        functionName: \"approve\",\n        args: [quote.txnData.to as Address, MaxUint256],\n      })\n    );\n  }\n\n  payload.externalCallTargets.push(quote.txnData.to);\n  payload.externalCallDataList.push(quote.txnData.data);\n\n  return payload;\n}\n\nfunction combineTransfers(tokenTransfers: TokenTransfer[]) {\n  const transfersMap: { [key: string]: TokenTransfer } = {};\n  let value = 0n;\n\n  for (const transfer of tokenTransfers) {\n    const key = `${transfer.tokenAddress}:${transfer.destination}`;\n\n    if (!transfersMap[key]) {\n      transfersMap[key] = { ...transfer };\n    } else {\n      transfersMap[key].amount += transfer.amount;\n    }\n\n    if (transfer.tokenAddress === NATIVE_TOKEN_ADDRESS) {\n      value += transfer.amount;\n    }\n  }\n\n  return { tokenTransfers: Object.values(transfersMap), value };\n}\n\nexport function getBatchOrderMulticallPayload({\n  params,\n}: {\n  params: BatchOrderTxnParams;\n}) {\n  const { createOrderParams, updateOrderParams, cancelOrderParams } = params;\n\n  const multicall: ExchangeRouterCall[] = [];\n  let value = 0n;\n\n  for (const params of createOrderParams) {\n    const { multicall: createMulticall, value: createValue } =\n      buildCreateOrderMulticall(params);\n    multicall.push(...createMulticall);\n    value += createValue;\n  }\n\n  for (const update of updateOrderParams) {\n    const { multicall: updateMulticall, value: updateValue } =\n      buildUpdateOrderMulticall(update);\n    multicall.push(...updateMulticall);\n    value += updateValue;\n  }\n\n  for (const cancel of cancelOrderParams) {\n    const { multicall: cancelMulticall, value: cancelValue } =\n      buildCancelOrderMulticall({ params: cancel });\n    multicall.push(...cancelMulticall);\n    value += cancelValue;\n  }\n\n  const { encodedMulticall, callData } =\n    encodeExchangeRouterMulticall(multicall);\n\n  return { multicall, value, encodedMulticall, callData };\n}\n\nexport function buildCreateOrderMulticall(params: CreateOrderTxnParams<any>) {\n  const { tokenTransfersParams, orderPayload } = params;\n  const {\n    tokenTransfers = [],\n    value = 0n,\n    externalCalls = undefined,\n  } = tokenTransfersParams ?? {};\n\n  const multicall: ExchangeRouterCall[] = [];\n\n  for (const transfer of tokenTransfers) {\n    if (transfer.tokenAddress === NATIVE_TOKEN_ADDRESS) {\n      multicall.push({\n        method: \"sendWnt\",\n        params: [transfer.destination, transfer.amount],\n      });\n    } else {\n      multicall.push({\n        method: \"sendTokens\",\n        params: [transfer.tokenAddress, transfer.destination, transfer.amount],\n      });\n    }\n  }\n\n  if (externalCalls) {\n    multicall.push({\n      method: \"makeExternalCalls\",\n      params: [\n        externalCalls.externalCallTargets,\n        externalCalls.externalCallDataList,\n        externalCalls.refundTokens,\n        externalCalls.refundReceivers,\n      ],\n    });\n  }\n\n  multicall.push({\n    method: \"createOrder\",\n    params: [orderPayload],\n  });\n\n  return {\n    multicall,\n    value,\n  };\n}\n\nexport function buildUpdateOrderMulticall(updateTxn: UpdateOrderTxnParams) {\n  const { updatePayload, params: updateParams } = updateTxn;\n  const { chainId } = updateParams;\n  const orderVaultAddress = getContract(chainId, \"OrderVault\");\n\n  const multicall: ExchangeRouterCall[] = [];\n\n  if (updatePayload.executionFeeTopUp > 0n) {\n    multicall.push({\n      method: \"sendWnt\",\n      params: [orderVaultAddress, updatePayload.executionFeeTopUp],\n    });\n  }\n\n  multicall.push({\n    method: \"updateOrder\",\n    params: [\n      updatePayload.orderKey,\n      updatePayload.sizeDeltaUsd,\n      updatePayload.acceptablePrice,\n      updatePayload.triggerPrice,\n      updatePayload.minOutputAmount,\n      0n,\n      updatePayload.autoCancel,\n    ],\n  });\n\n  return {\n    multicall,\n    value: updatePayload.executionFeeTopUp,\n  };\n}\n\nexport function buildCancelOrderMulticall({\n  params,\n}: {\n  params: CancelOrderTxnParams;\n}) {\n  const { orderKey } = params;\n\n  const multicall: ExchangeRouterCall[] = [];\n\n  multicall.push({\n    method: \"cancelOrder\",\n    params: [orderKey],\n  });\n\n  return {\n    multicall,\n    value: 0n,\n  };\n}\n\nexport function encodeExchangeRouterMulticall(multicall: ExchangeRouterCall[]) {\n  const encodedMulticall = multicall.map((call) =>\n    encodeFunctionData({\n      abi: abis.ExchangeRouter,\n      functionName: call.method as any,\n      args: call.params as any,\n    })\n  );\n\n  const callData = encodeFunctionData({\n    abi: ExchangeRouterAbi,\n    functionName: \"multicall\",\n    args: [encodedMulticall],\n  });\n\n  return {\n    encodedMulticall,\n    callData,\n  };\n}\n\nexport function createCancelEncodedPayload(\n  orderKeys: (string | null)[] = []\n): string[] {\n  return orderKeys.filter(Boolean).map((orderKey) =>\n    encodeFunctionData({\n      abi: abis.ExchangeRouter as any,\n      functionName: \"cancelOrder\",\n      args: [orderKey],\n    })\n  );\n}\n\nexport function createUpdateEncodedPayload({\n  chainId,\n  orderKey,\n  sizeDeltaUsd,\n  executionFee,\n  indexToken,\n  acceptablePrice,\n  triggerPrice,\n  minOutputAmount,\n  autoCancel,\n}: {\n  chainId: ContractsChainId;\n  orderKey: string;\n  sizeDeltaUsd: bigint;\n  executionFee?: bigint;\n  indexToken?: { decimals: number };\n  acceptablePrice: bigint;\n  triggerPrice: bigint;\n  minOutputAmount: bigint;\n  autoCancel: boolean;\n}): string[] {\n  const orderVaultAddress = getContract(chainId, \"OrderVault\");\n\n  const multicall: ExchangeRouterCall[] = [];\n  if (executionFee != undefined && executionFee > 0) {\n    multicall.push({\n      method: \"sendWnt\",\n      params: [orderVaultAddress, executionFee],\n    });\n  }\n\n  multicall.push({\n    method: \"updateOrder\",\n    params: [\n      orderKey,\n      sizeDeltaUsd,\n      acceptablePrice !== undefined\n        ? convertToContractPrice(acceptablePrice, indexToken?.decimals || 0)\n        : 0n,\n      triggerPrice !== undefined\n        ? convertToContractPrice(triggerPrice, indexToken?.decimals || 0)\n        : 0n,\n      minOutputAmount,\n      0n,\n      autoCancel,\n    ],\n  });\n\n  return multicall.filter(Boolean).map((call) =>\n    encodeFunctionData({\n      abi: abis.ExchangeRouter as any,\n      functionName: call!.method as any,\n      args: call!.params,\n    })\n  );\n}\n\nexport type DecreaseOrderParams = {\n  account: string;\n  marketAddress: string;\n  initialCollateralAddress: string;\n  initialCollateralDeltaAmount: bigint;\n  swapPath: string[];\n  receiveTokenAddress: string;\n  sizeDeltaUsd: bigint;\n  acceptablePrice: bigint;\n  triggerPrice: bigint | undefined;\n  minOutputUsd: bigint;\n  isLong: boolean;\n  decreasePositionSwapType: DecreasePositionSwapType;\n  orderType: OrderType;\n  executionFee: bigint;\n  allowedSlippage: number;\n  referralCode?: string;\n  indexToken: { decimals: number; address: string };\n  autoCancel: boolean;\n  dataList?: string[];\n  uiFeeReceiver?: string;\n};\n\nexport function createDecreaseEncodedPayload({\n  chainId,\n  orderVaultAddress,\n  ps,\n  uiFeeReceiver,\n}: {\n  chainId: ContractsChainId;\n  orderVaultAddress: string;\n  ps: DecreaseOrderParams[];\n  uiFeeReceiver?: string;\n}): string[] {\n  const multicall = [\n    ...ps.flatMap((p) => {\n      const isNativeReceive = p.receiveTokenAddress === NATIVE_TOKEN_ADDRESS;\n\n      const initialCollateralTokenAddress = convertTokenAddress(\n        chainId,\n        p.initialCollateralAddress,\n        \"wrapped\"\n      );\n\n      const shouldApplySlippage = isMarketOrderType(p.orderType);\n\n      const acceptablePrice = shouldApplySlippage\n        ? applySlippageToPrice(\n            p.allowedSlippage,\n            p.acceptablePrice,\n            false,\n            p.isLong\n          )\n        : p.acceptablePrice;\n\n      const minOutputAmount = shouldApplySlippage\n        ? applySlippageToMinOut(p.allowedSlippage, p.minOutputUsd)\n        : p.minOutputUsd;\n      const orderParams = {\n        addresses: {\n          cancellationReceiver: zeroAddress,\n          receiver: p.account,\n          initialCollateralToken: initialCollateralTokenAddress,\n          callbackContract: zeroAddress,\n          market: p.marketAddress,\n          swapPath: p.swapPath,\n          uiFeeReceiver: p.uiFeeReceiver || uiFeeReceiver || zeroAddress,\n        },\n        numbers: {\n          sizeDeltaUsd: p.sizeDeltaUsd,\n          initialCollateralDeltaAmount: p.initialCollateralDeltaAmount,\n          triggerPrice: convertToContractPrice(\n            p.triggerPrice ?? 0n,\n            p.indexToken.decimals\n          ),\n          acceptablePrice: convertToContractPrice(\n            acceptablePrice,\n            p.indexToken.decimals\n          ),\n          executionFee: p.executionFee,\n          callbackGasLimit: 0n,\n          minOutputAmount,\n          validFromTime: 0n,\n        },\n        orderType: p.orderType,\n        decreasePositionSwapType: p.decreasePositionSwapType,\n        isLong: p.isLong,\n        shouldUnwrapNativeToken: isNativeReceive,\n        autoCancel: p.autoCancel,\n        referralCode: p.referralCode || zeroHash,\n        dataList: p.dataList ?? [],\n      };\n\n      return [\n        { method: \"sendWnt\", params: [orderVaultAddress, p.executionFee] },\n        {\n          method: \"createOrder\",\n          params: [orderParams],\n        },\n      ];\n    }),\n  ];\n\n  return multicall.filter(Boolean).map((call) =>\n    encodeFunctionData({\n      abi: abis.ExchangeRouter as any,\n      functionName: call!.method as any,\n      args: call!.params,\n    })\n  );\n}\n\nexport function getBatchRequiredActions(\n  orderParams: BatchOrderTxnParams | undefined\n) {\n  if (!orderParams) {\n    return 0;\n  }\n\n  return (\n    orderParams.createOrderParams.length +\n    orderParams.updateOrderParams.length +\n    orderParams.cancelOrderParams.length\n  );\n}\n\nexport function getBatchSwapsCount(\n  orderParams: BatchOrderTxnParams | undefined\n) {\n  if (!orderParams) {\n    return 0;\n  }\n\n  return orderParams.createOrderParams.reduce((acc, co) => {\n    return acc + co.orderPayload.addresses.swapPath.length;\n  }, 0);\n}\n\nexport function getIsEmptyBatch(orderParams: BatchOrderTxnParams | undefined) {\n  if (!orderParams) {\n    return true;\n  }\n\n  if (getBatchRequiredActions(orderParams) === 0) {\n    return true;\n  }\n\n  const hasEmptyOrder = orderParams.createOrderParams.some(\n    (o) =>\n      o.orderPayload.numbers.sizeDeltaUsd === 0n &&\n      o.orderPayload.numbers.initialCollateralDeltaAmount === 0n\n  );\n\n  return hasEmptyOrder;\n}\n\nexport function getBatchIsNativePayment(orderParams: BatchOrderTxnParams) {\n  return orderParams.createOrderParams.some(\n    (o) => o.tokenTransfersParams?.isNativePayment\n  );\n}\n\nexport function getIsInvalidBatchReceiver(\n  batchParams: BatchOrderTxnParams,\n  signerAddress: string\n) {\n  return batchParams.createOrderParams.some(\n    (co) => co.orderPayload.addresses.receiver !== signerAddress\n  );\n}\n"]}