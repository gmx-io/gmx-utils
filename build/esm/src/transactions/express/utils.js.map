{"version":3,"sources":["../../../../../src/transactions/express/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourcesContent":["import { Address, encodeAbiParameters, keccak256 } from \"viem\";\n\nimport { abis } from \"abis\";\nimport type { ContractsChainId, SourceChainId } from \"configs/chains\";\nimport { BOTANIX } from \"configs/chains\";\nimport { ContractName, getContract } from \"configs/contracts\";\nimport { convertTokenAddress, NATIVE_TOKEN_ADDRESS } from \"configs/tokens\";\nimport { ExternalSwapQuote } from \"domain/externalSwap/types\";\nimport { getBestSwapStrategy } from \"domain/externalSwap/utils\";\nimport type { MarketsInfoData } from \"domain/markets/types\";\nimport { getOppositeCollateral } from \"domain/markets/utils\";\nimport { getSwapAmountsByToValue } from \"domain/swap/swapValues\";\nimport type { FindSwapPath, SwapAmounts } from \"domain/swap/types\";\nimport type {\n  SignedTokenPermit,\n  TokenData,\n  TokensAllowanceData,\n} from \"domain/tokens/types\";\nimport { getByKey } from \"lib/objects\";\nimport { nowInSeconds } from \"lib/time\";\n\nimport type {\n  GasPaymentParams,\n  GasPaymentValidations,\n  RawRelayParamsPayload,\n  RelayFeePayload,\n  RelayParamsPayload,\n} from \"./types\";\nimport {\n  combineExternalCalls,\n  type ExternalCallsPayload,\n  getEmptyExternalCallsPayload,\n  getExternalCallsPayload,\n} from \"../batch/payloads/orderTransactions\";\n\nexport function getExpressContractAddress(\n  chainId: ContractsChainId,\n  {\n    isSubaccount,\n    isMultichain,\n    scope,\n  }: {\n    isSubaccount?: boolean;\n    isMultichain?: boolean;\n    scope?: \"glv\" | \"gm\" | \"transfer\" | \"claims\" | \"order\" | \"subaccount\";\n  }\n): Address {\n  let contractName: ContractName;\n  if (isMultichain) {\n    switch (scope) {\n      case \"claims\":\n        contractName = \"MultichainClaimsRouter\";\n        break;\n      case \"order\":\n        contractName = \"MultichainOrderRouter\";\n        break;\n      case \"subaccount\":\n        contractName = \"MultichainSubaccountRouter\";\n        break;\n      case \"glv\":\n        contractName = \"MultichainGlvRouter\";\n        break;\n      case \"gm\":\n        contractName = \"MultichainGmRouter\";\n        break;\n      case \"transfer\":\n        contractName = \"MultichainTransferRouter\";\n        break;\n      default:\n        throw new Error(`Invalid scope: ${scope}`);\n    }\n  } else {\n    if (isSubaccount) {\n      contractName = \"SubaccountGelatoRelayRouter\";\n    } else {\n      contractName = \"GelatoRelayRouter\";\n    }\n  }\n\n  return getContract(chainId, contractName);\n}\n\nexport type SignatureDomain = {\n  name: string;\n  version: string;\n  chainId: number;\n  verifyingContract: Address;\n};\n\nexport function getGelatoRelayRouterDomain(\n  chainId: SourceChainId | ContractsChainId,\n  relayRouterAddress: string\n): SignatureDomain {\n  const name = \"GmxBaseGelatoRelayRouter\";\n\n  return {\n    name,\n    version: \"1\",\n    chainId,\n    verifyingContract: relayRouterAddress as Address,\n  };\n}\n\nexport function getOracleParams({\n  chainId,\n  tokenAddresses,\n}: {\n  chainId: ContractsChainId;\n  tokenAddresses: string[];\n}) {\n  const uniqTokenAddresses = Array.from(\n    new Set(\n      tokenAddresses.map((tokenAddress) =>\n        convertTokenAddress(chainId, tokenAddress, \"wrapped\")\n      )\n    )\n  );\n  const chainLinkPriceFeedProvider = getContract(\n    chainId,\n    \"ChainlinkPriceFeedProvider\"\n  );\n\n  return {\n    tokens: uniqTokenAddresses,\n    providers: Array(uniqTokenAddresses.length).fill(\n      chainLinkPriceFeedProvider\n    ),\n    data: Array(uniqTokenAddresses.length).fill(\"0x\"),\n  };\n}\n\nexport function getSwapPathOracleTokens({\n  marketsInfoData,\n  initialCollateralAddress,\n  swapPath,\n}: {\n  marketsInfoData: MarketsInfoData;\n  initialCollateralAddress: string;\n  swapPath: string[];\n}): string[] {\n  let currentToken = initialCollateralAddress;\n  const tokenAddresses: string[] = [initialCollateralAddress];\n\n  for (const marketAddress of swapPath) {\n    const marketInfo = getByKey(marketsInfoData, marketAddress);\n\n    if (!marketInfo) {\n      throw new Error(`Market not found for oracle params: ${marketAddress}`);\n    }\n\n    const tokenOut = getOppositeCollateral(marketInfo, currentToken);\n\n    if (!tokenOut?.address) {\n      throw new Error(\n        `Token not found for oracle params: ${initialCollateralAddress}`\n      );\n    }\n\n    currentToken = tokenOut.address;\n    tokenAddresses.push(currentToken, marketInfo.indexToken.address);\n  }\n\n  return tokenAddresses;\n}\n\nexport function getOracleParamsForRelayParams({\n  chainId,\n  gasPaymentTokenAddress,\n  relayerFeeTokenAddress,\n  feeSwapPath,\n  externalCalls,\n  marketsInfoData,\n}: {\n  chainId: ContractsChainId;\n  gasPaymentTokenAddress: string;\n  relayerFeeTokenAddress: string;\n  feeSwapPath: string[];\n  externalCalls: ExternalCallsPayload | undefined;\n  marketsInfoData: MarketsInfoData;\n}) {\n  const tokenAddresses = [gasPaymentTokenAddress, relayerFeeTokenAddress];\n\n  if (externalCalls) {\n    tokenAddresses.push(...externalCalls.sendTokens);\n  }\n\n  if (feeSwapPath.length) {\n    tokenAddresses.push(\n      ...getSwapPathOracleTokens({\n        marketsInfoData,\n        initialCollateralAddress: gasPaymentTokenAddress,\n        swapPath: feeSwapPath,\n      })\n    );\n  }\n\n  return getOracleParams({ chainId, tokenAddresses });\n}\n\nexport function getRelayerFeeParams({\n  chainId,\n  account,\n  gasPaymentToken,\n  relayerFeeToken,\n  relayerFeeAmount,\n  totalRelayerFeeTokenAmount,\n  gasPaymentTokenAsCollateralAmount,\n  transactionExternalCalls,\n  feeExternalSwapQuote,\n  findFeeSwapPath,\n}: {\n  chainId: ContractsChainId;\n  account: string;\n  relayerFeeAmount: bigint;\n  totalRelayerFeeTokenAmount: bigint;\n  relayerFeeToken: TokenData;\n  gasPaymentToken: TokenData;\n  gasPaymentTokenAsCollateralAmount: bigint;\n  findFeeSwapPath: FindSwapPath | undefined;\n  feeExternalSwapQuote: ExternalSwapQuote | undefined;\n  transactionExternalCalls: ExternalCallsPayload | undefined;\n}) {\n  const gasPaymentParams: GasPaymentParams = {\n    gasPaymentToken: gasPaymentToken,\n    relayFeeToken: relayerFeeToken,\n    gasPaymentTokenAddress: gasPaymentToken.address,\n    relayerFeeTokenAddress: relayerFeeToken.address,\n    relayerFeeAmount,\n    totalRelayerFeeTokenAmount,\n    gasPaymentTokenAmount: 0n,\n    gasPaymentTokenAsCollateralAmount,\n  };\n\n  let feeParams: RelayFeePayload;\n  let externalCalls =\n    transactionExternalCalls ?? getEmptyExternalCallsPayload();\n  let feeExternalSwapGasLimit = 0n;\n\n  if (relayerFeeToken.address === gasPaymentToken.address) {\n    feeParams = {\n      feeToken: relayerFeeToken.address,\n      feeAmount: totalRelayerFeeTokenAmount,\n      feeSwapPath: [],\n    };\n    gasPaymentParams.gasPaymentTokenAmount = totalRelayerFeeTokenAmount;\n  } else {\n    let feeSwapAmounts: SwapAmounts | undefined;\n\n    if (findFeeSwapPath) {\n      feeSwapAmounts = getSwapAmountsByToValue({\n        tokenIn: gasPaymentToken,\n        tokenOut: relayerFeeToken,\n        amountOut: totalRelayerFeeTokenAmount,\n        isLimit: false,\n        findSwapPath: findFeeSwapPath,\n        swapOptimizationOrder: [\"length\"],\n        uiFeeFactor: 0n,\n        marketsInfoData: undefined,\n        chainId,\n        externalSwapQuoteParams: undefined,\n      });\n    }\n\n    const bestFeeSwapStrategy = getBestSwapStrategy({\n      internalSwapAmounts: feeSwapAmounts,\n      externalSwapQuote: feeExternalSwapQuote,\n    });\n\n    if (bestFeeSwapStrategy?.swapPath) {\n      feeParams = {\n        feeToken: gasPaymentToken.address,\n        feeAmount: bestFeeSwapStrategy.amountIn,\n        feeSwapPath: bestFeeSwapStrategy.swapPath,\n      };\n      gasPaymentParams.gasPaymentTokenAmount = bestFeeSwapStrategy.amountIn;\n      gasPaymentParams.totalRelayerFeeTokenAmount =\n        bestFeeSwapStrategy.amountOut;\n    } else if (bestFeeSwapStrategy?.externalSwapQuote) {\n      externalCalls = combineExternalCalls([\n        externalCalls,\n        getExternalCallsPayload({\n          chainId,\n          account,\n          quote: bestFeeSwapStrategy.externalSwapQuote,\n        }),\n      ]);\n      feeExternalSwapGasLimit =\n        bestFeeSwapStrategy.externalSwapQuote.txnData.estimatedGas;\n      feeParams = {\n        feeToken: relayerFeeToken.address,\n        feeAmount: 0n,\n        feeSwapPath: [],\n      };\n      gasPaymentParams.gasPaymentTokenAmount =\n        bestFeeSwapStrategy.externalSwapQuote.amountIn;\n      gasPaymentParams.totalRelayerFeeTokenAmount =\n        bestFeeSwapStrategy.externalSwapQuote.amountOut;\n    } else {\n      return undefined;\n    }\n  }\n\n  return {\n    feeParams,\n    externalCalls,\n    feeExternalSwapGasLimit,\n    gasPaymentParams,\n  };\n}\n\nexport function getRawRelayerParams({\n  chainId,\n  gasPaymentTokenAddress,\n  relayerFeeTokenAddress,\n  feeParams,\n  externalCalls,\n  tokenPermits,\n  marketsInfoData,\n}: {\n  chainId: ContractsChainId;\n  gasPaymentTokenAddress: string;\n  relayerFeeTokenAddress: string;\n  feeParams: RelayFeePayload;\n  externalCalls: ExternalCallsPayload;\n  tokenPermits: SignedTokenPermit[];\n  marketsInfoData: MarketsInfoData;\n}): RawRelayParamsPayload {\n  const oracleParams = getOracleParamsForRelayParams({\n    chainId,\n    externalCalls,\n    feeSwapPath: feeParams.feeSwapPath,\n    gasPaymentTokenAddress,\n    relayerFeeTokenAddress,\n    marketsInfoData,\n  });\n\n  const relayParamsPayload: RawRelayParamsPayload = {\n    oracleParams,\n    tokenPermits,\n    externalCalls,\n    fee: feeParams,\n    desChainId: BigInt(chainId),\n    userNonce: BigInt(nowInSeconds()),\n  };\n\n  return relayParamsPayload;\n}\n\nexport function hashRelayParams(relayParams: RelayParamsPayload) {\n  const encoded = encodeAbiParameters(abis.RelayParams, [\n    {\n      tokens: relayParams.oracleParams.tokens as readonly `0x${string}`[],\n      providers: relayParams.oracleParams.providers as readonly `0x${string}`[],\n      data: relayParams.oracleParams.data as readonly `0x${string}`[],\n    },\n    {\n      sendTokens: relayParams.externalCalls\n        .sendTokens as readonly `0x${string}`[],\n      sendAmounts: relayParams.externalCalls.sendAmounts,\n      externalCallTargets: relayParams.externalCalls\n        .externalCallTargets as readonly `0x${string}`[],\n      externalCallDataList: relayParams.externalCalls\n        .externalCallDataList as readonly `0x${string}`[],\n      refundTokens: relayParams.externalCalls\n        .refundTokens as readonly `0x${string}`[],\n      refundReceivers: relayParams.externalCalls\n        .refundReceivers as readonly `0x${string}`[],\n    },\n    relayParams.tokenPermits as readonly {\n      owner: `0x${string}`;\n      spender: `0x${string}`;\n      value: bigint;\n      deadline: bigint;\n      v: number;\n      r: `0x${string}`;\n      s: `0x${string}`;\n      token: `0x${string}`;\n    }[],\n    {\n      feeToken: relayParams.fee.feeToken as `0x${string}`,\n      feeAmount: relayParams.fee.feeAmount,\n      feeSwapPath: relayParams.fee.feeSwapPath as readonly `0x${string}`[],\n    },\n    relayParams.userNonce,\n    relayParams.deadline,\n    relayParams.desChainId,\n  ]);\n\n  const hash = keccak256(encoded);\n\n  return hash;\n}\n\nexport function getNeedTokenApprove(\n  tokenAllowanceData: TokensAllowanceData | undefined,\n  tokenAddress: string | undefined,\n  amountToSpend: bigint | undefined,\n  permits: SignedTokenPermit[]\n): boolean {\n  if (\n    tokenAddress === NATIVE_TOKEN_ADDRESS ||\n    amountToSpend === undefined ||\n    amountToSpend <= 0n\n  ) {\n    return false;\n  }\n\n  if (\n    !tokenAllowanceData ||\n    !tokenAddress ||\n    tokenAllowanceData?.[tokenAddress] === undefined\n  ) {\n    return true;\n  }\n\n  const shouldApprove = amountToSpend > tokenAllowanceData[tokenAddress];\n  const signedPermit = permits.find(\n    (permit) =>\n      permit.token === tokenAddress &&\n      BigInt(permit.value) >= amountToSpend &&\n      Number(permit.deadline) > nowInSeconds()\n  );\n\n  return shouldApprove && !signedPermit;\n}\n\nexport function getGasPaymentValidations({\n  gasPaymentToken,\n  gasPaymentTokenAmount,\n  gasPaymentTokenAsCollateralAmount,\n  gasPaymentAllowanceData,\n  tokenPermits,\n  isGmxAccount,\n}: {\n  gasPaymentToken: TokenData;\n  gasPaymentTokenAmount: bigint;\n  gasPaymentTokenAsCollateralAmount: bigint;\n  gasPaymentAllowanceData: TokensAllowanceData;\n  tokenPermits: SignedTokenPermit[];\n  isGmxAccount: boolean;\n}): GasPaymentValidations {\n  const gasTokenAmountWithBuffer = (gasPaymentTokenAmount * 13n) / 10n;\n  const totalGasPaymentTokenAmount =\n    gasPaymentTokenAsCollateralAmount + gasTokenAmountWithBuffer;\n\n  const tokenBalance = isGmxAccount\n    ? gasPaymentToken.gmxAccountBalance\n    : gasPaymentToken.walletBalance;\n\n  const isOutGasTokenBalance =\n    tokenBalance === undefined || totalGasPaymentTokenAmount > tokenBalance;\n\n  const needGasPaymentTokenApproval = isGmxAccount\n    ? false\n    : getNeedTokenApprove(\n        gasPaymentAllowanceData,\n        gasPaymentToken?.address,\n        totalGasPaymentTokenAmount,\n        tokenPermits\n      );\n\n  return {\n    isOutGasTokenBalance,\n    needGasPaymentTokenApproval,\n    isValid: !isOutGasTokenBalance && !needGasPaymentTokenApproval,\n  };\n}\n\nexport function getIsValidExpressParams({\n  chainId,\n  gasPaymentValidations,\n  isSponsoredCall,\n}: {\n  chainId: number;\n  isSponsoredCall: boolean;\n  gasPaymentValidations: GasPaymentValidations;\n}): boolean {\n  if (chainId === BOTANIX && !isSponsoredCall) {\n    return false;\n  }\n\n  return gasPaymentValidations.isValid;\n}\n\nexport function getOrderRelayRouterAddress(\n  chainId: ContractsChainId,\n  isSubaccount: boolean,\n  isMultichain: boolean\n): string {\n  let contractName: ContractName;\n  if (isMultichain) {\n    if (isSubaccount) {\n      contractName = \"MultichainSubaccountRouter\";\n    } else {\n      contractName = \"MultichainOrderRouter\";\n    }\n  } else {\n    if (isSubaccount) {\n      contractName = \"SubaccountGelatoRelayRouter\";\n    } else {\n      contractName = \"GelatoRelayRouter\";\n    }\n  }\n\n  return getContract(chainId, contractName);\n}\n"]}