{"version":3,"sources":["../../../../../src/transactions/express/oracleParamsUtils.ts"],"names":[],"mappings":";;;;;;AAUO,SAAS,eAAA,CAAgB;AAAA,EAC9B,OAAA;AAAA,EACA;AACF,CAAA,EAGG;AACD,EAAA,MAAM,kBAAA,GAAqB,IAAA;AAAA,IACzB,cAAA,CAAe,GAAA;AAAA,MAAI,CAAC,YAAA,KAClB,mBAAA,CAAoB,OAAA,EAAS,cAAc,SAAS;AAAA;AACtD,GACF;AACA,EAAA,MAAM,0BAAA,GAA6B,WAAA;AAAA,IACjC,OAAA;AAAA,IACA;AAAA,GACF;AAEA,EAAA,OAAO;AAAA,IACL,MAAA,EAAQ,kBAAA;AAAA,IACR,SAAA,EAAW,KAAA,CAAM,kBAAA,CAAmB,MAAM,CAAA,CAAE,IAAA;AAAA,MAC1C;AAAA,KACF;AAAA,IACA,MAAM,KAAA,CAAM,kBAAA,CAAmB,MAAM,CAAA,CAAE,KAAK,IAAI;AAAA,GAClD;AACF;AAEO,SAAS,6BAAA,CAA8B;AAAA,EAC5C,OAAA;AAAA,EACA,sBAAA;AAAA,EACA,sBAAA;AAAA,EACA,WAAA;AAAA,EACA,aAAA;AAAA,EACA;AACF,CAAA,EAOG;AACD,EAAA,MAAM,cAAA,GAAiB,CAAC,sBAAA,EAAwB,sBAAsB,CAAA;AAEtE,EAAA,IAAI,aAAA,EAAe;AACjB,IAAA,cAAA,CAAe,IAAA,CAAK,GAAG,aAAA,CAAc,UAAU,CAAA;AAAA,EACjD;AAEA,EAAA,IAAI,YAAY,MAAA,EAAQ;AACtB,IAAA,cAAA,CAAe,IAAA;AAAA,MACb,GAAG,uBAAA,CAAwB;AAAA,QACzB,eAAA;AAAA,QACA,wBAAA,EAA0B,sBAAA;AAAA,QAC1B,QAAA,EAAU;AAAA,OACX;AAAA,KACH;AAAA,EACF;AAEA,EAAA,OAAO,eAAA,CAAgB,EAAE,OAAA,EAAS,cAAA,EAAgB,CAAA;AACpD;AAEO,SAAS,uBAAA,CAAwB;AAAA,EACtC,eAAA;AAAA,EACA,wBAAA;AAAA,EACA;AACF,CAAA,EAIa;AACX,EAAA,IAAI,YAAA,GAAe,wBAAA;AACnB,EAAA,MAAM,cAAA,GAA2B,CAAC,wBAAwB,CAAA;AAE1D,EAAA,KAAA,MAAW,iBAAiB,QAAA,EAAU;AACpC,IAAA,MAAM,UAAA,GAAa,QAAA,CAAS,eAAA,EAAiB,aAAa,CAAA;AAE1D,IAAA,IAAI,CAAC,UAAA,EAAY;AACf,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,oCAAA,EAAuC,aAAa,CAAA,CAAE,CAAA;AAAA,IACxE;AAEA,IAAA,MAAM,QAAA,GAAW,qBAAA,CAAsB,UAAA,EAAY,YAAY,CAAA;AAE/D,IAAA,IAAI,CAAC,UAAU,OAAA,EAAS;AACtB,MAAA,MAAM,IAAI,KAAA;AAAA,QACR,sCAAsC,wBAAwB,CAAA;AAAA,OAChE;AAAA,IACF;AAEA,IAAA,YAAA,GAAe,QAAA,CAAS,OAAA;AACxB,IAAA,cAAA,CAAe,IAAA,CAAK,YAAA,EAAc,UAAA,CAAW,UAAA,CAAW,OAAO,CAAA;AAAA,EACjE;AAEA,EAAA,OAAO,cAAA;AACT","file":"oracleParamsUtils.js","sourcesContent":["import uniq from \"lodash/uniq\";\n\nimport type { ContractsChainId } from \"configs/chains\";\nimport { getContract } from \"configs/contracts\";\nimport { convertTokenAddress } from \"configs/tokens\";\nimport { MarketsInfoData } from \"domain/markets/types\";\nimport { getOppositeCollateral } from \"domain/markets/utils\";\nimport { getByKey } from \"lib/objects\";\nimport { ExternalCallsPayload } from \"transactions/batch/payloads/orderTransactions\";\n\nexport function getOracleParams({\n  chainId,\n  tokenAddresses,\n}: {\n  chainId: ContractsChainId;\n  tokenAddresses: string[];\n}) {\n  const uniqTokenAddresses = uniq(\n    tokenAddresses.map((tokenAddress) =>\n      convertTokenAddress(chainId, tokenAddress, \"wrapped\")\n    )\n  );\n  const chainLinkPriceFeedProvider = getContract(\n    chainId,\n    \"ChainlinkPriceFeedProvider\"\n  );\n\n  return {\n    tokens: uniqTokenAddresses,\n    providers: Array(uniqTokenAddresses.length).fill(\n      chainLinkPriceFeedProvider\n    ),\n    data: Array(uniqTokenAddresses.length).fill(\"0x\"),\n  };\n}\n\nexport function getOracleParamsForRelayParams({\n  chainId,\n  gasPaymentTokenAddress,\n  relayerFeeTokenAddress,\n  feeSwapPath,\n  externalCalls,\n  marketsInfoData,\n}: {\n  chainId: ContractsChainId;\n  gasPaymentTokenAddress: string;\n  relayerFeeTokenAddress: string;\n  feeSwapPath: string[];\n  externalCalls: ExternalCallsPayload | undefined;\n  marketsInfoData: MarketsInfoData;\n}) {\n  const tokenAddresses = [gasPaymentTokenAddress, relayerFeeTokenAddress];\n\n  if (externalCalls) {\n    tokenAddresses.push(...externalCalls.sendTokens);\n  }\n\n  if (feeSwapPath.length) {\n    tokenAddresses.push(\n      ...getSwapPathOracleTokens({\n        marketsInfoData,\n        initialCollateralAddress: gasPaymentTokenAddress,\n        swapPath: feeSwapPath,\n      })\n    );\n  }\n\n  return getOracleParams({ chainId, tokenAddresses });\n}\n\nexport function getSwapPathOracleTokens({\n  marketsInfoData,\n  initialCollateralAddress,\n  swapPath,\n}: {\n  marketsInfoData: MarketsInfoData;\n  initialCollateralAddress: string;\n  swapPath: string[];\n}): string[] {\n  let currentToken = initialCollateralAddress;\n  const tokenAddresses: string[] = [initialCollateralAddress];\n\n  for (const marketAddress of swapPath) {\n    const marketInfo = getByKey(marketsInfoData, marketAddress);\n\n    if (!marketInfo) {\n      throw new Error(`Market not found for oracle params: ${marketAddress}`);\n    }\n\n    const tokenOut = getOppositeCollateral(marketInfo, currentToken);\n\n    if (!tokenOut?.address) {\n      throw new Error(\n        `Token not found for oracle params: ${initialCollateralAddress}`\n      );\n    }\n\n    currentToken = tokenOut.address;\n    tokenAddresses.push(currentToken, marketInfo.indexToken.address);\n  }\n\n  return tokenAddresses;\n}\n"]}