{"version":3,"sources":["../../../../../src/transactions/simulation/simulation.ts"],"names":[],"mappings":"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","file":"simulation.js","sourcesContent":["import {\n  createPublicClient,\n  decodeFunctionResult,\n  encodeFunctionData,\n  http,\n  type PublicClient,\n  withRetry,\n} from \"viem\";\nimport { zeroAddress } from \"viem\";\n\nimport { abis } from \"abis\";\nimport type { ContractsChainId } from \"configs/chains\";\nimport { getViemChain } from \"configs/chains\";\nimport { getContract } from \"configs/contracts\";\nimport { isGlvEnabled } from \"configs/glv\";\nimport { convertTokenAddress } from \"configs/tokens\";\nimport { convertToContractPrice } from \"domain/pricing/contractPrice\";\nimport { SwapPricingType } from \"domain/swap/types\";\nimport { SignedTokenPermit } from \"domain/tokens/types\";\nimport { TokenPrices, TokensData } from \"domain/tokens/types\";\nimport { getTokenData } from \"domain/tokens/utils\";\nimport {\n  CustomErrorName,\n  ErrorData,\n  TxErrorType,\n  extendError,\n  isContractError,\n  parseError,\n} from \"lib/errors\";\nimport {\n  CreateOrderTxnParams,\n  ExternalCallsPayload,\n} from \"transactions/batch/payloads/orderTransactions\";\n\nexport type BlockTimestampData = {\n  blockTimestamp: bigint;\n  localTimestamp: bigint;\n};\n\nexport type BlockTimestampResult = {\n  blockTimestampData?: BlockTimestampData;\n};\n\nexport function adjustBlockTimestamp(blockTimestampData: BlockTimestampData) {\n  const nowInSeconds = BigInt(Math.floor(Date.now() / 1000));\n\n  return (\n    blockTimestampData.blockTimestamp +\n    (nowInSeconds - blockTimestampData.localTimestamp)\n  );\n}\n\nexport type SimulateExecuteParams = {\n  account: string;\n  createMulticallPayload: string[];\n  prices: SimulationPrices;\n  value: bigint;\n  tokenPermits: SignedTokenPermit[];\n  isExpress: boolean;\n  method?:\n    | \"simulateExecuteLatestDeposit\"\n    | \"simulateExecuteLatestWithdrawal\"\n    | \"simulateExecuteLatestOrder\"\n    | \"simulateExecuteLatestShift\"\n    | \"simulateExecuteLatestGlvDeposit\"\n    | \"simulateExecuteLatestGlvWithdrawal\";\n  swapPricingType?: SwapPricingType;\n  blockTimestampData: BlockTimestampData | undefined;\n};\n\nexport function isSimulationPassed(errorData: ErrorData) {\n  return isContractError(errorData, CustomErrorName.EndOfOracleSimulation);\n}\n\nfunction getPublicClient(chainId: ContractsChainId): PublicClient {\n  const chain = getViemChain(chainId);\n  const rpcUrl = chain.rpcUrls.default.http[0];\n\n  return createPublicClient({\n    chain,\n    transport: http(rpcUrl),\n  });\n}\n\nfunction getExpressPublicClient(chainId: ContractsChainId): PublicClient {\n  const chain = getViemChain(chainId);\n  const rpcUrl = chain.rpcUrls.default.http[0];\n\n  return createPublicClient({\n    chain,\n    transport: http(rpcUrl),\n  });\n}\n\nexport async function simulateExecution(\n  chainId: ContractsChainId,\n  p: SimulateExecuteParams\n) {\n  const publicClient = p.isExpress\n    ? getExpressPublicClient(chainId) ?? getPublicClient(chainId)\n    : getPublicClient(chainId);\n\n  const multicallAddress = getContract(chainId, \"Multicall\");\n  const exchangeRouterAddress = getContract(chainId, \"ExchangeRouter\");\n  const glvRouterAddress = isGlvEnabled(chainId)\n    ? getContract(chainId, \"GlvRouter\")\n    : zeroAddress;\n\n  let blockTimestamp: bigint;\n  let blockTag: \"latest\" | bigint;\n\n  if (p.blockTimestampData) {\n    blockTimestamp = adjustBlockTimestamp(p.blockTimestampData);\n    blockTag = \"latest\";\n  } else {\n    const getCurrentBlockTimestampData = encodeFunctionData({\n      abi: abis.Multicall,\n      functionName: \"getCurrentBlockTimestamp\",\n    });\n\n    const result = await publicClient.simulateContract({\n      address: multicallAddress,\n      abi: abis.Multicall,\n      functionName: \"blockAndAggregate\",\n      args: [\n        [\n          {\n            target: multicallAddress as `0x${string}`,\n            callData: getCurrentBlockTimestampData,\n          },\n        ],\n      ],\n      account: p.account as `0x${string}`,\n    });\n\n    const [blockNumber, , returnData] = result.result;\n\n    const decoded = decodeFunctionResult({\n      abi: abis.Multicall,\n      functionName: \"getCurrentBlockTimestamp\",\n      data: returnData[0].returnData,\n    });\n\n    blockTimestamp = decoded as bigint;\n    blockTag = blockNumber;\n  }\n\n  const priceTimestamp = blockTimestamp + 120n;\n  const method = p.method || \"simulateExecuteLatestOrder\";\n\n  const isGlv =\n    method === \"simulateExecuteLatestGlvDeposit\" ||\n    method === \"simulateExecuteLatestGlvWithdrawal\";\n\n  const simulationPriceParams = {\n    primaryTokens: p.prices.primaryTokens as readonly `0x${string}`[],\n    primaryPrices: p.prices.primaryPrices as readonly {\n      min: bigint;\n      max: bigint;\n    }[],\n    minTimestamp: priceTimestamp,\n    maxTimestamp: priceTimestamp,\n  };\n\n  let simulationPayloadData: string[] = [];\n\n  if (p.tokenPermits.length > 0) {\n    const externalCalls: ExternalCallsPayload = {\n      sendTokens: [],\n      sendAmounts: [],\n      externalCallTargets: [],\n      externalCallDataList: [],\n      refundTokens: [],\n      refundReceivers: [],\n    };\n\n    for (const permit of p.tokenPermits) {\n      externalCalls.externalCallTargets.push(permit.token);\n      externalCalls.externalCallDataList.push(\n        encodeFunctionData({\n          abi: abis.ERC20PermitInterface,\n          functionName: \"permit\",\n          args: [\n            permit.owner,\n            permit.spender,\n            permit.value,\n            permit.deadline,\n            permit.v,\n            permit.r,\n            permit.s,\n          ],\n        })\n      );\n    }\n\n    simulationPayloadData.push(\n      encodeFunctionData({\n        abi: abis.ExchangeRouter,\n        functionName: \"makeExternalCalls\",\n        args: [\n          externalCalls.externalCallTargets.map(\n            (t) => t as `0x${string}`\n          ) as readonly `0x${string}`[],\n          externalCalls.externalCallDataList.map(\n            (d) => d as `0x${string}`\n          ) as readonly `0x${string}`[],\n          externalCalls.refundTokens.map(\n            (t) => t as `0x${string}`\n          ) as readonly `0x${string}`[],\n          externalCalls.refundReceivers.map(\n            (r) => r as `0x${string}`\n          ) as readonly `0x${string}`[],\n        ],\n      })\n    );\n  }\n\n  simulationPayloadData.push(...p.createMulticallPayload);\n\n  const routerAddress = isGlv ? glvRouterAddress : exchangeRouterAddress;\n  const routerAbi = isGlv ? abis.GlvRouter : abis.ExchangeRouter;\n\n  if (method === \"simulateExecuteLatestWithdrawal\") {\n    if (p.swapPricingType === undefined) {\n      throw new Error(\n        \"swapPricingType is required for simulateExecuteLatestWithdrawal\"\n      );\n    }\n\n    simulationPayloadData.push(\n      encodeFunctionData({\n        abi: routerAbi,\n        functionName: \"simulateExecuteLatestWithdrawal\",\n        args: [simulationPriceParams, p.swapPricingType],\n      })\n    );\n  } else if (method === \"simulateExecuteLatestDeposit\") {\n    simulationPayloadData.push(\n      encodeFunctionData({\n        abi: routerAbi,\n        functionName: \"simulateExecuteLatestDeposit\",\n        args: [simulationPriceParams],\n      })\n    );\n  } else if (method === \"simulateExecuteLatestOrder\") {\n    simulationPayloadData.push(\n      encodeFunctionData({\n        abi: routerAbi,\n        functionName: \"simulateExecuteLatestOrder\",\n        args: [simulationPriceParams],\n      })\n    );\n  } else if (method === \"simulateExecuteLatestShift\") {\n    simulationPayloadData.push(\n      encodeFunctionData({\n        abi: routerAbi,\n        functionName: \"simulateExecuteLatestShift\",\n        args: [simulationPriceParams],\n      })\n    );\n  } else if (method === \"simulateExecuteLatestGlvDeposit\") {\n    simulationPayloadData.push(\n      encodeFunctionData({\n        abi: abis.GlvRouter,\n        functionName: \"simulateExecuteLatestGlvDeposit\",\n        args: [simulationPriceParams],\n      })\n    );\n  } else if (method === \"simulateExecuteLatestGlvWithdrawal\") {\n    simulationPayloadData.push(\n      encodeFunctionData({\n        abi: abis.GlvRouter,\n        functionName: \"simulateExecuteLatestGlvWithdrawal\",\n        args: [simulationPriceParams],\n      })\n    );\n  } else {\n    throw new Error(`Unknown method: ${method}`);\n  }\n\n  try {\n    await withRetry(\n      () => {\n        return publicClient.simulateContract({\n          address: routerAddress,\n          abi: routerAbi,\n          functionName: \"multicall\",\n          args: [\n            simulationPayloadData.map(\n              (d) => d as `0x${string}`\n            ) as readonly `0x${string}`[],\n          ],\n          value: p.value,\n          blockNumber: blockTag === \"latest\" ? undefined : blockTag,\n          account: p.account as `0x${string}`,\n        });\n      },\n      {\n        retryCount: 2,\n        delay: 200,\n        shouldRetry: ({ error }) => {\n          const errorData = parseError(error);\n          return (\n            errorData?.errorMessage?.includes(\"unsupported block number\") ||\n            errorData?.errorMessage\n              ?.toLowerCase()\n              .includes(\"failed to fetch\") ||\n            errorData?.errorMessage?.toLowerCase().includes(\"load failed\") ||\n            errorData?.errorMessage\n              ?.toLowerCase()\n              .includes(\"an error has occurred\") ||\n            false\n          );\n        },\n      }\n    );\n  } catch (txnError: any) {\n    const errorData = parseError(txnError);\n\n    const isPassed = errorData && isSimulationPassed(errorData);\n    const shouldIgnoreExpressNativeTokenBalance =\n      errorData?.txErrorType === TxErrorType.NotEnoughFunds && p.isExpress;\n\n    if (isPassed || shouldIgnoreExpressNativeTokenBalance) {\n      return;\n    } else {\n      throw extendError(txnError, {\n        errorContext: \"simulation\",\n      });\n    }\n  }\n}\n\nexport function getOrdersTriggerPriceOverrides(\n  createOrderPayloads: CreateOrderTxnParams<any>[]\n) {\n  const overrides: PriceOverride[] = [];\n\n  for (const co of createOrderPayloads) {\n    if (\n      co.orderPayload.numbers.triggerPrice !== 0n &&\n      \"indexTokenAddress\" in co.params\n    ) {\n      overrides.push({\n        tokenAddress: co.params.indexTokenAddress,\n        contractPrices: {\n          minPrice: co.orderPayload.numbers.triggerPrice,\n          maxPrice: co.orderPayload.numbers.triggerPrice,\n        },\n      });\n    }\n  }\n\n  return overrides;\n}\n\nexport type SimulationPrices = ReturnType<typeof getSimulationPrices>;\n\nexport type PriceOverride = {\n  tokenAddress: string;\n  contractPrices?: TokenPrices;\n  prices?: TokenPrices;\n};\n\nexport function getSimulationPrices(\n  chainId: number,\n  tokensData: TokensData,\n  overrides: PriceOverride[]\n) {\n  const tokenAddresses = Object.keys(tokensData);\n  const primaryTokens: string[] = [];\n  const primaryPrices: { min: bigint; max: bigint }[] = [];\n\n  for (const address of tokenAddresses) {\n    const token = getTokenData(tokensData, address);\n    const convertedAddress = convertTokenAddress(chainId, address, \"wrapped\");\n\n    if (!token?.prices || primaryTokens.includes(convertedAddress)) {\n      continue;\n    }\n\n    primaryTokens.push(convertedAddress);\n\n    const currentPrice = {\n      min: convertToContractPrice(token.prices.minPrice, token.decimals),\n      max: convertToContractPrice(token.prices.maxPrice, token.decimals),\n    };\n\n    const override = overrides.find((o) => o.tokenAddress === address);\n    const primaryOverriddenPrice = override?.contractPrices ?? override?.prices;\n\n    if (primaryOverriddenPrice) {\n      primaryPrices.push({\n        min: primaryOverriddenPrice.minPrice,\n        max: primaryOverriddenPrice.maxPrice,\n      });\n    } else {\n      primaryPrices.push(currentPrice);\n    }\n  }\n\n  return {\n    primaryTokens,\n    primaryPrices,\n  };\n}\n"]}